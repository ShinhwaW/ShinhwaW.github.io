{"pages":[{"title":"Hello World","url":"/2019/03/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":""},{"title":"OS Summary - 启动、中断、异常和系统调用","url":"/2018/12/02/os-lecture-3-summary/","text":"课程内容概述 系统启动过程 BIOS 的原理 BIOS 的一些具体工作 系统启动规范 中断，异常和系统调用 中断 系统调用 系统启动过程BIOS 的基本功能 计算机刚刚启动时的内存布局如图： 地址 用途 (4GB - 64KB) ~ 4GB 实际BIOS ROM 1MB ~ (4GB - 64KB) 空闲空间 640KB ~ 1MB 视频内存，BIOS启动固件（映射） 0 ~ 640KB 空闲空间 （这是一个非常简略的示意图，具体请见Memory Map (x86))） 这一复杂的映射机制是为了保证向后兼容而设计的。在8086时代，内存只有1MB大小，此时，BIOS的代码固化在EPROM中，且EPROM被编址在1MB内存地址空间的最高64KB中。PC加电后，CS寄存器初始化为0xF000，IP寄存器初始化为0xFFF0，所以CPU要执行的第一条指令的地址为CS:IP=0xF000:0XFFF0（ Segment:Offset表示） =0xFFFF0（ Linear表示） 。这个地址位于被固化的EPROM中，该地址存储了一条指令，它是一个长跳转指令JMP F000:E05B。这样就开启了BIOS的执行过程。 到了32位的80386 CPU时代，内存空间扩大到了4G，多了段机制和页机制。如果仍然把BIOS启动固件编址在0xF0000起始的64KB内存地址空间内，就会把整个物理内存地址空间隔离成不连续的两段，一段是0xF0000以前的地址，一段是1MB以后的地址，这很不协调。为此，intel采用了一个折中的方案：默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成0xF000，将它的shadow register的Base值初始化设置为0xFFFF0000，EIP寄存器初始化设置为0x0000FFF0。所以机器执行的第一条指令的物理地址是0xFFFFFFF0。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址0xFFFFFFF0处的指令还是一条长跳转指令jmp F000:E05B。注意，这个长跳转指令会更新CS寄存器和它的shadowregister，即执行jmp F000:E05B后，CS将被更新成0xF000。表面上看CS其实没有变化，但CS的shadow register被更新为另外一个值了，它的Base域被更新成0x000F0000，此时形成的物理地址为Base+EIP=0x000FE05B，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M以内了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以PC机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086 CPU初始化控制流，保证了向下兼容。 上述说明指出，在 CPU 启动之后，它一直处于实模式之下，执行的第一条指令是 jmp F000:E05B ，跳转到 BIOS 程序中。此时，PC = 16 * CS + IP，系统地址空间只有 20 位（1MB）。 20 位地址空间：1MB 这之后 BIOS 会进入以下工作： 在实模式下提供基本输入输出方法 通过中断调用实现 只能在实模式下使用，操作系统无法使用 运行自检程序 用户选择引导设备（从什么介质启动） 将 BootLoader 从磁盘的引导扇区加载到内存中 0x7c00 开始的位置 跳转到 BootLoader的位置：CS:IP=0000:7C00 系统设置信息 开机后自检程序 系统自启动程序等 这之后，控制权就交给 BootLoader： 切换到保护模式 将操作系统的代码和数据从硬盘加载到内存中（因为 BIOS 无法处理硬件的文件系统） 跳转到操作系统的起始地址 加载之后的内存布局如下表： 地址 用途 (4GB - 64KB) ~ 4GB 实际BIOS ROM ? ~ (4GB - 64KB) 空闲空间 1MB ~ ? 操作系统 640KB ~ 1MB 视频内存，BIOS启动固件（映射） ? ~ 640KB 空闲空间 0x7c00 ~ ? bootloader 0 ~ 0x7c00 BIOS数据 最后，bootloader把控制权转交给操作系统。 BIOS 的一些具体工作BISO 本身的初始化内容 硬件自检 POST 检测系统中内存和显卡等关键部件的存在和工作状态 查找并执行显卡等接口卡 BIOS，进行设备初始化 执行系统 BIOS，进行系统检测：检测和配置系统中安装的即插即用设备 更新 CMOS 中的扩展系统配置数据 ESCD 按指定启动顺序从硬盘、软盘等设备启动 BIOS 如何读取 BootLoader Wiki上是这么说的： 系统开机或者重启。 BIOS加电（台湾用语：开机）自检（Power On Self Test – POST）。BIOS执行内存地址为FFFF:0000H处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件（包括内存）进行检查。 读取主引导记录（MBR）。当BIOS检查到硬件正常并与CMOS中的设置相符后，按照CMOS中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区（也就是MBR扇区）读入内存地址为0000:7C00H处。 检查0000:7DFEH-0000:7DFFH（MBR的结束标志位）是否等于55AAH，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。 当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。启动设备的MBR将自己复制到0000:0600H处，然后继续执行。根据MBR中的引导代码启动引导程序。 事实上，BIOS不仅检查0000:7DFEH-0000:7DFFH（MBR的结束标志位）是否等于55AAH，往往还对磁盘是否有写保护、主引导扇区中是否存在活动分区等进行检查。如果发现磁盘有写保护，则显示磁盘写保护出错信息；如果发现磁盘中不存在活动分区，则显示类似如下的信息“Remove disk or other media Press any key to restart”。 标准MBR的结构如下： 地址（十进制） 描述 长度（字节） 0 代码区 440（最大446） 440 选用磁盘标志 4 444 一般为空值; 0x0000 2 446 标准MBR分区表规划（四个16 byte的主分区表入口） 64 510 MBR有效标志：0x55AA 2 系统启动规范课程中还讲到了BIOS-MBR、BIOS-GPT、PXE和UEFI等系统启动规范，其中UEFI似乎还更重要一点。这似乎是通用的现代BIOS标准。 中断、异常和系统调用定义： 系统调用（System Call)：应用程序主动向操作系统发出的服务请求 异常（Exception)：非法指令或其他原因导致当前指令执行失败（如：内存出错）后的处理请求 中单（Hardware Interrupt）：来自硬件设备的处理请求 它们的相同之处是，采用的处理方式大致相同。无论发生异常、中断、还是系统调用，都需要由硬件保存现场和中断号，转到内核态，进入中断向量表，查找对应的设备驱动程序地址（异常）、异常服务例程地址（异常），或找到系统调用表，并在其中查找对应的系统调用实现的起始地址。处理完毕之后，在进行现场切换，会到用户态继续执行程序（如果可能继续的话）。它们的区别如下表： 源头 响应方式 处理机制 中断 外设 异步 持续，对用户应用程序是透明的 异常 应用程序或内核意想不到的行为 同步 杀死或重新执行意想不到的应用程序指令 系统调用 应用程序请求操作提供服务 异步或同步 等待和持续 这三者的处理有时可以嵌套，有时不可以。 相比于用户态的函数调用，中断和异常的开销是比较大的，因为他们需要进行： 特权级的切换 建立内核堆栈 验证参数的合法性（防止对内核的恶意攻击） 内核态需要映射到用户态的地址空间（因为需要访问用户程序的一些内容），因此㤇更新页面映射权限 内核态也拥有独立的地址空间，因此 TLB 会失效 中断的具体处理机制 中断处理的过程需要软件和硬件的配合（虽然系统调用和异常也是。。。） 硬件处理内容包括： 在 CPU 初始化时设置中断使能表示 依据内部或者外部事件设置中断标志 依据中断向量调用对应的中断服务例程 软件处理内容包括： 现场保存（编译器） 终端服务处理（服务例程） 清楚中断标记（服务例程）（系统调用只占用一个中断向量，另有系统调用表） 现场恢复（编译器） 系统调用 特点 系统调用时操作系统服务的编程接口 通常由高级语言编写（ C 或 C ++） 程序访问系统调用通常是高层次的 API 接口（比如封装到标准 C 库一）而不是直接进行系统调用 3中最常用的应用程序编程接口（API): Win32 API：Windows POSIX API：UNIX、LINUX、Mac OS X Java API：用于JAVA虚拟机（JVM），是对实际系统调用的进一步抽象 系统调用的实现 每个系统调用对应一个系统调用号 系统调用接口根据系统调用号来维护表的索引 系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果 用户不需要系统调用的实现 需要设置调用参数和获取返回结果 操作系统接口的细节大部分都隐藏在应用编程接口后 通过运行程序支持的库来管理 注意，系统调用时，堆栈需要切换（内核和用户程序使用的是不同的堆栈），特权级需要进行切换 习题简答题BIOS从磁盘读入的第一个扇区是是什么内容？为什么没有直接读入操作系统内核映像？ BIOS完成硬件初始化和自检后，会根据CMOS中设置的启动顺序启动相应的设备，这里假定按顺序系统要启动硬盘。但此时，文件系统并没有建立，BIOS也不知道硬盘里存放的是什么，所以BIOS是无法直接启动操作系统。另外一个硬盘可以有多个分区，每个分区都有可能包括一个不同的操作系统，BIOS也无从判断应该从哪个分区启动，所以对待硬盘，所有的BIOS都是读取硬盘的0磁头、0柱面、1扇区的内容，然后把控制权交给这里面的MBR (Main Boot Record）。 我认为上述答案并不十分确切。比如，在uCore中，虽然BIOS没有建立文件系统，bootloader也没有建立文件系统啊。但是，加载操作系统是个很复杂的过程：就比如uCore，我们需要完成对ELF文件格式的解析和文件本身的读入。BIOS工作在实模式，本身访存范围只有1MB（能使用的数据只有0 ~ 0x7c00的范围），而且代码长度被限制在64KB。为了将OS读入到高地址的内存中，需要BIOS进行模式的切换。但是，如果BIOS进行了实模式到保护模式的切换，就不能实现向后兼容了。而且不同的OS的文件格式和处理方法也有差异，这会导致BIOS十分复杂。因此，让OS提供自己的启动程序是最好的选择。 比较UEFI和BIOS的区别。 统一可扩展固件接口 (Unified Extensible Firmware Interface, UEFI) 是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。 UEFI启动对比BIOS启动的优势有三点： 安全性更强：UEFI启动需要一个独立的分区，它将系统启动文件和操作系统本身隔离，可以更好的保护系统的启动； 启动配置更灵活：EFI启动和GRUB启动类似，在启动的时候可以调用EFIShell，在此可以加载指定硬件驱动，选择启动文件。比如默认启动失败，在EFIShell加载U盘上的启动文件继续启动系统； 支持容量更大：传统的BIOS启动由于MBR的限制，默认是无法引导超过2TB以上的硬盘的。随着硬盘价格的不断走低，2TB以上的硬盘会逐渐普及，因此UEFI启动也是今后主流的启动方式。 分区引导扇区的结束标志是什么？ 0X55AA。当然，上面也说到了，BIOS除此之外还会检查别的内容。 在UEFI中的可信启动有什么作用？ 通过启动前的数字签名检查来保证启动介质的安全性。 什么是中断、异常和系统调用？ 中断：外部意外的响应； 异常：指令执行意外的响应； 系统调用：系统调用指令的响应。 这个回答真是十分简洁明了。 中断、异常和系统调用的处理流程有什么异同？ 相同点：都会进入异常服务例程，切换为内核态。 不同点： 源头不同，中断源是外部设备，异常和系统调用源是应用程序； 响应方式不同，中断是异步的，异常是同步的，系统调用异步和同步都可以。 处理机制不同，中断对用户程序是透明的，异常会重新执行用户指令或杀死用户进程，系统调用一般是用户程序调用的 系统调用与函数调用的区别是什么？ 汇编指令的区别 系统调用：使用INT和IRET指令 函数调用：使用CALL和RET指令 安全性的区别 系统调用有堆栈和特权级的转换过程，函数调用没有这样的过程，系统调用相对更为安全 性能的区别 时间角度：系统调用比函数调用要做更多和特权级切换的工作，所以需要更多的时间开销 空间角度：在一些情况下，如果函数调用采用静态编译，往往需要大量的空间开销，此时系统调用更具有优势","tags":"os"},{"title":"OS Summary - 操作系统实验环境","url":"/2018/11/27/os-lecture-2-summary/","text":"课程内容概述 实验内容的详细介绍 X86-32硬件的介绍 uCore 的部分编程技巧和数据结构 如何使用工具编写和调试实验 实验主要是使用 C 语言实现的，目前还没有认真动手操作，只是大概了解一下思路。 实验具体内容略。。。 X86-32硬件简单介绍 运行模式 80386 共有四中运行模式，我们只用到了其中两种 实模式：加电后的默认模式，在BootLoader中就会切换为保护模式 保护模式：一般的模式 寻址方法 逻辑地址：由16位的段选择子和32位的偏移量组成，是应用程序直接使用的地址空间（大概就是程序运行时访问的地址） 线性地址：由逻辑地址的偏移量 + 段基址得到，是虚存管理下每个运行的应用程序能访问的地址空间 物理地址：处理器提交到总线上用于访问计算机系统中内存和外设的最终地址。如果未开启页机制，则物理地址 = 线性地址；否则通过页表和线性地址可得到物理地址 寄存器 通用寄存器 EAX : 累加器 EBX : 基址寄存器 ECX : 计数器 EDX : 数据寄存器 ESI : 原地址指针寄存器 EDI : 目的地址指针寄存器 EBP : 基址指针寄存器 ESP : 堆栈指针寄存器 段寄存器 CS : 代码段 ( Code Segment) DS : 数据段（Data Segment） ES : 附加数据段（Extra Segment） SS : 堆栈段（Stack Segment FS : 附加段 GS : 附加段 指令寄存器 EIP : 指令的段内偏移地址 标志寄存器 EFLAGS : TF : 开启单步调试 IF : 开启硬件中断 IOPL : I/O特权级，CPL &lt;= IOPL 时才能进行 I/O 操作 选择题略。。。 简答题你理解的对于类似ucore这样需要进程/虚存/文件系统的操作系统，在硬件设计上至少需要有哪些直接的支持？至少应该提供哪些功能的特权指令？ 进程的切换需要硬件支持时钟中断；虚存管理需要地址映射机制，从而需要MMU等硬件；对于文件系统，需要硬件有稳定的存储介质来保证操作系统的持久性。对应的，应当提供中断使能，触发软中断等中断相关的，设置内存寻址模式，设置页表等内存管理相关的，执行 I/O 操作等文件系统相关的特权指令。 对于现代操作系统（每个进程占一个时间片）时钟中断是非常重要的。存储介质当然也是非常重要的。当然，事实上，MMU 没有也行，可以用用户态函数库来实现地址转换，但这样可能就保证不了安全性了。 Intel 手册第 3 卷 2.8 j节 “System Instruction Summary” 中给出了一个系统指令列表。 “系统指令完成的是系统级的功能，包括加载系统寄存器、管理 Cache、管理终端和设置调试寄存器。其中的大部分指令都必须由操作系统或特权级为 0 的进程执行；另一部分可以由任何特权级的进程执行。” 你理解的x86的实模式和保护模式有什么区别？物理地址、线性地址、逻辑地址的含义分别是什么？ 保护模式和实模式的根本区别是进程内存是否受保护。（作者的意见是，实模式既是一个历史包袱，又有一定的实际用途。在实模式下，BIOS 自检和加载 BootLoader 的程序可以尽可能简单，因为不需要建立复杂的段映射。但是段机制必须开启这一点也是历史包袱。总之，BootLoader 一开始就开了 A20 ，设置了GDT然后长跳转切换到保护模式了。）实模式将整个内存看成分段的区域，程序代码和数据位于不同的区域，系统程序和用户程序没有区别对待，而且没一个指针都是指向“实在”的物理地址。这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，那么对于这个别修改的系统程序或用户程序，其后果可能是灾难性的。为了克服这种低劣的内存管理模式，处理器厂商开发出保护模式。这样，物理内存不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。 物理地址：是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。 逻辑地址：在有地址变换功能的计算机中，访问指令给出的地址叫逻辑地址。（一般的定义是段选择子+段内偏移量是逻辑地址。大概） 线性地址：线性地址是逻辑地址和物理地址变换之间的中间层，是处理器通过段（Segment）机制控制下形成的地址空间 虚拟地址：对这个名称的定义总是模糊不清。在这门课中，似乎虚拟地址就是程序内存的地址。","tags":"os"},{"title":"OS Summary - 操作系统概述","url":"/2018/11/21/os-lecture-1-summary/","text":"内容概述 什么是操作系统 操作系统的演变 操作系统结果的分类 什么是操作系统操作系统可以是： 一个控制程序 一个资源管理器 一套标准库 操作系统通常有内核、命令行和 GUI 组成。我们研究的主要是内核。可以分成以下4个层次 ： 应用程序 命令行程序、编译器、解释器、系统库 内核 内核向上提供系统调用接口 同时调用下层提供的硬件抽象 硬件设备 操作系统内核的特征： 并发：OS 需要管理和调度多个同时运行的程序 共享：对资源的互斥共享 虚拟：对 CUP 和内存资源的虚拟化 异步：程序的运行时时常会停止的，OS 需要保证程序展厅之后状态不变 操作系统的演变 单用户系统：1945 - 1955 OS = 装载器 + 通用子程序库 存在的问题：任务完全为穿行执行，由于读卡时间过长，执行时间比例降低 批处理系统：1955 - 1965 每个任务在每个组件中串行执行，总体看来是并行执行的 解决了利用率的问题 多道程序系统：1965 - 1980 将多个程序储存在内存中，复用 CPU 在程序进行 I/O 操作室将其阻塞，切换到别的程序 分时系统：1970 - 定义中断当前程序，实现对CPU的复用 个人电脑操作系统 分布式操作系统 …… 操作系统结构的分类操作系统的结构可以分为以下几种： 简单结构：没有拆分为模块，没有很好的分离接口和功能 应用程序可以直接访问最底层的服务，也可以使用操作系统的服务 例： MS-DOS 分层结构：将操作系统分为几层，每层建立在底层之上 优点：可移植性强 缺点：层次过多会导致效率降低 例：UNIX 微内核结构：将一些内核服务移动到用户态，内核只保留进程通信和硬件支持功能 优点：灵活，安全 缺点：性能差 例：目前的系统结构是微内核结构和分层结构的混合体 外核结构：内核只起到资源的保护和隔离功能，操作系统原有功能由用户态操作系统库支持 虚拟机结构：操作系统和虚拟机管理器交互，虚拟机管理器负责和硬件交互 习题选择填空题 当前常见的操作系统主要用C，C++，ASM编程语言编写。 “Operating system”这个单词起源于Operator。 指的是原来的系统操作员。 在计算机系统中，控制和管理各种资源、有效地组织多道程序运行的系统软件称作操作系统。 对操作系统定义的考察。当然我觉得这个答案并不全面，加上“提供了一套标准库”（也就是系统调用）会更好。 允许多用户将若干个作业提交给计算机系统集中处理的操作系统称为批处理操作系统。 这说明单用户系统是每个任务手动提交上去的。 你了解的当前世界上使用最多的32bit CPU是ARM，其上运行最多的操作系统是Android。 答案如此，没有找到信源。不过知道这个也没什么意义。 应用程序通过系统调用接口获得操作系统的服务。 系统调用是非常重要的。这是应用程序主动进入内核态的方式。 现代操作系统的特征包括并发性，共享性，虚拟性，异步性，持久性。 特征到底应该包括哪些也是见仁见智。OSTEP中总结出的三点是虚拟，并发和持久性。异步性和共享性大概可以归入并发性。同时我也觉得持久性未必是操作系统的特点，而是存储设备的特点。当然这也可能是我的理解不够。 UPD：操作系统本身也是需要从持久性存储设备中读入的。文件系统也是OS的重要组成成分。所以我想得可能太片面了。 操作系统内核的架构包括宏内核，微内核，外核。 这个答案和上面讲的并不相符。那么，当然应该填简单结构、分层结构、微内核结构、外核结构和虚拟机结构了。 简答题请总结你认为操作系统应该具有的特征有什么？并对其特征进行简要阐述。 操作系统应该具有的特征有：虚拟性、并发性、异步性、共享性和持久性。 虚拟性：虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备。 并发性：并发是指两个或多个事件在同一时间间隔内发生，在多道程序环境下，一段时间内宏观上有多个程序在同时执行，而在同一时刻，单处理器环境下实际上只有一个程序在执行，故微观上这些程序还是在分时的交替进行。操作系统的并发是通过分时得以实现的。操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。 异步性：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。异步性使得操作系统运行在一种随机的环境下，可能导致进程产生于时间有关的错误。但是只要运行环境相同，操作系统必须保证多次运行进程，都获得相同的结果。 共享性：系统中的资源可供内存中多个并发执行的进程共同使用。（事实上，只能做到互斥共享，或者说同时。） 持久性：通过实现文件系统，操作系统可以将程序以及数据存储在磁盘等存储介质中。 详细解释可以参考操作系统的特征。 为什么现在的操作系统基本上用C语言来实现？为什么没有人用python，java来实现操作系统？ C语言是编译型语言，有良好的性能，能够直接嵌入汇编，可以方便地操作硬件；Python，Java无法保证性能，不能直接操作硬件。 不过，仍然是有人用这些语言来编写操作系统的，比如： 用Java实现的操作系统：JavaOS 用Python实现的操作系统：pycorn，pythonix 用Rust实现的操作系统：Redox 参考： https://github.com/chyyuu/os_course_info https://zhanghuimeng.github.io/ http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about","tags":"os"},{"title":"About Me","url":"/about/index.html","text":"Hello my name is Shinhwa Wang.I come from China, now live and work in Kuala Lumpur, Malaysia.I like to code and want to know more interesting technical stuff. If you are interested in what I am learning now start from here.I also love English and try to use it in my daily life. As you already know I’m Chinese and learning English is a tough process for most Chinese people , here is some advise on how I learn English.Over the years I’ve made so many projects that I’ve lost the count. In this website you can find some articles on what I’ve learned.I’m actively collecting a list of useful resources that I take inspiration from and you can find it here.If you’d like to know more about me, like the projects I’ve been involved in, check out my Resume and GitHub.I have worked for more than 5 years and it would be pretentious to say I’ve got all the answers, but I hope you’ll find my experiences and findings useful.I believe in god that everything gets it way and reason, so stay thankful, try to improve gradually and enjoy your life in everyday. Here is my favorite verse, Blessed be the LORD god, the God of Israel, who alone does wonderful deeds. Now I’ll get back to work on something more meaningful than the about section of my blog. And I’d suggest you did that too. My Biggest Influences and fav 💕 blogsCS-Notes: The blog made me realize how much more I need to learn. Contact Me ​ For general communication, contact shinhwawang2015@gmail.com ​ My Wechat id wshpop","tags":""},{"title":"404","url":"/404.html","text":"* { -webkit-box-sizing: border-box; box-sizing: border-box; -webkit-user-select: none; /* Safari 3.1+ */ -moz-user-select: none; /* Firefox 2+ */ -ms-user-select: none; /* IE 10+ */ user-select: none; /* Standard syntax */ } body { padding: 0; margin: 0; } #notfound { position: relative; height: 90%; width: 100%; } #notfound .notfound { position: absolute; left: 50%; top: 50%; -webkit-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%); } .notfound { max-width: 550px; width: 100%; line-height: 1.4; text-align: center; } .notfound .notfound-404 { position: relative; height: 200px; margin: 0px auto 20px; z-index: -1; } .notfound .notfound-404 h1 { font-family: 'Palatino', serif; font-size: 236px; font-weight: 200; margin: 0px; color: #211b19; text-transform: uppercase; position: absolute; left: 50%; top: 50%; -webkit-transform: translate(-50%, -50%); -ms-transform: translate(-50%, -50%); transform: translate(-50%, -50%); } .notfound .notfound-404 h2 { font-family: 'Palatino', serif; font-size: 36px; font-weight: 400; text-transform: uppercase; color: #211b19; background: #fff; padding-top: 20px; padding-bottom: 10px; margin: auto; display: inline-block; position: absolute; width: 120%; left: 50%; top: 50%; -webkit-transform: translate(-50%, -80%); -ms-transform: translate(-50%, -80%); transform: translate(-50%, -80%); } .notfound a { font-family: 'Palatino', serif; text-decoration: none; text-transform: uppercase; padding: 13px 23px; font-size: 18px; -webkit-transition: 0.2s all; transition: 0.2s all; display: inline-block; margin: 0 4px; padding: 4px 12px; background-color: #fff; border-bottom: 4px solid #b21c1c; border-radius: 4px; font-size: 14px; color: #fff; background-color: #e20b0b; text-align: center; cursor: pointer; } .notfound a:hover { background-color: #f21a1a; } @media only screen and (max-width: 600px) { .notfound .notfound-404 h1 { font-size: 120px; } .notfound .notfound-404 h2 { font-size: 18px; padding-top: 10px; padding-bottom: 5px; } } 404 - Page not found 404 🙃 Page is not found. Take me home!","tags":""},{"title":"","url":"/search/index.html","text":"","tags":""}]}