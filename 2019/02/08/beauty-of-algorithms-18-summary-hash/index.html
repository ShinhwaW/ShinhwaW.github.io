<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Beauty Of Algorithms 18 Summary. Hash · Shinhwa's Site</title><meta name="description" content="Beauty Of Algorithms 18 Summary. Hash - Shinhwa"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.jpg"><link rel="stylesheet" href="/css/nella.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Shinhwa's Site"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"></a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"></a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"></a></li></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">Beauty Of Algorithms 18 Summary. Hash</h1><div class="post-info">Feb 8, 2019<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><a href="/categories/Alogorithms/" class="post-category">#Alogorithms</a></div><div class="post-content"><h3 id="哈希算法的定义和原理"><a href="#哈希算法的定义和原理" class="headerlink" title="哈希算法的定义和原理"></a>哈希算法的定义和原理</h3><p>将任意长度的二进制串映射为固定长度的二进制串。</p>
<p>这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值。</p>
<p>设计一个优秀的哈希算法需要满足：</p>
<ul>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值<a id="more"></a>
</li>
</ul>
<h4 id="MD5哈希算法"><a href="#MD5哈希算法" class="headerlink" title="MD5哈希算法"></a>MD5哈希算法</h4><p>MD5的哈希值是128位的bit长度，为了方便转换成了16进制编码。</p>
<p>可以看出无论哈希值文本有多长多短，通过MD5哈希之后，得到的哈希值的长度都是一样的，</p>
<p>而且得到的哈希值看起来像一堆随机数完全没有规律。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(&quot; 今天我来讲哈希算法 &quot;) = bb4767201ad42c74e650c1b6c03d78fa</span><br><span class="line">MD5(&quot;jiajia&quot;) = cd611a31ea969b908932d44d126d195b</span><br></pre></td></tr></table></figure>
<h3 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h3><h4 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a><strong>安全加密</strong></h4><p><strong>加密算法</strong></p>
<p>最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。</p>
<p>对用于加密的哈希算法来说，有两点格外重要：</p>
<ul>
<li>很难根据哈希值反向推导出原始数据</li>
<li>散列冲突的概率要很小</li>
</ul>
<p>实际上，不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。</p>
<p><strong>鸽巢理论</strong></p>
<p>这里就基于组合数学中一个非常基础的理论，鸽巢原理（也叫抽屉原理）。</p>
<p>这个原理本身很简单，它是说如果有 10 个鸽巢，有 11 只鸽子那肯定有 1 个鸽巢中的鸽子数量多于 1 个。</p>
<p>换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p>
<p>我们知道，哈希算法产生的哈希值的长度是固定且有限的。</p>
<p>哈希值是固定的 128 位二进制串，能表示的数据是有限的最多能表示 2^128 个数据。</p>
<p>基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。</p>
<h4 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a><strong>唯一标识</strong></h4><p><strong>在图库中搜索图片</strong></p>
<p>如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对。</p>
<p>因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。</p>
<p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。</p>
<p>比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节。</p>
<p>然后将这 300 个字节放到一块，通过哈希算法（比如 MD5)得到一个哈希字符串，用它作为图片的唯一标识。</p>
<p>通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量</p>
<p><strong>性能提升</strong><br>如果还想继续提高效率，我们可以把每个图片的唯一标识和相应的图片文件在图库中的路径信息，都存储在散列表中。</p>
<p>当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p>
<h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a><strong>数据校验</strong></h4><p><strong>P2P文件快校验</strong></p>
<p>BT 下载的原理是基于 P2P 协议的。</p>
<p>我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成100 块，每块大约 20MB）。</p>
<p>等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p>
<p>网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。</p>
<p><strong>解决方法</strong></p>
<p>我们通过哈希算法，对 100 个文件块分别取哈希值并且保存在种子文件中。</p>
<p>当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。</p>
<p>如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a><strong>散列函数</strong></h4><p><strong>散列函数是一种哈希算法</strong></p>
<p>实际上，散列函数也是哈希算法的一种应用。</p>
<p>散列函数是设计一个散列表的关键。</p>
<p>它直接决定了散列冲突的概率和散列表的性能。</p>
<p>不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。</p>
<p>即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p>
<p><strong>散列函数追求平均分布</strong></p>
<p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。</p>
<p>散列函数中用到的散列算法，更加关注散列后的值是否能平均分布。</p>
<p>也就是一组数据是否能均匀地散列在各个槽中。</p>
<p>除此之外，散列函数执行的快慢，也会影响散列表的性能，</p>
<p>所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h4><p>我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p>
<p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。</p>
<p>客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p>
<ul>
<li>如果客户端很多，映射表可能会很大，比较浪费内存空间</li>
<li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大</li>
</ul>
<p>如果借助哈希算法，这些问题都可以非常完美地解决。</p>
<p>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</p>
<p>这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a><strong>数据分片</strong></h4><p><strong>统计“搜索关键词”出现的次数</strong></p>
<p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，</p>
<p>我们想要快速统计出每个关键词被搜索的次数。</p>
<p>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p>
<p>为了提高处理的速度，我们用 n 台机器并行处理。</p>
<p>我们从搜索记录的日志文件中，依次读出每个搜索关键词，</p>
<p>并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>
<p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。</p>
<p>也就是说，同一个搜索关键词会被分配到同一个机器上。</p>
<p>每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p>
<p><strong>快速判断图片是否在图库中</strong></p>
<p>假设现在我们的图库中有 1 亿张图片，在单台机器上构建散列表是行不通的。</p>
<p>我们同样可以对数据进行分片，然后采用多机处理。</p>
<p>我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。</p>
<p>我们每次从图库中读取一个图片，计算唯一标识，</p>
<p>然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，</p>
<p>然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p>
<p>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，</p>
<p>计算这个图片的唯一标识，然后与机器个数 n 求余取模。</p>
<p>假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a><strong>分布式存储</strong></h4><p>我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。</p>
<p>我们需要将数据分布在多台机器上通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号</p>
<p>如果数据增多，原来的 10 个机器已经无法承受，我们需要扩容，假如扩到 11 个机器。</p>
<p>原来的数据是通过与 10 来取模的，比如 13 这个数据，存储在编号为 3 这台机器上。</p>
<p>新加了一台机器后，我们对数据按照 11 取模，原来 13 这个数据被分配到了 2 号这台机器上。</p>
<p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。</p>
<p>所有的数据请求都会穿透缓存，直接去请求数据库，可能会发生雪崩效应，压垮数据库。</p>
<p>我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。</p>
<p>这时候，一致性哈希算法就要登场了。</p>
<p><strong>一致性哈希算法</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">参考</a></p>
<p>假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。</p>
<p>我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。</p>
<p>当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。</p>
<p>这样既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/Alogorithms/">#Alogorithms</a><a href="/tags/数据结构与算法/">#数据结构与算法</a><a href="/tags/Hash/">#Hash</a><a href="/tags/哈希算法/">#哈希算法</a></p></article></div><footer><div class="paginator"><a href="/2019/02/09/beauty-of-algorithms-19-summary-binarytree/" class="prev">PREV</a><a href="/2019/02/07/beauty-of-algorithms-17-summary-hash-table/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="/gitalk/gitalk.css"><script src="/gitalk/gitalk.min.js"></script><script>var gitalk = new Gitalk({
    clientID: 'abc8dd436b794dd57f1a',
    clientSecret: 'abb0140fec65a00f96066e5c84eee8a7eb8818a4',
    repo: 'shinhwaw.github.io',
    owner: 'shinhwaw',
    admin: ['shinhwaw'],
    perPage: 100,
    id: 'Fri Feb 08 2019 00:45:30 GMT+0800 GMT'.split('GMT')[0].replace(/\s/g, '-'),
    distractionFreeMode: false,
    pagerDirection: 'first'
})

gitalk.render('container')</script></footer></div><script async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ["script","noscript","style","textarea","code","pre"]
    }
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-137034489-1",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>