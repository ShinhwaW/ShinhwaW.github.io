<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Beauty Of Algorithms 19 Summary. Binarytree · Shinhwa's Site</title><meta name="description" content="Beauty Of Algorithms 19 Summary. Binarytree - Shinhwa"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.jpg"><link rel="stylesheet" href="/css/nella.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.12/css/all.css" integrity="sha384-G0fIWCsCzJIMAVNQPfjH08cyYaUtMwjJwqiRKxxE/rx96Uroj1BtIQ6MLJuheaO9" crossorigin="anonymous"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Shinhwa's Site"><script src="//code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"></a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"></a></li><li class="nav-list-item"><a href="/search/" target="_self" class="nav-list-link">SEARCH</a></li><li class="nav-list-item"><a href="/search" target="_self" class="nav-list-link search"></a></li></ul></header><main class="container"></main><div class="post"><article class="post-block"><h1 class="post-title">Beauty Of Algorithms 19 Summary. Binarytree</h1><div class="post-info">Feb 9, 2019<span class="categories"><i class="fa fa-bookmark" aria-hidden="true"></i></span><a href="/categories/Algorithms/" class="post-category">#Algorithms</a></div><div class="post-content"><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li><p>节点</p>
<p>树中的元素称之为节点</p>
</li>
<li><p>高度</p>
<ul>
<li><p>节点的高度</p>
<p>节点到叶子节点的最长路径</p>
</li>
<li><p>树的高度</p>
<p>跟节点的高度</p>
</li>
</ul>
</li>
<li><p>深度</p>
<p>根节点到这个节点所经历的边的个数</p>
</li>
<li><p>层</p>
<p>节点的深度+1</p>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797246423.png" alt></p>
<h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3></li>
<li><p>满二叉树</p>
<p>除了叶子结点外每个节点都有左右两个子节点</p>
</li>
<li><p>完全二叉树</p>
<p>叶子结点都在最低下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</p>
</li>
</ul>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797311876.png" alt></p>
<h3 id="表示、存储一棵二叉树"><a href="#表示、存储一棵二叉树" class="headerlink" title="表示、存储一棵二叉树"></a>表示、存储一棵二叉树</h3><p><strong>链式存储法</strong></p>
<p>每个结点有三个字段，其中一个存储数据，另两个是指向左右子节点的指针。</p>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797363532.png" alt></p>
<p><strong>顺序存储法(基于数组)</strong></p>
<p>根节点存储在下标i=1的位置，左子节点存储在下标2<em>i=2的位置，右子节点存储在2</em>i+1=3的位置，以此类推。</p>
<p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 的位置存储的就是右子节点。<br>我们只要知道根节点存储的位置，这样就可以通过下标计算，把整棵树都串起来。</p>
<p>为了方便计算子节点，根节点会存储在下标为 1 的位置</p>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797402073.png" alt></p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li><p>前序遍历</p>
<p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
</li>
<li><p>中序遍历</p>
<p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
</li>
<li><p>后序遍历</p>
<p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
</li>
<li><p>层序遍历</p>
<p>从树的第一层开始从左到右打印节点</p>
</li>
</ul>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797580379.png" alt></p>
<p>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</p>
<p>比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p>
<h3 id="二叉树以及二叉树遍历代码实现"><a href="#二叉树以及二叉树遍历代码实现" class="headerlink" title="二叉树以及二叉树遍历代码实现"></a><strong>二叉树以及二叉树遍历代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BinaryTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            root.data = data;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add(root, <span class="keyword">new</span> Node(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node root, Node newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode.data &lt; root.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.leftNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.leftNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.leftNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.rightNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.rightNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHigh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前序遍历："</span>);</span><br><span class="line">        pre(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            pre(node.leftNode);</span><br><span class="line">            pre(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"中序遍历："</span>);</span><br><span class="line">        in(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            in(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            in(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后序遍历："</span>);</span><br><span class="line">        post(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            post(node.rightNode);</span><br><span class="line">            post(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node leftNode;</span><br><span class="line">        <span class="keyword">private</span> Node rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.leftNode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rightNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        BinaryTree t = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        t.add(<span class="number">40</span>);</span><br><span class="line">        t.add(<span class="number">25</span>);</span><br><span class="line">        t.add(<span class="number">78</span>);</span><br><span class="line">        t.add(<span class="number">10</span>);</span><br><span class="line">        t.add(<span class="number">32</span>);</span><br><span class="line">        t.add(<span class="number">50</span>);</span><br><span class="line">        t.add(<span class="number">93</span>);</span><br><span class="line">        t.add(<span class="number">3</span>);</span><br><span class="line">        t.add(<span class="number">17</span>);</span><br><span class="line">        t.add(<span class="number">30</span>);</span><br><span class="line">        t.add(<span class="number">38</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t.getLow());</span><br><span class="line">        System.out.println(t.getHigh());</span><br><span class="line">        System.out.println(<span class="string">"Size-"</span> + t.size);</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        t.inOrder();</span><br><span class="line">        t.preOrder();</span><br><span class="line">        t.postOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 Binary Search Tree"></a>二叉查找树 Binary Search Tree</h2><h3 id="二叉查找树的定义"><a href="#二叉查找树的定义" class="headerlink" title="二叉查找树的定义"></a>二叉查找树的定义</h3><p>二叉查找树又称二叉搜索树。其要求在二叉树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树的节点的值都大于这个节点的值。</p>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550049430176.png" alt></p>
<h3 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h3><p><strong>二叉树类、节点类以及查找方法的代码实现</strong></p>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064373887.png" alt></p>
<p>先取根节点，如果它等于我们要查找的数据，那就返回。</p>
<p>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</p>
<p>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二叉查找树的插入操作</strong></p>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064441773.png" alt></p>
<p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p>
<p>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二叉查找树的删除操作</strong></p>
<p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064532346.png" alt></p>
<p>第一种情况，删除的节点没有子节点直接将其父节点指向置为null。</p>
<p>第二种情况，删除的节点只有一个子节点，将其父节点指向其子节点。</p>
<p>第三种情况，删除的节点有两个子节点，首先找到该节点右子树中最小的的节点把他替换掉要删除的节点 然后再删除这个最小的节点，该节点必定没有子节点，否则就不是最小的节点了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 先找到要删除的节点 </span></span><br><span class="line"><span class="comment"> * 2. 如果这个节点有两个叶子节点，找到右子树的最小值，替换当前的这个节点值，同时删除这个最小值 </span></span><br><span class="line"><span class="comment"> * 3.如果这个节点只有一个叶子节点，用叶子节点的值替换当前节点的值 </span></span><br><span class="line"><span class="comment"> * 4. 如果这个节点没有叶子节点，直接删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = root;</span><br><span class="line">    Node pp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node minP = p;</span><br><span class="line">        Node minPP = pp;</span><br><span class="line">        <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p.data = minP.data;</span><br><span class="line">        p = minP;</span><br><span class="line">        pp = minpp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node child;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">        pp.left = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pp.right = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。</p>
<p>这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p>
<h3 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a><strong>二叉查找树的其他操作</strong></h3><p>二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。</p>
<p>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</p>
<h3 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h3><p>前面的二叉查找树的操作，我们默认树中节点存储的都是数字，针对的都是不存在键值相同的情况。</p>
<p>我们可以通过两种办法来构建支持重复数据的二叉查找树。</p>
<ul>
<li><p>第一种方法</p>
<p>二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
</li>
<li><p>第二种方法</p>
<p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p>
<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>
</li>
</ul>
<h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p><strong>最坏、最好情况</strong></p>
<p>如果根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<p>最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。而完全二叉树的高度小于等于 log2n。</p>
<p><strong>平衡二叉查找树</strong></p>
<p>我们需要构建一种不管怎么删除、插入数据，在任何时候都能保持任意节点左右子树都比较平衡的二叉查找树，这就是一种特殊的二叉查找树，平衡二叉查找树。</p>
<p>平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)。</p>
<h3 id="二叉查找树相比散列表的优势"><a href="#二叉查找树相比散列表的优势" class="headerlink" title="二叉查找树相比散列表的优势"></a>二叉查找树相比散列表的优势</h3><p><strong>散列表中的数据是无序存储的</strong></p>
<p>如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</p>
<p><strong>散列表扩容耗时很多</strong></p>
<p>而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p>
<p><strong>散列表存在哈希冲突</strong></p>
<p>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。</p>
<p>加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p>
<p><strong>散列表装载因子不能太大</strong></p>
<p>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p>
<p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。</p>
</div><p class="post-tags"><i class="fa fa-tags" aria-hidden="true"></i><a href="/tags/Algorithms/">#Algorithms</a><a href="/tags/数据结构与算法/">#数据结构与算法</a><a href="/tags/BinaryTree/">#BinaryTree</a><a href="/tags/二叉树/">#二叉树</a></p></article></div><footer><div class="paginator"><a href="/2019/02/13/beauty-of-algorithms-20-summary-red-black-tree/" class="prev">PREV</a><a href="/2019/02/08/beauty-of-algorithms-18-summary-hash/" class="next">NEXT</a></div><div id="container"></div><link rel="stylesheet" href="/gitalk/gitalk.css"><script src="/gitalk/gitalk.min.js"></script><script>var gitalk = new Gitalk({
    clientID: 'abc8dd436b794dd57f1a',
    clientSecret: 'abb0140fec65a00f96066e5c84eee8a7eb8818a4',
    repo: 'www.shinhwa.wang',
    owner: 'shinhwaw',
    admin: ['shinhwaw'],
    perPage: 100,
    id: 'Sat Feb 09 2019 00:45:30 GMT+0800 GMT'.split('GMT')[0].replace(/\s/g, '-'),
    distractionFreeMode: false,
    pagerDirection: 'first'
})

gitalk.render('container')</script></footer></div><script async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ["script","noscript","style","textarea","code","pre"]
    }
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-137034489-1",'auto');ga('send','pageview');</script><link rel="stylesheet" href="//cdn.datatables.net/1.10.7/css/jquery.dataTables.min.css" media="screen" type="text/css"><script src="//cdn.datatables.net/1.10.7/js/jquery.dataTables.min.js"></script><script>$(function(){$('.datatable').dataTable( {"order": [[ 0, "desc" ]],"iDisplayLength": -1,"lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]} );});</script></body></html>