<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shinhwa&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-14T14:10:00.337Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shinhwa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes On Network Protocol UDP AND TCP</title>
    <link href="http://yoursite.com/2019/04/14/notes-on-network-protocol-udp-and-tcp/"/>
    <id>http://yoursite.com/2019/04/14/notes-on-network-protocol-udp-and-tcp/</id>
    <published>2019-04-14T14:06:44.000Z</published>
    <updated>2019-04-14T14:10:00.337Z</updated>
    
    <content type="html"><![CDATA[<p>UDP 和 TCP 详解 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a><br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UDP 和 TCP 详解 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>IPA Sounds And Exmaples</title>
    <link href="http://yoursite.com/2019/04/07/phonetic-alphabet/"/>
    <id>http://yoursite.com/2019/04/07/phonetic-alphabet/</id>
    <published>2019-04-07T03:53:21.000Z</published>
    <updated>2019-04-07T13:39:15.601Z</updated>
    
    <content type="html"><![CDATA[<p>Examples of IPA use in common English words.<br>List of challenging English sounds and words especially for Chinese people.<br><a id="more"></a></p><h3 id="Diphthong-Vowels"><a href="#Diphthong-Vowels" class="headerlink" title="Diphthong Vowels"></a>Diphthong Vowels</h3><p>The key is to pronounce two symbols clearly</p><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">aʊ</td><td style="text-align:center">Mouth, house, brown, cow, out, downtown</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">əʊ</td><td style="text-align:center">No, don’t, stones, alone, hole, ghost</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">eɪ</td><td style="text-align:center">Face, space, rain , case, eight, name</td><td style="text-align:center">two symbols</td></tr><tr><td style="text-align:center">aɪ</td><td style="text-align:center">My, sight, pride, kind, flight, time</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɔɪ</td><td style="text-align:center">Joy, employ, toy, coil, oyster, point, coin</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʊə</td><td style="text-align:center">lure, tour</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">eə</td><td style="text-align:center">Hair, there, care, stairs, pear, fair, stare</td><td style="text-align:center">tongue back enough</td></tr></tbody></table><h3 id="Short-Vowels-Or-Single-Vowels"><a href="#Short-Vowels-Or-Single-Vowels" class="headerlink" title="Short Vowels Or Single Vowels"></a>Short Vowels Or Single Vowels</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">æ</td><td style="text-align:center">Cat, hand, nap, flat, have, apple</td><td style="text-align:center">tongue back enough</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">Went, intend, send, letter, bed, step</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʌ</td><td style="text-align:center">Fun, love, money, one, London, come, hungry, but</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɒ</td><td style="text-align:center">Rob, top, watch, squat, sausage, job</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ə</td><td style="text-align:center">Alive, again, mother, toward, banana</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʊ</td><td style="text-align:center">Put, look, should, cook, book, look, good</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɪ</td><td style="text-align:center">city, skin, kill, sit</td><td style="text-align:center">expand mouth</td></tr></tbody></table><h3 id="Long-Vowels"><a href="#Long-Vowels" class="headerlink" title="Long Vowels"></a>Long Vowels</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">ɑ:</td><td style="text-align:center">Fast, car, hard, bath, garden, park</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɔ:</td><td style="text-align:center">Talk, law, bored, yawn, jaw, soft, loft</td><td style="text-align:center">tongue back enough</td></tr><tr><td style="text-align:center">ɜ:</td><td style="text-align:center">Nurse, heard, third, turn, earth, earn</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">u:</td><td style="text-align:center">Few, boot, lose, gloomy, fruit, chew, do</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">i:</td><td style="text-align:center">Need, beat, team, me, keen</td><td style="text-align:center">expand mouth</td></tr></tbody></table><h3 id="Consonants-Sounds"><a href="#Consonants-Sounds" class="headerlink" title="Consonants Sounds"></a>Consonants Sounds</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">l</td><td style="text-align:center">large, milk, pill, chill, melt</td><td style="text-align:center">Approximants / tongue touch teeth</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">Room, mother, mad, more</td><td style="text-align:center">Nasals</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">Now, nobody, knew, turn</td><td style="text-align:center">Nasals</td></tr><tr><td style="text-align:center">ŋ</td><td style="text-align:center">King, thing, song, swimming, long, rank</td><td style="text-align:center">tongue touch roof of back mouth</td></tr><tr><td style="text-align:center">θ</td><td style="text-align:center">Thank, Think, Bath, Mouth</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ð</td><td style="text-align:center">There, those, brothers, others</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">snake, sense</td><td style="text-align:center">expand mouth</td></tr><tr><td style="text-align:center">z</td><td style="text-align:center">Zoo, crazy, lazy, zigzag, nose, close</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ts</td><td style="text-align:center">treats, tweets</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dz</td><td style="text-align:center">ends, bends, friends</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">f</td><td style="text-align:center">Full, Friday, fish, knife, fair, fine</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">Vest, village, view, cave, live, very</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">Cash, quick, cricket, sock, kind, clock</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">Girl, green, grass, flag, great, egg</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">Time, train, tow, late, tour</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">Door, day, drive, down, feed, dog</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">Pin, cap, purpose, pause, pet</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">Bag, bubble, build, robe, bus</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʈʃ</td><td style="text-align:center">Choose, cheese, church, watch, chance</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dʒ</td><td style="text-align:center">Joy, juggle, juice, stage, jar</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʃ</td><td style="text-align:center">Shirt, rush, shop, cash, shut, shall</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʒ</td><td style="text-align:center">Television, delusion, casual, leisure</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">tr</td><td style="text-align:center">trend, treasure</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dr</td><td style="text-align:center">drive, dry</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">High, help, hello, have</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">Road, roses, river, ring, ride, rare, rest</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">Wall, walk, wine, world, where, what</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">Yellow, usual, yield, yesterday, yard.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Examples of IPA use in common English words.&lt;br&gt;List of challenging English sounds and words especially for Chinese people.&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="http://yoursite.com/categories/English/"/>
    
    
      <category term="International Phonetic Alphabet" scheme="http://yoursite.com/tags/International-Phonetic-Alphabet/"/>
    
      <category term="IPA" scheme="http://yoursite.com/tags/IPA/"/>
    
      <category term="Pronunciation" scheme="http://yoursite.com/tags/Pronunciation/"/>
    
  </entry>
  
  <entry>
    <title>Binary tree B tree B+ Tree</title>
    <link href="http://yoursite.com/2019/04/04/binary-tree-B-tree/"/>
    <id>http://yoursite.com/2019/04/04/binary-tree-B-tree/</id>
    <published>2019-04-04T10:29:05.000Z</published>
    <updated>2019-04-08T13:38:31.594Z</updated>
    
    <content type="html"><![CDATA[<p>平衡二叉树、B树、B+树、B*树 </p><a id="more"></a><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p><ul><li>非叶子节点只能允许最多两个子节点存在</li><li>每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)</li></ul><p>平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如AVL、<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/Treap" target="_blank" rel="noopener">Treap</a>、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1.，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115440.png" alt></p><p>总结平衡二叉树特点：</p><ul><li>非叶子节点最多拥有两个子节点</li><li>非叶子节值大于左边子节点、小于右边子节点</li><li>树的左右两边的层级数相差不会大于1</li><li>没有值相等重复的节点</li></ul><h2 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a><strong>B树(B-tree)</strong></h2><p>注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）</li><li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</li></ul><p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115645.png" alt></p><h4 id="B树的查询流程"><a href="#B树的查询流程" class="headerlink" title="B树的查询流程"></a><strong>B树的查询流程</strong></h4><p>如上图我要从上图中找到E字母，查找流程如下</p><ul><li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）</li></ul><h4 id="B树的插入节点流程"><a href="#B树的插入节点流程" class="headerlink" title="B树的插入节点流程"></a><strong>B树的插入节点流程</strong></h4><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来</p><p>遵循规则</p><ul><li>节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）</li><li>排序规则：满足节点本身比左边节点大，比右边节点小的排序规则</li></ul><p>先插入 3、8、31、11</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115817.png" alt></p><p>再插入23、29</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405144609.png" alt></p><p>再插入50、28</p><p><img src="C:\develop\blog\newblog\source\_posts\assets\1554446788867.png" alt="1554446788867"></p><h4 id="B树节点的删除"><a href="#B树节点的删除" class="headerlink" title="B树节点的删除"></a><strong>B树节点的删除</strong></h4><p><strong>规则</strong></p><ul><li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）</li><li>满足节点本身比左边节点大，比右边节点小的排序规则</li><li>关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405144759.png" alt></p><p><strong>特点</strong></p><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a><strong>B+ 树</strong></h2><p><strong>概念</strong></p><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p><p><strong>规则</strong></p><ul><li>B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针</li><li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405145634.png" alt></p><p><strong>（百度百科算法结构示意图）</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405150344.png" alt></p><p><strong>（维基百科算法结构示意图）</strong></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快</li><li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定</li><li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描</li><li><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a><strong>B*树</strong></h2><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a><strong>规则</strong></h4><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ul><li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</li><li>B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来</li></ul><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h4><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405150527.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><p><strong>相同思想和策略</strong></p><p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度</p></li><li><p><strong>不同的方式的磁盘空间利用</strong></p><p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的</p></li></ul><p>文章转载自 <a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27700617</a></p><p>参考</p><p>附（二分法查找）：<a href="https://zhuanlan.zhihu.com/p/27597160" target="_blank" rel="noopener">二分法查找原理 - 知乎专栏</a></p><p>附（B、B+、B* 树）：<a href="https://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="noopener">从 B 树、B+ 树谈到 R 树</a></p><p>附（B、B+、B* 树）：<a href="https://blog.csdn.net/endlu/article/details/51720299" target="_blank" rel="noopener">end’s coding life</a></p><p>附：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener"> B 树和 B+ 树的插入、删除图文详解 - nullzx - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平衡二叉树、B树、B+树、B*树 &lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Notes On MySQL Locking</title>
    <link href="http://yoursite.com/2019/03/08/notes-on-MySQL-locking/"/>
    <id>http://yoursite.com/2019/03/08/notes-on-MySQL-locking/</id>
    <published>2019-03-08T13:43:42.000Z</published>
    <updated>2019-04-08T14:15:30.684Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL里面的锁可以分为：全局锁、表级锁、行级锁<br><a id="more"></a></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul><li>对整个数据库实例加锁。</li><li>使用场景：做全库逻辑备份时，为了保证备份期间的库在同一个逻辑时间点，即一致性视图（类似于可重复读隔离级别的效果）</li></ul><p>全局锁两种方式：</p><ul><li><em>Flush tables with read lock(FTWRL)</em> 使数据库处于只读状态，数据的增删改、数据定义语句和更新类事务的提交语句都会被阻塞</li><li><em>mysqldump</em> 官方自带的逻辑备份工具，参数 <em>-single-transaction</em> 会在导数据之前启动一个事务，确保拿到一致性视图</li></ul><p>以上两种方式不同点：</p><p>使用 <em>mysqldump</em> 前提是 <strong>引擎支持隔离级别</strong> ，所以<em>single-transaction</em>方法只适用于支持事务引擎的库；MyISAM不支持事务，所以只能使用FTWRL命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global readonly = true</span><br></pre></td></tr></table></figure><p>这条语句也可以做到全库只读，但是不建议使用：</p><ul><li>有时 readonly 会用来判断库是主库还是备库，因此修改global变量的方式影响会比较大</li><li>异常处理方面：FTWRL后客户端异常断开，MySQL会自动释放全局锁，库恢复正常；设置readonly，客户端异常，则会保持readonly，会导致长时间处于不可写状态，风险较高</li></ul><blockquote><p>以上哪种方式，一个库被全局上锁后，对立面任何一个表做字段操作，都会被锁住的</p></blockquote><p>即使没有全局加锁，有了表级锁，加字段也会遇到问题</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL有两种表级别的锁：一种是表锁、另一种是元数据锁( metadata lock，MDL )</p><h4 id="表级锁的语法："><a href="#表级锁的语法：" class="headerlink" title="表级锁的语法："></a>表级锁的语法：</h4><p><code>lock tables xxx read/write</code></p><p>例如 线程A执行了<code>lock table t1 read,t2 write</code> 效果是 <strong>包括A线程在内的所有线程对于t1表只可读，写被阻塞；t2表读写都被阻塞</strong></p><p>lock tables 操作可以用 unlock tables 主动释放，也可以在客户端断开的时候自动释放。  </p><blockquote><p>该操作不仅阻塞其他线程的操作，也阻塞了当前线程的操作</p></blockquote><p>对于innoDB这种支持行锁的引擎，一般不使用<code>lock tables</code>命令控制并发，影响过大</p><h4 id="另一种表级锁：MDL-metadata-lock"><a href="#另一种表级锁：MDL-metadata-lock" class="headerlink" title="另一种表级锁：MDL(metadata lock)"></a>另一种表级锁：<code>MDL(metadata lock)</code></h4><p>MDL在访问一个表的时候会自动加上，MDL的作用是，保证读写的正确性。当表做增删改查操作时，加MDL读锁；当对表结构变更的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，多线程可对同一张表增删改查</li><li>读写锁之间、写锁之间互斥。两个线程同时给一个表增加字段，则第二个需要等待第一个执行完才能继续</li><li>MDL锁在语句执行开始时申请，事务结束后释放</li></ul><h4 id="如何给小锁安全的加字段"><a href="#如何给小锁安全的加字段" class="headerlink" title="如何给小锁安全的加字段"></a>如何给小锁安全的加字段</h4><ul><li><p>解决长事务，当做DDL变更的表中正好在执行长事务，则从information_schema库的innodb_trx找到当前执行长事务，先kill掉长事务或者暂停DDL</p></li><li><p>比较理想的状态：修改表结构语句alter table可以设置等待时间，如果该时间内拿不到MDL锁，则该时间内拿不到MDL锁，则放弃执行，不会阻塞后面的语句</p><p>MariaDB/ALiSQL已经支持 <code>DDL NOWAIT/WAIT n</code> 这个语法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table tb1_name NOWAIT add column...</span><br><span class="line">alter table tb1_name WAIT N add column...</span><br></pre></td></tr></table></figure><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul><li><p>定义：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放， 而是要等到事务结束时才释放</p></li><li><p>建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</p></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>定义：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态</li><li>解决方案<ul><li>通过参数 <code>innodb_lock_wait_timeout</code> 根据实际业务场景来设置超时时间，InnoDB 引擎默认值是50s</li><li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑（默认是开启状态）。</li></ul></li></ul><h4 id="如何解决热点行更新导致的性能问题？"><a href="#如何解决热点行更新导致的性能问题？" class="headerlink" title="如何解决热点行更新导致的性能问题？"></a>如何解决热点行更新导致的性能问题？</h4><ul><li>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用</li><li>控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了</li><li>将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高</li></ul><p>Innodb 行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL里面的锁可以分为：全局锁、表级锁、行级锁&lt;br&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Network Protocol 7 layers</title>
    <link href="http://yoursite.com/2019/03/08/notes-on-network-protocol-7-layers/"/>
    <id>http://yoursite.com/2019/03/08/notes-on-network-protocol-7-layers/</id>
    <published>2019-03-08T10:24:47.000Z</published>
    <updated>2019-04-14T14:05:14.385Z</updated>
    
    <content type="html"><![CDATA[<p>网络七层协议总结 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a></p><a id="more"></a><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="电脑和电脑使用网线连接"><a href="#电脑和电脑使用网线连接" class="headerlink" title="电脑和电脑使用网线连接"></a>电脑和电脑使用网线连接</h3><p><strong>1-3，2-6</strong>交叉接法。</p><p>水晶头的第 1、2 和第 3、6 脚， 它们分别起着收、发信号的作用。 将一端的 1 号和 3 号线、2 号和 6 号线互换一下位置， 就能够在物理层实现一端发送的信号， 另一端能收到。</p><h3 id="Hub-集线器"><a href="#Hub-集线器" class="headerlink" title="Hub 集线器"></a>Hub 集线器</h3><p>采取的是广播模。遗留的几个问题:</p><ul><li>这个包是发给谁的？谁应该接收？</li><li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li><li>如果发送的时候出现了错误，怎么办？</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p><strong>背景: 上述 HUB 遗留的问题，大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</strong></p><p>Medium Access Control， 媒体访问控制。</p><p>控制在往媒体发数据的时候， 谁先发， 谁后发的问题。 防止发生混乱。 (解决上述第2个问题)， 学名叫<strong>多路访问</strong>， 下面是解决多路访问的三种算法方式。</p><ul><li><p><strong>信道划分</strong></p><p>分多个车道。 每个车一个车道， 你走你的， 我走我的。 这在计算机网里叫作信道划分。</p></li><li><p><strong>轮流协议</strong></p><p>今天单号出行， 明天双号出行， 轮着来。 这在计算机网络里叫作轮流协议。</p></li><li><p><strong>随机接入协议</strong></p><p>不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作随机接入协议。著名的<strong>以太网，用的就是这个方式</strong>。</p></li></ul><h3 id="链路层地址"><a href="#链路层地址" class="headerlink" title="链路层地址"></a>链路层地址</h3><p><strong>解决: 这个包是发给谁的？谁应该接收？</strong></p><p>物理地址， 叫做<strong>链路层(第一层)地址</strong>。 因为第二层主要解决媒体接入控制的问题， 所以它常被称为<code>MAC</code>地址。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413111538.png" alt></p><h4 id="NGINX-访问示例"><a href="#NGINX-访问示例" class="headerlink" title="NGINX 访问示例"></a>NGINX 访问示例</h4><p>有了这个目标 MAC 地址，，<strong>数据包在链路上广播</strong>，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80，而 nginx 就是监听 80。</p><p>于是将请求提交给 nginx，nginx 返回一个网页。然后将网页内容发回请求的机器。然后层层封装，最后到 MAC 层。因为来的时候有源 MAC 地址，返回的时候，源 MAC 就变成了目标 MAC，再返给请求的机器。</p><h4 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h4><p>循环冗余检测</p><p><strong>解决: 如果发送的时候出现了错误，怎么办？</strong></p><p>通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。</p><h4 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h4><p>已知<code>IP</code>地址， 求<code>MAC</code>地址的协议。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413112027.png" alt></p><p>询问和应答的报文：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413112121.png" alt></p><p>机器本地会进行<code>ARP</code>缓存。 <code>ARP</code>的<code>MAC</code>地址缓存过一段时间就会过期。</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>一旦机器数目增多， 问题就出现了。 因为 <strong>Hub</strong> 是广播的，不管某个接口是否需要，所有的<code>Bit</code>都会被发送出去，然后让主机来判断是不是需要。 产生冲突的概率就提高了。</p><p><strong>交换机学习</strong></p><p>一台<code>MAC1</code>电脑将一个包发送给另一台 MAC2 电脑，当这个包到达交换机的时候，一开始交换机也不知道 MAC2 的电脑在哪个口， 所以没办法， 它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住， MAC1 是来自一个明确的口。以后有包的目的地址是 MAC1 的， 直接发送到这个口就可以了。</p><p><strong>转发表</strong></p><p>当交换机作为一个关卡一样, 过了一段时间之后, 就有了整个网络的一个结构了, 这个时候, 基本上不用广播了, 全部可以准确转发. 当然, 每个机器的 IP 地址会变, 所在的口也会变,因而交换机上的学习的结果,我们称为转发表, 是有一个过期时间的.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>MAC</code>层是用来解决多路访问堵车问题的</li><li><code>APR</code>是通过吼的方式来寻找目标的<code>MAC</code>地址的，吼完之后记住一段时间,，这个叫做缓存</li><li>交换机是有<code>MAC</code>地址学习能力的,，学完了它就知道谁在哪儿了，不用广播了</li></ul><h3 id="交换机与-VLAN"><a href="#交换机与-VLAN" class="headerlink" title="交换机与 VLAN"></a>交换机与 VLAN</h3><p>多台交换机之间连接起来, 形成一个<strong>拓扑结构</strong>。</p><p><strong>环路问题</strong>：交换机之间重复发送 ARP 广播</p><p>解决方式：STP (最小生成树)</p><p>多个交换机之间的<strong>广播问题和安全问题</strong></p><ul><li>一大堆机器广播, 性能下降</li><li>有的需要保密, 所有包都会在一个局域网传输, 如果没有加密会有安全问题.</li></ul><p><code>VLAN</code>，<strong>虚拟局域网</strong>。</p><p>使用<code>VLAN</code>, 一个交换机会连属于多个局域网的机器，在原来的二层的头上加一个<code>TAG</code>，里面有一个<code>VLAN ID</code>来区分不同的局域网。<strong>交换机之间可以通过 <code>Trunk</code> 口互相连接</strong></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>也即 IP 层</p><h3 id="ICMP-协议的格式"><a href="#ICMP-协议的格式" class="headerlink" title="ICMP 协议的格式"></a>ICMP 协议的格式</h3><p><code>ICMP</code>全称<code>Internet Control Message Protocol</code>，互联网控制报文协议。是封装在<code>IP</code>报文里面的。</p><p><strong>ICMP</strong>属于网络层(IP)协议。 发送不涉及到传输层， 没有端口的概念。</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413220937.png" alt></p><h3 id="MAC-头和-IP-头的细节"><a href="#MAC-头和-IP-头的细节" class="headerlink" title="MAC 头和 IP 头的细节"></a>MAC 头和 IP 头的细节</h3><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190414204325.png" alt></p><p>任何一台机器，当腰访问另一个IP地址的时候， 会先判断, 这个目标 IP 地址，和当前机器的 IP 地址，是否在同一个网段.。(通过CIDR, 子网掩码)</p><ul><li>如果是同一个网段：<strong>不经过网关</strong>直接将源地址和目标地址放入<code>IP</code>头中。然后通过 ARP 获得 MAC 地址， 将源 <code>MAC</code> 和目的 <code>MAC</code> 放入 <code>MAC</code> 头中，发出去就可以了。</li><li>如果不是同一个网段：需要<strong>发往默认网关GateWay</strong>。Gateway 的地址一定是和源 IP 地址是一个网段的。往往不是第一个，就是第二个。例如 <code>192.168.1.0/24</code> 这个网段，Gateway 往往会是<code>192.168.1.1/24</code> 或者 <code>192.168.1.2/24</code>。(通过 ARP 获得网关 MAC 地址, 然后发送)</li></ul><p>网关往往是一个路由器，是一个三层转发的设备(网络层)。</p><ul><li>一个路由器有多个网口</li><li>一台服务器做这个网关则会有多个网卡, 其中一个网卡是和源IP同网段的</li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 <code>IP</code>地址都和局域网的<code>IP</code>地址相同的网段，每只手都是它握住的那个局域网的网关。</p><p>任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。</p><blockquote><p>MAC 地址是一个局域网内才有效的地址。<code>MAC</code>地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于<code>IP</code>地址是否改变。不改变<code>IP</code>地址的网关，我们称为转发网关；改变<code>IP</code>地址的网关，我们称为<code>NAT</code>网关。</p></blockquote><ul><li><p>静态路由</p><p>配置复杂的策略路由, 控制转发策略</p></li><li><p>动态路由</p><ul><li>距离矢量算法<strong>BGP</strong></li><li>链路状态算法<strong>OSPF</strong></li></ul></li></ul><p>路由器是一台网络设备, 有多张网卡. 当一个口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为<strong>路由表</strong>。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>如果离开本局域网，就需要经过网关，网关是路由器的一个网口</li><li>路由器是一个三层设备，里面有如何寻找下一跳的规则</li><li>转发网关, <strong>MAC变 IP不变</strong></li><li>NAT网关, <strong>IP变</strong></li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层里比较重要的两个协议， <a href>TCP 和 UDP</a></p><h4 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h4><ul><li><p>面向连接</p><p>在互通之前, 面向连接的协议会先<strong>建立连接</strong>。<code>TCP</code>会三次握手，<code>UDP</code>不会</p><blockquote><p>是为了在客户端和服务端维护连接,，而<strong>建立一定的数据结构来维护双方交互的状态, 用这样的数据结构来保证所谓的面向连接的特性</strong>。</p></blockquote></li><li><p>可靠性</p><ul><li>TCP提供可靠交付, 通过<code>TCP</code>连接传输的数据，无差错、不丢失、不重复、并且按序到达</li><li><code>IP</code>包没有任何可靠性。<code>UDP</code>继承了<code>IP</code>包的特性, 不保证不丢失, 不保证按顺序到达</li></ul></li><li>传输<ul><li><code>TCP</code>是面向字节流的。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的<code>IP</code>包。之所以变成了流, 这也是<code>TCP</code>自己的状态维护做的事情</li><li><code>UDP</code>继承了<code>IP</code>的特性, 基于数据报的, 一个一个地发, 一个一个地收</li></ul></li><li>拥塞控制<ul><li><code>TCP</code>是可以拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点</li><li><code>UDP</code>应用让我发，我就发，管它洪水滔天</li></ul></li><li>有状态服务<ul><li><code>TCP</code>其实是一个有状态服务。精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行</li><li><code>UDP</code>是无状态服务, 发出去就发出去了</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>MAC</code>层定义了本地局域网的传输行为,<code>IP</code>层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：</p><p><strong>网络传输</strong>是以<strong>包</strong>为单位的</p><ul><li>二层传输叫<strong>帧</strong></li><li>网络层叫<strong>包</strong></li><li>传输层叫<strong>段</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络七层协议总结 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Network Protocol Overview</title>
    <link href="http://yoursite.com/2019/03/07/notes-on-network-protocol-overview/"/>
    <id>http://yoursite.com/2019/03/07/notes-on-network-protocol-overview/</id>
    <published>2019-03-07T15:00:17.000Z</published>
    <updated>2019-04-14T14:09:06.246Z</updated>
    
    <content type="html"><![CDATA[<p>网络协议大致框架 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a><br><a id="more"></a></p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li><p>应用层</p><p>浏览器输入网址，DNS 查找目标 IP。HTTPS 协议打包请求信息。此处包含 HTTP 头和报文信息。</p></li><li><p>传输层</p><p>通过 socket 编程来实现 TCP ( 面向连接 ) 和 UDP 两种协议。TCP 头包含客户端和服务器监听端口。如果发生丢包，客户端会发包重试。</p></li><li><p>网络层</p><p>操作系统的网络层使用 IP 协议封装 IP 头，包括客户端和服务端 IP。</p></li><li><p>数据链路层</p><p>操作系统通过 ARP 协议查找网关 MAC，封装 MAC 头，包括客户端 MAC 和网关 MAC.</p></li><li><p>物理层</p><p>通过路由协议寻找目标服务器 IP 以及 MAC 地址</p></li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>和客户端相反的方向，服务器校验 MAC 地址正确，取 MAC 头，然后交给操作系统网络层检验 IP ，取 IP 头，再交给传输层，即 TCP 层。这一层里服务端收到的每一个包都要原路返回回复给客户端。TCP 头中包含服务器的端口号，找到服务端的进程对请求处理（此处处理往往通过 RPC 即远程调用方式来实现不同进程间调用通信）。最后再将处理结果原路返回给客户端浏览器。</p><h4 id="网络分层的理解"><a href="#网络分层的理解" class="headerlink" title="网络分层的理解"></a>网络分层的理解</h4><ul><li><strong>只要在网络上跑的包，都是完整的</strong>。<strong>可以有下层没上层，绝不可能有上层没下层</strong></li><li>二层设备收到的是整个网络包。包括 HTTP, TCP, IP, MAC都有。二层设备只把 MAC 头摘下来，看看到底是丢弃、转发、还是自己留着。二层设备是工作在数据链路层的设备，通常是交换机，可以通过地址表确定 MAC 地址和对应端口。如果都不存在会更新地址表。</li><li>三层设备就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发、还是自己留着。三层设备是工作在网络层的设备，通常是指路由器。</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190408174305.png" alt></p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><ul><li>IP 是地址，有定位功能； MAC 是身份证，误定位功能</li><li>CIDR 无类型域间选路。把 IP 分为网络号和主机号，中间斜杠 / 区分</li><li>IP 分公有 IP 和私有 IP</li></ul><h4 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP ( Dynamic Host Configuration Protocol )"></a>DHCP ( Dynamic Host Configuration Protocol )</h4><p>动态主机配置协议。新机器加入会发送一个广播包，里面封装了 MAC 头，IP 头，UDP 头，BOOTP 头，以及请求内容。MAC 地址是唯一的身份，可以确定是否需要分配新的 IP。DHCP server 会广播返回消息包。包括 MAC 头，IP 头，UDP 头，BOOTP 头，同时包含新 IP 地址的合法租用信息和其他配置信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络协议大致框架 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on MySQL Overview</title>
    <link href="http://yoursite.com/2019/03/02/notes-on-MySQL-overview/"/>
    <id>http://yoursite.com/2019/03/02/notes-on-MySQL-overview/</id>
    <published>2019-03-02T10:29:57.000Z</published>
    <updated>2019-04-08T13:42:11.446Z</updated>
    
    <content type="html"><![CDATA[<p>读书笔记：《 MySQL 实战 45 讲》，MySQL 基本原理介绍，极客时间笔记</p><p><em><a id="more"></a></em></p><h2 id="MySQL-基础架构，主要包括-Server-层和储存引擎层"><a href="#MySQL-基础架构，主要包括-Server-层和储存引擎层" class="headerlink" title="MySQL 基础架构，主要包括 Server 层和储存引擎层"></a>MySQL 基础架构，主要包括 Server 层和储存引擎层</h2><ul><li>Server 端<ul><li>连接器：管理连接、权限验证</li><li>分析器：词法分析、语法分析</li><li>优化器：执行计划生成、索引选择</li><li>执行器：操作引擎、返回结果</li></ul></li><li>存储引擎层负责数据的存储和提取。场景的存储引擎有 <strong>InnoDB</strong>( 5.5 之后为默认)、MyISAM、Memory</li></ul><p>逻辑架构图：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190402184504.png" alt></p><h2 id="日志系统-redo-log-和-binLog"><a href="#日志系统-redo-log-和-binLog" class="headerlink" title="日志系统 redo log 和 binLog"></a>日志系统 redo log 和 binLog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(ID int primary key, c int);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update T <span class="built_in">set</span> c=c+1 <span class="built_in">where</span> ID=2;</span></span><br></pre></td></tr></table></figure><h4 id="InnodDB-redo-log"><a href="#InnodDB-redo-log" class="headerlink" title="InnodDB redo log"></a>InnodDB redo log</h4><p>如果每次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候，这就像打烊以后掌柜做的事。</p><ul><li>WAL技术：Write-Ahead Logging，先写日志，再写磁盘</li><li>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里，并更新内存。其它合适时间再写入磁盘</li></ul><p>有了redo log，Inno DB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><h4 id="MySQL-binlog（归档日志）"><a href="#MySQL-binlog（归档日志）" class="headerlink" title="MySQL binlog（归档日志）"></a>MySQL binlog（归档日志）</h4><p>redo log是 InnoDB 引擎特有的日志，而Server层也有自己的日志，称为binlog。</p><h4 id="redo-log-和-binlog-不同点"><a href="#redo-log-和-binlog-不同点" class="headerlink" title="redo log 和 binlog 不同点"></a>redo log 和 binlog 不同点</h4><ul><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL的 Server 层实现的，所有引擎都能用</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的，写到一定大小会切换到下一个文件，不会覆盖以前的日志</li></ul><p>我们来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ul><li>执行器先找引擎取 ID = 2 这一行。 ID 是主键，引擎直接用树搜索找到这一行。如果ID = 2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</li><li>执行器拿到引擎给的行数据，把这个值加上 1 ，比如原来是 N ， 现在就是 N+1 ，得到新的一行数据，再调用引擎接口写入这行新数据</li><li>引擎将这行数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状体啊。然后告知执行期执行完成了，随时可以提交事务</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成 提交（commit）状态，更新完成</li></ul><h4 id="redolog两阶段提交"><a href="#redolog两阶段提交" class="headerlink" title="redolog两阶段提交"></a>redolog两阶段提交</h4><p>redo log 和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>事务：ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><p>隔离级别：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</p><p>事务隔离的实现：在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>长事务：系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h4 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h4><ul><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback</li><li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit  或  rollback 语句，或者断开连接</li></ul><p>建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。避免长连接导致长事务。</p><h4 id="查询长事务"><a href="#查询长事务" class="headerlink" title="查询长事务"></a>查询长事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60; -- 查找持续时间超过60s的事务</span><br></pre></td></tr></table></figure><h2 id="深入浅出索引"><a href="#深入浅出索引" class="headerlink" title="深入浅出索引"></a>深入浅出索引</h2><h4 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h4><ul><li>哈希表 ( 查询效率不高 )</li><li>有序数组 （ 增删效率低，适合静态存储 ）</li><li><strong>搜索树</strong></li></ul><h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul><li><p>主键索引</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）</p></li><li><p>非主键索引</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create table T(</span></span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 <a href="https://www.shinhwa.wang/2019/04/04/binary-tree-B-tree-B+-Tree/" target="_blank" rel="noopener">B+ 树</a> ；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该<strong>尽量使用主键查询</strong>。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><h4 id="索引下推-（index-condition-pushdown"><a href="#索引下推-（index-condition-pushdown" class="headerlink" title="索引下推 （index condition pushdown)"></a>索引下推 （index condition pushdown)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from tuser <span class="built_in">where</span> name like <span class="string">'张%'</span> and age=10 and ismale=1;</span></span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405153458.png" alt></p><p><strong>InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读书笔记：《 MySQL 实战 45 讲》，MySQL 基本原理介绍，极客时间笔记&lt;/p&gt;
&lt;p&gt;&lt;em&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Tcpdump and Wireshark</title>
    <link href="http://yoursite.com/2019/02/27/notes-on-tcpdump-and-Wireshark/"/>
    <id>http://yoursite.com/2019/02/27/notes-on-tcpdump-and-Wireshark/</id>
    <published>2019-02-27T13:44:24.000Z</published>
    <updated>2019-04-07T15:05:54.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tcpdump-和-Wireshark"><a href="#tcpdump-和-Wireshark" class="headerlink" title="tcpdump 和 Wireshark"></a>tcpdump 和 Wireshark</h3><p>这个例子只是执行 ping 指令的一个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn udp port 53 or host x.x.x.x -w ping.pcap</span><br></pre></td></tr></table></figure><ul><li>-nn 不解析抓包中的域名（不反向解析）、协议以及端口号</li><li>udp port 53 只显示 UDP 协议的端口号（包括源端口和目的端口）为 53 的包</li><li>host x.x.x.x 只显示 IP 地址（包括原地址和目的地址）为 x.x.x.x 的包</li><li>or 或的关系</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900591970.png" alt></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900605148.png" alt></p><p>HTTP 的一个例子，便于理解 TCP 三次握手和四次挥手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn host example.com -w web.pcap</span><br><span class="line">curl example.com</span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901484205.png" alt></p><p>可以看到TCP 三次握手和四次挥手的请求</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901518443.png" alt></p><p>顺便复习一下流程：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901543490.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tcpdump-和-Wireshark&quot;&gt;&lt;a href=&quot;#tcpdump-和-Wireshark&quot; class=&quot;headerlink&quot; title=&quot;tcpdump 和 Wireshark&quot;&gt;&lt;/a&gt;tcpdump 和 Wireshark&lt;/h3&gt;&lt;p&gt;这个
      
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Tcpdump" scheme="http://yoursite.com/tags/Tcpdump/"/>
    
      <category term="Wireshark" scheme="http://yoursite.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 206. Reverse Linked List</title>
    <link href="http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/"/>
    <id>http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/</id>
    <published>2019-02-26T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>单链表反转</p><p>题目来源：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/?</p><p>代码效率：100%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>迭代法：将当前节点的后继节点指向前一个节点，移动当前节点</p><p>递归法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nonesense"><a href="#Nonesense" class="headerlink" title="Nonesense"></a>Nonesense</h3><p>最简单的单链表居然花费了我半天的时间，最后还是参考别人的答案才写出来。。。智商捉急</p><p>总结一下问题：</p><ul><li>太急躁，要静下心来慢慢梳理过程，整理成代码输出</li><li><strong>java变量指针等概念感觉还是不清晰</strong>，今天抽空需要补一下</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;单链表反转&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 448 Find All Numbers Disappeared in an Array</title>
    <link href="http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/"/>
    <id>http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/</id>
    <published>2019-02-24T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：</p><p>题目来源：<a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/N</p><p>代码效率： 95.58%</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>取负法：不管一个元素出现一次还是两次，只要出现它对应的位置就会被取负。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[val] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nums[val] = -nums[val];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>感觉这个题就是单纯考虑数学技巧，做起来比较吃力，看答案的时候豁然开朗，还是慢慢积累吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 283 Move Zeroes</title>
    <link href="http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/"/>
    <id>http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/</id>
    <published>2019-02-23T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变</p><p>题目来源：<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一个快指针，一个慢指针，快指针指向不为0的元素，快慢指针值交换，同时向后移动一位。这样可以保证下面两个条件：</p><ul><li>快慢指针之间的元素都是0</li><li>慢指针之前的元素都不为0<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>一开始理解错误，以为把0都放到后面之后还是要对前面从大到小进行排序。。。结果想了半天</p><p>以后还是要仔细审题，不要怀疑自己，先用自己的想法暴力实现</p><p>写代码之前可以举个栗子来一步一步推敲，想好边界和规律再写代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 136. Single Number</title>
    <link href="http://yoursite.com/2019/02/22/leetcode-136-single-number/"/>
    <id>http://yoursite.com/2019/02/22/leetcode-136-single-number/</id>
    <published>2019-02-22T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。</p><p>题目来源：<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用异或 <code>^</code></p><ul><li>两个相同的数异或后为0</li><li>0和一个数异或后为那个数</li><li>异或运算满足交换律</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            result^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 226. Invert Binary Tree</title>
    <link href="http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/"/>
    <id>http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/</id>
    <published>2019-02-21T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>反转二叉树左右子树</p><p>题目来源：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/ N</p><p>代码效率：100.00%</p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>左子树和右子树递归互换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>对递归还是理解不透彻，总结一下如何处理递归问题：</p><blockquote><p>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;反转二叉树左右子树&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/invert-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/invert-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 104. Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/"/>
    <id>http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/</id>
    <published>2019-02-20T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>计算二叉树的深度</p><p>题目来源：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：思路很乱，参考 Discuss 的答案</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>递归左右子树，对深度最大的子树进行递归调用并+1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;计算二叉树的深度&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-depth-of-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 617 Merge Two Binary Trees</title>
    <link href="http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/"/>
    <id>http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/</id>
    <published>2019-02-19T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。</p><p>题目来源：<a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-binary-trees/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/1</p><p>代码效率：98.24%</p><p>耗时：25分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>主要考察对递归算法的理解。</p><ul><li>首先考虑边界，如果两个子二叉树都为空，则新的二叉树必定为空</li><li>考虑其中一个子二叉树为空，则新的二叉树直接等于另外一个子二叉树</li><li>如果两个子二叉树都不为空，新二叉树节点值为两个子二叉树对应节点的值的和，同时对两个子二叉树的左右子树进行递归调用，仔细想想就明白了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode ret;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">            ret.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">            ret.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然别人思路的总是最好的 o(╥﹏╥)o</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    TreeNode result = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    result.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    result.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>学习数据结构的时候，总感觉递归对自己来说是弱项，智商不够用。今天居然一次性直接做出来了。学习数据结构和算法真的能培养思维逻辑和解决问题的能力。fighting !!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-two-binary-trees/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 461 Hamming Distance</title>
    <link href="http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/"/>
    <id>http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/</id>
    <published>2019-02-18T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.233Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>统计两个整数转换成二进制位时位数不同的个数。</p><p>题目来源：<a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/hamming-distance/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/2 (少写了 return 语句。。)</p><p>代码效率：91.77%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>二进制的每一位的值不是 0 就是 1，就是整数除以 2 取余的结果，判断是否相等。然后再取模（相当于向左移动一位），再取余作比较。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span> || y != <span class="number">0</span>)&#123;</span><br><span class="line">            i = x % <span class="number">2</span>;</span><br><span class="line">            j = y % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">            y = y / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人的一行代码实现Orz：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;统计两个整数转换成二进制位时位数不同的个数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/hamming-distance/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 771 Jewels And Stones</title>
    <link href="http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/"/>
    <id>http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/</id>
    <published>2019-02-17T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。</p><p>题目来源：<a href="https://leetcode.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode.com/problems/jewels-and-stones/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/4</p><p>代码效率：93.10%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>把 J 和S 转换成字符数组，遍历 J 数组中的字符是否等于 S 中的 字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charJ = J.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charS = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> <span class="keyword">var</span> : charJ)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;charS.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">var</span> == charS[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人还有更好的做法：</p><ul><li>遍历 J 把字符放入 set 集合</li><li>遍历 S 字符是否出现在 set 中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Set setJ = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> j: J.toCharArray()) setJ.add(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> s: S.toCharArray()) <span class="keyword">if</span> (setJ.contains(s)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>第一次开始刷 Leetcode ,虽然做的是 easy 的题目，但还是没有参考其他人的答案自己完成了。开始有一点新鲜感和成就感了，希望可以坚持下去。</p><p>刚开始刷题使用的是 VS CODE 码代码，在网上看了一些网友的建议，为了应对后续面试可能要求手写编程的情况，所以现在是先用 IDE 把代码写出来，再手写输入 Leetcode 提交答案。</p><p>加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/jewels-and-stones/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/jewels-and-stones/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Tips</title>
    <link href="http://yoursite.com/2019/02/15/Leetcode-tips/"/>
    <id>http://yoursite.com/2019/02/15/Leetcode-tips/</id>
    <published>2019-02-15T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.234Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。</p><p>数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：<br><a id="more"></a></p><ul><li><p>数据结构与算法之美</p><p>极客时间的一个专栏，内容通俗易懂，适合入门</p></li><li><p>数据结构与算法分析：Java语言描述</p><p>下一步打算看的书籍</p></li><li><p>经典大作：算法，算法导论</p></li></ul><p>附数据结构与算法之美推荐书单：<br><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407333793.png" alt></p><h3 id="Leetcode-刷题方法"><a href="#Leetcode-刷题方法" class="headerlink" title="Leetcode 刷题方法"></a>Leetcode 刷题方法</h3><p>在刚开始刷 Leetcode 时，很多人只有在看完答案才知道要怎么做，如果不看答案的话完全没有思路。这是非常正常的现象，并不表示你的思维能力比别人差。人类最擅长的学习方式是模仿，刚开始刷题的时候不会做看看别人怎么做是很正确的做法，模仿多了自然就会做了。</p><p>刷 Leetcode 也有两种流派：龟派和兔派。龟派每道题都要想很久，而且尽可能想出多种解法。兔派是想一会儿就看答案，这样就可以很快地刷题。龟派比较适合思维锻炼，而兔派比较适合短期内快速提高并记忆。如果是为了应对校招的话，比较推荐兔派这种刷题方法，因为校招确实很依赖于短期记忆。选择兔派这种方式的话，就需要反复地进行复习，从而保持记忆并增加理解。但是也不能完全采用兔派这种方法，因为如果习惯于不去思考怎么做的话，会养成惰性的思维方式。</p><p>当你刷题到一定程度的时候，最好每天再刷一两题保持题感。可以选你之前做过的题目，因为你再做一遍的话可以很快做出来，这样子就可以让你对刷题这件事保持积极的一种心态。</p><p>刷 Leetcode 的收益如下图所示，可以看到刷的越多收益增长的越小。刷 200 题就足够应对大多数互联网公司的校招，但是如果时间不够的话刷 100 题也是有很大的收益，可以刷一下 <a href="https://leetcode.com/problemset/top-100-liked-questions/" target="_blank" rel="noopener">Top 100 Liked Questions</a>。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407398105.png" alt></p><ul><li>排序：大部分要求能手写，并分析时间空间复杂度，以及稳定性</li><li>树：红黑树的原理以及在 JDK 的使用；B+ 树以及在数据库索引中的使用</li><li>图：拓扑排序；并查集；最短路径；最小生成树</li><li>散列表：实现原理，以及在 JDK 中的使用</li><li>字符串：KMP；AC 自动机；Trie 树</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。&lt;/p&gt;
&lt;p&gt;数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 20 Summary. Red Black Tree</title>
    <link href="http://yoursite.com/2019/02/13/beauty-of-algorithms-20-summary-red-black-tree/"/>
    <id>http://yoursite.com/2019/02/13/beauty-of-algorithms-20-summary-red-black-tree/</id>
    <published>2019-02-12T16:45:30.000Z</published>
    <updated>2019-03-31T15:02:57.218Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树的数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n,所以它是近似平衡， 插入、删除、查找操作的时间复杂度都是O(logn)。<br><a id="more"></a><br>红黑树非常复杂，无法永久记忆它的平衡调整策略。</p><p>有时间深入了解一下 :)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树的数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n,所以它是近似平衡， 插入、删除、查找操作的时间复杂度都是O(logn)。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Red Black Tree" scheme="http://yoursite.com/tags/Red-Black-Tree/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 19 Summary. Binarytree</title>
    <link href="http://yoursite.com/2019/02/09/beauty-of-algorithms-19-summary-binarytree/"/>
    <id>http://yoursite.com/2019/02/09/beauty-of-algorithms-19-summary-binarytree/</id>
    <published>2019-02-08T16:45:30.000Z</published>
    <updated>2019-03-31T15:02:57.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li><p>节点</p><p>树中的元素称之为节点</p></li><li><p>高度</p><ul><li><p>节点的高度</p><p>节点到叶子节点的最长路径</p></li><li><p>树的高度</p><p>跟节点的高度</p></li></ul></li><li><p>深度</p><p>根节点到这个节点所经历的边的个数</p></li><li><p>层</p><p>节点的深度+1</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797246423.png" alt></p><h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3></li><li><p>满二叉树</p><p>除了叶子结点外每个节点都有左右两个子节点</p></li><li><p>完全二叉树</p><p>叶子结点都在最低下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797311876.png" alt></p><h3 id="表示、存储一棵二叉树"><a href="#表示、存储一棵二叉树" class="headerlink" title="表示、存储一棵二叉树"></a>表示、存储一棵二叉树</h3><p><strong>链式存储法</strong></p><p>每个结点有三个字段，其中一个存储数据，另两个是指向左右子节点的指针。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797363532.png" alt></p><p><strong>顺序存储法(基于数组)</strong></p><p>根节点存储在下标i=1的位置，左子节点存储在下标2<em>i=2的位置，右子节点存储在2</em>i+1=3的位置，以此类推。</p><p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 的位置存储的就是右子节点。<br>我们只要知道根节点存储的位置，这样就可以通过下标计算，把整棵树都串起来。</p><p>为了方便计算子节点，根节点会存储在下标为 1 的位置</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797402073.png" alt></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>前序遍历</p><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></li><li><p>中序遍历</p><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></li><li><p>后序遍历</p><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p></li><li><p>层序遍历</p><p>从树的第一层开始从左到右打印节点</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797580379.png" alt></p><p>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</p><p>比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p><h3 id="二叉树以及二叉树遍历代码实现"><a href="#二叉树以及二叉树遍历代码实现" class="headerlink" title="二叉树以及二叉树遍历代码实现"></a><strong>二叉树以及二叉树遍历代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BinaryTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            root.data = data;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add(root, <span class="keyword">new</span> Node(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node root, Node newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode.data &lt; root.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.leftNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.leftNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.leftNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.rightNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.rightNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHigh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前序遍历："</span>);</span><br><span class="line">        pre(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            pre(node.leftNode);</span><br><span class="line">            pre(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"中序遍历："</span>);</span><br><span class="line">        in(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            in(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            in(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后序遍历："</span>);</span><br><span class="line">        post(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            post(node.rightNode);</span><br><span class="line">            post(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node leftNode;</span><br><span class="line">        <span class="keyword">private</span> Node rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.leftNode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rightNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        BinaryTree t = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        t.add(<span class="number">40</span>);</span><br><span class="line">        t.add(<span class="number">25</span>);</span><br><span class="line">        t.add(<span class="number">78</span>);</span><br><span class="line">        t.add(<span class="number">10</span>);</span><br><span class="line">        t.add(<span class="number">32</span>);</span><br><span class="line">        t.add(<span class="number">50</span>);</span><br><span class="line">        t.add(<span class="number">93</span>);</span><br><span class="line">        t.add(<span class="number">3</span>);</span><br><span class="line">        t.add(<span class="number">17</span>);</span><br><span class="line">        t.add(<span class="number">30</span>);</span><br><span class="line">        t.add(<span class="number">38</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t.getLow());</span><br><span class="line">        System.out.println(t.getHigh());</span><br><span class="line">        System.out.println(<span class="string">"Size-"</span> + t.size);</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        t.inOrder();</span><br><span class="line">        t.preOrder();</span><br><span class="line">        t.postOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 Binary Search Tree"></a>二叉查找树 Binary Search Tree</h2><h3 id="二叉查找树的定义"><a href="#二叉查找树的定义" class="headerlink" title="二叉查找树的定义"></a>二叉查找树的定义</h3><p>二叉查找树又称二叉搜索树。其要求在二叉树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树的节点的值都大于这个节点的值。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550049430176.png" alt></p><h3 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h3><p><strong>二叉树类、节点类以及查找方法的代码实现</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064373887.png" alt></p><p>先取根节点，如果它等于我们要查找的数据，那就返回。</p><p>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</p><p>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉查找树的插入操作</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064441773.png" alt></p><p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p><p>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉查找树的删除操作</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064532346.png" alt></p><p>第一种情况，删除的节点没有子节点直接将其父节点指向置为null。</p><p>第二种情况，删除的节点只有一个子节点，将其父节点指向其子节点。</p><p>第三种情况，删除的节点有两个子节点，首先找到该节点右子树中最小的的节点把他替换掉要删除的节点 然后再删除这个最小的节点，该节点必定没有子节点，否则就不是最小的节点了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 先找到要删除的节点 </span></span><br><span class="line"><span class="comment"> * 2. 如果这个节点有两个叶子节点，找到右子树的最小值，替换当前的这个节点值，同时删除这个最小值 </span></span><br><span class="line"><span class="comment"> * 3.如果这个节点只有一个叶子节点，用叶子节点的值替换当前节点的值 </span></span><br><span class="line"><span class="comment"> * 4. 如果这个节点没有叶子节点，直接删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = root;</span><br><span class="line">    Node pp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node minP = p;</span><br><span class="line">        Node minPP = pp;</span><br><span class="line">        <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p.data = minP.data;</span><br><span class="line">        p = minP;</span><br><span class="line">        pp = minpp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node child;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">        pp.left = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pp.right = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。</p><p>这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><h3 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a><strong>二叉查找树的其他操作</strong></h3><p>二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。</p><p>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</p><h3 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h3><p>前面的二叉查找树的操作，我们默认树中节点存储的都是数字，针对的都是不存在键值相同的情况。</p><p>我们可以通过两种办法来构建支持重复数据的二叉查找树。</p><ul><li><p>第一种方法</p><p>二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p></li><li><p>第二种方法</p><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p><p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p></li></ul><h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p><strong>最坏、最好情况</strong></p><p>如果根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p><p>最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。而完全二叉树的高度小于等于 log2n。</p><p><strong>平衡二叉查找树</strong></p><p>我们需要构建一种不管怎么删除、插入数据，在任何时候都能保持任意节点左右子树都比较平衡的二叉查找树，这就是一种特殊的二叉查找树，平衡二叉查找树。</p><p>平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)。</p><h3 id="二叉查找树相比散列表的优势"><a href="#二叉查找树相比散列表的优势" class="headerlink" title="二叉查找树相比散列表的优势"></a>二叉查找树相比散列表的优势</h3><p><strong>散列表中的数据是无序存储的</strong></p><p>如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</p><p><strong>散列表扩容耗时很多</strong></p><p>而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p><p><strong>散列表存在哈希冲突</strong></p><p>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。</p><p>加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p><strong>散列表装载因子不能太大</strong></p><p>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h3&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
