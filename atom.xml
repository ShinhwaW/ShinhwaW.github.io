<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shinhwa&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-07T13:39:15.601Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shinhwa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IPA Sounds And Exmaples</title>
    <link href="http://yoursite.com/2019/04/07/phonetic-alphabet/"/>
    <id>http://yoursite.com/2019/04/07/phonetic-alphabet/</id>
    <published>2019-04-07T03:53:21.000Z</published>
    <updated>2019-04-07T13:39:15.601Z</updated>
    
    <content type="html"><![CDATA[<p>Examples of IPA use in common English words.<br>List of challenging English sounds and words especially for Chinese people.<br><a id="more"></a></p><h3 id="Diphthong-Vowels"><a href="#Diphthong-Vowels" class="headerlink" title="Diphthong Vowels"></a>Diphthong Vowels</h3><p>The key is to pronounce two symbols clearly</p><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">aʊ</td><td style="text-align:center">Mouth, house, brown, cow, out, downtown</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">əʊ</td><td style="text-align:center">No, don’t, stones, alone, hole, ghost</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">eɪ</td><td style="text-align:center">Face, space, rain , case, eight, name</td><td style="text-align:center">two symbols</td></tr><tr><td style="text-align:center">aɪ</td><td style="text-align:center">My, sight, pride, kind, flight, time</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɔɪ</td><td style="text-align:center">Joy, employ, toy, coil, oyster, point, coin</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʊə</td><td style="text-align:center">lure, tour</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">eə</td><td style="text-align:center">Hair, there, care, stairs, pear, fair, stare</td><td style="text-align:center">tongue back enough</td></tr></tbody></table><h3 id="Short-Vowels-Or-Single-Vowels"><a href="#Short-Vowels-Or-Single-Vowels" class="headerlink" title="Short Vowels Or Single Vowels"></a>Short Vowels Or Single Vowels</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">æ</td><td style="text-align:center">Cat, hand, nap, flat, have, apple</td><td style="text-align:center">tongue back enough</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">Went, intend, send, letter, bed, step</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʌ</td><td style="text-align:center">Fun, love, money, one, London, come, hungry, but</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɒ</td><td style="text-align:center">Rob, top, watch, squat, sausage, job</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ə</td><td style="text-align:center">Alive, again, mother, toward, banana</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʊ</td><td style="text-align:center">Put, look, should, cook, book, look, good</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɪ</td><td style="text-align:center">city, skin, kill, sit</td><td style="text-align:center">expand mouth</td></tr></tbody></table><h3 id="Long-Vowels"><a href="#Long-Vowels" class="headerlink" title="Long Vowels"></a>Long Vowels</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">ɑ:</td><td style="text-align:center">Fast, car, hard, bath, garden, park</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɔ:</td><td style="text-align:center">Talk, law, bored, yawn, jaw, soft, loft</td><td style="text-align:center">tongue back enough</td></tr><tr><td style="text-align:center">ɜ:</td><td style="text-align:center">Nurse, heard, third, turn, earth, earn</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">u:</td><td style="text-align:center">Few, boot, lose, gloomy, fruit, chew, do</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">i:</td><td style="text-align:center">Need, beat, team, me, keen</td><td style="text-align:center">expand mouth</td></tr></tbody></table><h3 id="Consonants-Sounds"><a href="#Consonants-Sounds" class="headerlink" title="Consonants Sounds"></a>Consonants Sounds</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">l</td><td style="text-align:center">large, milk, pill, chill, melt</td><td style="text-align:center">Approximants / tongue touch teeth</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">Room, mother, mad, more</td><td style="text-align:center">Nasals</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">Now, nobody, knew, turn</td><td style="text-align:center">Nasals</td></tr><tr><td style="text-align:center">ŋ</td><td style="text-align:center">King, thing, song, swimming, long, rank</td><td style="text-align:center">tongue touch roof of back mouth</td></tr><tr><td style="text-align:center">θ</td><td style="text-align:center">Thank, Think, Bath, Mouth</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ð</td><td style="text-align:center">There, those, brothers, others</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">snake, sense</td><td style="text-align:center">expand mouth</td></tr><tr><td style="text-align:center">z</td><td style="text-align:center">Zoo, crazy, lazy, zigzag, nose, close</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ts</td><td style="text-align:center">treats, tweets</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dz</td><td style="text-align:center">ends, bends, friends</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">f</td><td style="text-align:center">Full, Friday, fish, knife, fair, fine</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">Vest, village, view, cave, live, very</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">Cash, quick, cricket, sock, kind, clock</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">Girl, green, grass, flag, great, egg</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">Time, train, tow, late, tour</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">Door, day, drive, down, feed, dog</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">Pin, cap, purpose, pause, pet</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">Bag, bubble, build, robe, bus</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʈʃ</td><td style="text-align:center">Choose, cheese, church, watch, chance</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dʒ</td><td style="text-align:center">Joy, juggle, juice, stage, jar</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʃ</td><td style="text-align:center">Shirt, rush, shop, cash, shut, shall</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʒ</td><td style="text-align:center">Television, delusion, casual, leisure</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">tr</td><td style="text-align:center">trend, treasure</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dr</td><td style="text-align:center">drive, dry</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">High, help, hello, have</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">Road, roses, river, ring, ride, rare, rest</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">Wall, walk, wine, world, where, what</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">Yellow, usual, yield, yesterday, yard.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Examples of IPA use in common English words.&lt;br&gt;List of challenging English sounds and words especially for Chinese people.&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="http://yoursite.com/categories/English/"/>
    
    
      <category term="International Phonetic Alphabet" scheme="http://yoursite.com/tags/International-Phonetic-Alphabet/"/>
    
      <category term="IPA" scheme="http://yoursite.com/tags/IPA/"/>
    
      <category term="Pronunciation" scheme="http://yoursite.com/tags/Pronunciation/"/>
    
  </entry>
  
  <entry>
    <title>Binary tree B tree B+ Tree</title>
    <link href="http://yoursite.com/2019/04/04/binary-tree-B-tree/"/>
    <id>http://yoursite.com/2019/04/04/binary-tree-B-tree/</id>
    <published>2019-04-04T10:29:05.000Z</published>
    <updated>2019-04-06T04:46:36.595Z</updated>
    
    <content type="html"><![CDATA[<p>平衡二叉树、B树、B+树、B*树 </p><a id="more"></a><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p><ul><li>非叶子节点只能允许最多两个子节点存在</li><li>每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)</li></ul><p>平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如AVL、<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/Treap" target="_blank" rel="noopener">Treap</a>、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1.，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115440.png" alt></p><p>总结平衡二叉树特点：</p><ul><li>非叶子节点最多拥有两个子节点</li><li>非叶子节值大于左边子节点、小于右边子节点</li><li>树的左右两边的层级数相差不会大于1</li><li>没有值相等重复的节点</li></ul><h2 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a><strong>B树(B-tree)</strong></h2><p>注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）</li><li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</li></ul><p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115645.png" alt></p><h4 id="B树的查询流程"><a href="#B树的查询流程" class="headerlink" title="B树的查询流程"></a><strong>B树的查询流程</strong></h4><p>如上图我要从上图中找到E字母，查找流程如下</p><ul><li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）</li></ul><h4 id="B树的插入节点流程"><a href="#B树的插入节点流程" class="headerlink" title="B树的插入节点流程"></a><strong>B树的插入节点流程</strong></h4><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来</p><p>遵循规则</p><ul><li>节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）</li><li>排序规则：满足节点本身比左边节点大，比右边节点小的排序规则</li></ul><p>先插入 3、8、31、11</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115817.png" alt></p><p>再插入23、29</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405144609.png" alt></p><p>再插入50、28</p><p><img src="C:\develop\blog\newblog\source\_posts\assets\1554446788867.png" alt="1554446788867"></p><h4 id="B树节点的删除"><a href="#B树节点的删除" class="headerlink" title="B树节点的删除"></a><strong>B树节点的删除</strong></h4><p><strong>规则</strong></p><ul><li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）</li><li>满足节点本身比左边节点大，比右边节点小的排序规则</li><li>关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405144759.png" alt></p><p><strong>特点</strong></p><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a><strong>B+ 树</strong></h2><p><strong>概念</strong></p><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p><p><strong>规则</strong></p><ul><li>B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针</li><li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405145634.png" alt></p><p><strong>（百度百科算法结构示意图）</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405150344.png" alt></p><p><strong>（维基百科算法结构示意图）</strong></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快</li><li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定</li><li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描</li><li><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a><strong>B*树</strong></h2><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a><strong>规则</strong></h4><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ul><li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</li><li>B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来</li></ul><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h4><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405150527.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><p><strong>相同思想和策略</strong></p><p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度</p></li><li><p><strong>不同的方式的磁盘空间利用</strong></p><p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的</p></li></ul><p>文章转载自 <a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27700617</a></p><p>参考</p><p>附（二分法查找）：<a href="https://zhuanlan.zhihu.com/p/27597160" target="_blank" rel="noopener">二分法查找原理 - 知乎专栏</a></p><p>附（B、B+、B<em>树）：[从B树、B+树、B</em>树谈到R 树](<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="noopener">https://link.zhihu.com/?target=http%3A//blog.csdn.net/v_JULY_v/article/details/6530142/</a>)</p><p>附（B、B+、B*树）：<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/endlu/article/details/51720299" target="_blank" rel="noopener">end’s coding life</a></p><p>附：<a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">B树和B+树的插入、删除图文详解 - nullzx - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平衡二叉树、B树、B+树、B*树 &lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Network Protocol 7 layers</title>
    <link href="http://yoursite.com/2019/03/08/notes-on-network-protocol-7-layers/"/>
    <id>http://yoursite.com/2019/03/08/notes-on-network-protocol-7-layers/</id>
    <published>2019-03-08T10:24:47.000Z</published>
    <updated>2019-04-08T13:29:56.717Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Network Protocol Overview</title>
    <link href="http://yoursite.com/2019/03/07/notes-on-network-protocol-overview/"/>
    <id>http://yoursite.com/2019/03/07/notes-on-network-protocol-overview/</id>
    <published>2019-03-07T15:00:17.000Z</published>
    <updated>2019-04-08T10:21:35.456Z</updated>
    
    <content type="html"><![CDATA[<p>网络协议大致框架<br><a id="more"></a></p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li><p>应用层</p><p>浏览器输入网址，DNS 查找目标 IP。HTTPS 协议打包请求信息。此处包含 HTTP 头和报文信息。</p></li><li><p>传输层</p><p>通过 socket 编程来实现 TCP ( 面向连接 ) 和 UDP 两种协议。TCP 头包含客户端和服务器监听端口。如果发生丢包，客户端会发包重试。</p></li><li><p>网络层</p><p>操作系统的网络层使用 IP 协议封装 IP 头，包括客户端和服务端 IP。</p></li><li><p>数据链路层</p><p>操作系统通过 ARP 协议查找网关 MAC，封装 MAC 头，包括客户端 MAC 和网关 MAC.</p></li><li><p>物理层</p><p>通过路由协议寻找目标服务器 IP 以及 MAC 地址</p></li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>和客户端相反的方向，服务器校验 MAC 地址正确，取 MAC 头，然后交给操作系统网络层检验 IP ，取 IP 头，再交给传输层，即 TCP 层。这一层里服务端收到的每一个包都要原路返回回复给客户端。TCP 头中包含服务器的端口号，找到服务端的进程对请求处理（此处处理往往通过 RPC 即远程调用方式来实现不同进程间调用通信）。最后再将处理结果原路返回给客户端浏览器。</p><h4 id="网络分层的理解"><a href="#网络分层的理解" class="headerlink" title="网络分层的理解"></a>网络分层的理解</h4><ul><li><strong>只要在网络上跑的包，都是完整的</strong>。<strong>可以有下层没上层，绝不可能有上层没下层</strong></li><li>二层设备收到的是整个网络包。包括 HTTP, TCP, IP, MAC都有。二层设备只把 MAC 头摘下来，看看到底是丢弃、转发、还是自己留着。二层设备是工作在数据链路层的设备，通常是交换机，可以通过地址表确定 MAC 地址和对应端口。如果都不存在会更新地址表。</li><li>三层设备就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发、还是自己留着。三层设备是工作在网络层的设备，通常是指路由器。</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190408174305.png" alt></p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><ul><li>IP 是地址，有定位功能； MAC 是身份证，误定位功能</li><li>CIDR 无类型域间选路。把 IP 分为网络号和主机号，中间斜杠 / 区分</li><li>IP 分公有 IP 和私有 IP</li></ul><h4 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP ( Dynamic Host Configuration Protocol )"></a>DHCP ( Dynamic Host Configuration Protocol )</h4><p>动态主机配置协议。新机器加入会发送一个广播包，里面封装了 MAC 头，IP 头，UDP 头，BOOTP 头，以及请求内容。MAC 地址是唯一的身份，可以确定是否需要分配新的 IP。DHCP server 会广播返回消息包。包括 MAC 头，IP 头，UDP 头，BOOTP 头，同时包含新 IP 地址的合法租用信息和其他配置信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络协议大致框架&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on MySQL</title>
    <link href="http://yoursite.com/2019/03/02/notes-on-MySQL/"/>
    <id>http://yoursite.com/2019/03/02/notes-on-MySQL/</id>
    <published>2019-03-02T10:29:57.000Z</published>
    <updated>2019-04-07T15:05:16.941Z</updated>
    
    <content type="html"><![CDATA[<p>读书笔记：《 MySQL 实战 45 讲》，MySQL 基本原理介绍，极客时间笔记</p><p><em><a id="more"></a></em></p><h2 id="MySQL-基础架构，主要包括-Server-层和储存引擎层"><a href="#MySQL-基础架构，主要包括-Server-层和储存引擎层" class="headerlink" title="MySQL 基础架构，主要包括 Server 层和储存引擎层"></a>MySQL 基础架构，主要包括 Server 层和储存引擎层</h2><ul><li>Server 端<ul><li>连接器：管理连接、权限验证</li><li>分析器：词法分析、语法分析</li><li>优化器：执行计划生成、索引选择</li><li>执行器：操作引擎、返回结果</li></ul></li><li>存储引擎层负责数据的存储和提取。场景的存储引擎有 <strong>InnoDB</strong>( 5.5 之后为默认)、MyISAM、Memory</li></ul><p>逻辑架构图：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190402184504.png" alt></p><h2 id="日志系统-redo-log-和-binLog"><a href="#日志系统-redo-log-和-binLog" class="headerlink" title="日志系统 redo log 和 binLog"></a>日志系统 redo log 和 binLog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> create table T(ID int primary key, c int);</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><h4 id="InnodDB-redo-log"><a href="#InnodDB-redo-log" class="headerlink" title="InnodDB redo log"></a>InnodDB redo log</h4><p>如果每次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候，这就像打烊以后掌柜做的事。</p><ul><li>WAL技术：Write-Ahead Logging，先写日志，再写磁盘</li><li>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里，并更新内存。其它合适时间再写入磁盘</li></ul><p>有了redo log，Inno DB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><h4 id="MySQL-binlog（归档日志）"><a href="#MySQL-binlog（归档日志）" class="headerlink" title="MySQL binlog（归档日志）"></a>MySQL binlog（归档日志）</h4><p>redo log是 InnoDB 引擎特有的日志，而Server层也有自己的日志，称为binlog。</p><h4 id="redo-log-和-binlog-不同点"><a href="#redo-log-和-binlog-不同点" class="headerlink" title="redo log 和 binlog 不同点"></a>redo log 和 binlog 不同点</h4><ul><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL的 Server 层实现的，所有引擎都能用</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的，写到一定大小会切换到下一个文件，不会覆盖以前的日志</li></ul><p>我们来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ul><li>执行器先找引擎取 ID = 2 这一行。 ID 是主键，引擎直接用树搜索找到这一行。如果ID = 2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</li><li>执行器拿到引擎给的行数据，把这个值加上 1 ，比如原来是 N ， 现在就是 N+1 ，得到新的一行数据，再调用引擎接口写入这行新数据</li><li>引擎将这行数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状体啊。然后告知执行期执行完成了，随时可以提交事务</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成 提交（commit）状态，更新完成</li></ul><h4 id="redolog两阶段提交"><a href="#redolog两阶段提交" class="headerlink" title="redolog两阶段提交"></a>redolog两阶段提交</h4><p>redo log 和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>事务：ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><p>隔离级别：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</p><p>事务隔离的实现：在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>长事务：系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h4 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h4><ul><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback</li><li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit  或  rollback 语句，或者断开连接</li></ul><p>建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。避免长连接导致长事务。</p><h4 id="查询长事务"><a href="#查询长事务" class="headerlink" title="查询长事务"></a>查询长事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60; -- 查找持续时间超过60s的事务</span><br></pre></td></tr></table></figure><h2 id="深入浅出索引"><a href="#深入浅出索引" class="headerlink" title="深入浅出索引"></a>深入浅出索引</h2><h4 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h4><ul><li>哈希表 ( 查询效率不高 )</li><li>有序数组 （ 增删效率低，适合静态存储 ）</li><li><strong>搜索树</strong></li></ul><h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul><li><p>主键索引</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）</p></li><li><p>非主键索引</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 <a href="https://www.shinhwa.wang/2019/04/04/binary-tree-B-tree-B+-Tree/" target="_blank" rel="noopener">B+ 树</a> ；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该<strong>尽量使用主键查询</strong>。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><h4 id="索引下推-（index-condition-pushdown"><a href="#索引下推-（index-condition-pushdown" class="headerlink" title="索引下推 （index condition pushdown)"></a>索引下推 （index condition pushdown)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> select * from tuser where name like '张%' and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405153458.png" alt></p><p><strong>InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读书笔记：《 MySQL 实战 45 讲》，MySQL 基本原理介绍，极客时间笔记&lt;/p&gt;
&lt;p&gt;&lt;em&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Tcpdump and Wireshark</title>
    <link href="http://yoursite.com/2019/02/27/notes-on-tcpdump-and-Wireshark/"/>
    <id>http://yoursite.com/2019/02/27/notes-on-tcpdump-and-Wireshark/</id>
    <published>2019-02-27T13:44:24.000Z</published>
    <updated>2019-04-07T15:05:54.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tcpdump-和-Wireshark"><a href="#tcpdump-和-Wireshark" class="headerlink" title="tcpdump 和 Wireshark"></a>tcpdump 和 Wireshark</h3><p>这个例子只是执行 ping 指令的一个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn udp port 53 or host x.x.x.x -w ping.pcap</span><br></pre></td></tr></table></figure><ul><li>-nn 不解析抓包中的域名（不反向解析）、协议以及端口号</li><li>udp port 53 只显示 UDP 协议的端口号（包括源端口和目的端口）为 53 的包</li><li>host x.x.x.x 只显示 IP 地址（包括原地址和目的地址）为 x.x.x.x 的包</li><li>or 或的关系</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900591970.png" alt></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900605148.png" alt></p><p>HTTP 的一个例子，便于理解 TCP 三次握手和四次挥手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn host example.com -w web.pcap</span><br><span class="line">curl example.com</span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901484205.png" alt></p><p>可以看到TCP 三次握手和四次挥手的请求</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901518443.png" alt></p><p>顺便复习一下流程：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901543490.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tcpdump-和-Wireshark&quot;&gt;&lt;a href=&quot;#tcpdump-和-Wireshark&quot; class=&quot;headerlink&quot; title=&quot;tcpdump 和 Wireshark&quot;&gt;&lt;/a&gt;tcpdump 和 Wireshark&lt;/h3&gt;&lt;p&gt;这个
      
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Tcpdump" scheme="http://yoursite.com/tags/Tcpdump/"/>
    
      <category term="Wireshark" scheme="http://yoursite.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 206. Reverse Linked List</title>
    <link href="http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/"/>
    <id>http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/</id>
    <published>2019-02-26T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>单链表反转</p><p>题目来源：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/?</p><p>代码效率：100%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>迭代法：将当前节点的后继节点指向前一个节点，移动当前节点</p><p>递归法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nonesense"><a href="#Nonesense" class="headerlink" title="Nonesense"></a>Nonesense</h3><p>最简单的单链表居然花费了我半天的时间，最后还是参考别人的答案才写出来。。。智商捉急</p><p>总结一下问题：</p><ul><li>太急躁，要静下心来慢慢梳理过程，整理成代码输出</li><li><strong>java变量指针等概念感觉还是不清晰</strong>，今天抽空需要补一下</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;单链表反转&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 448 Find All Numbers Disappeared in an Array</title>
    <link href="http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/"/>
    <id>http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/</id>
    <published>2019-02-24T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：</p><p>题目来源：<a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/N</p><p>代码效率： 95.58%</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>取负法：不管一个元素出现一次还是两次，只要出现它对应的位置就会被取负。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[val] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nums[val] = -nums[val];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>感觉这个题就是单纯考虑数学技巧，做起来比较吃力，看答案的时候豁然开朗，还是慢慢积累吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 283 Move Zeroes</title>
    <link href="http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/"/>
    <id>http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/</id>
    <published>2019-02-23T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变</p><p>题目来源：<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一个快指针，一个慢指针，快指针指向不为0的元素，快慢指针值交换，同时向后移动一位。这样可以保证下面两个条件：</p><ul><li>快慢指针之间的元素都是0</li><li>慢指针之前的元素都不为0<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>一开始理解错误，以为把0都放到后面之后还是要对前面从大到小进行排序。。。结果想了半天</p><p>以后还是要仔细审题，不要怀疑自己，先用自己的想法暴力实现</p><p>写代码之前可以举个栗子来一步一步推敲，想好边界和规律再写代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 136. Single Number</title>
    <link href="http://yoursite.com/2019/02/22/leetcode-136-single-number/"/>
    <id>http://yoursite.com/2019/02/22/leetcode-136-single-number/</id>
    <published>2019-02-22T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。</p><p>题目来源：<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用异或 <code>^</code></p><ul><li>两个相同的数异或后为0</li><li>0和一个数异或后为那个数</li><li>异或运算满足交换律</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            result^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 226. Invert Binary Tree</title>
    <link href="http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/"/>
    <id>http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/</id>
    <published>2019-02-21T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>反转二叉树左右子树</p><p>题目来源：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/ N</p><p>代码效率：100.00%</p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>左子树和右子树递归互换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>对递归还是理解不透彻，总结一下如何处理递归问题：</p><blockquote><p>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;反转二叉树左右子树&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/invert-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/invert-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 104. Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/"/>
    <id>http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/</id>
    <published>2019-02-20T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>计算二叉树的深度</p><p>题目来源：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：思路很乱，参考 Discuss 的答案</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>递归左右子树，对深度最大的子树进行递归调用并+1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;计算二叉树的深度&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-depth-of-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 617 Merge Two Binary Trees</title>
    <link href="http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/"/>
    <id>http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/</id>
    <published>2019-02-19T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。</p><p>题目来源：<a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-binary-trees/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/1</p><p>代码效率：98.24%</p><p>耗时：25分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>主要考察对递归算法的理解。</p><ul><li>首先考虑边界，如果两个子二叉树都为空，则新的二叉树必定为空</li><li>考虑其中一个子二叉树为空，则新的二叉树直接等于另外一个子二叉树</li><li>如果两个子二叉树都不为空，新二叉树节点值为两个子二叉树对应节点的值的和，同时对两个子二叉树的左右子树进行递归调用，仔细想想就明白了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode ret;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">            ret.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">            ret.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然别人思路的总是最好的 o(╥﹏╥)o</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    TreeNode result = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    result.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    result.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>学习数据结构的时候，总感觉递归对自己来说是弱项，智商不够用。今天居然一次性直接做出来了。学习数据结构和算法真的能培养思维逻辑和解决问题的能力。fighting !!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-two-binary-trees/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 461 Hamming Distance</title>
    <link href="http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/"/>
    <id>http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/</id>
    <published>2019-02-18T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.233Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>统计两个整数转换成二进制位时位数不同的个数。</p><p>题目来源：<a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/hamming-distance/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/2 (少写了 return 语句。。)</p><p>代码效率：91.77%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>二进制的每一位的值不是 0 就是 1，就是整数除以 2 取余的结果，判断是否相等。然后再取模（相当于向左移动一位），再取余作比较。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span> || y != <span class="number">0</span>)&#123;</span><br><span class="line">            i = x % <span class="number">2</span>;</span><br><span class="line">            j = y % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">            y = y / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人的一行代码实现Orz：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;统计两个整数转换成二进制位时位数不同的个数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/hamming-distance/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 771 Jewels And Stones</title>
    <link href="http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/"/>
    <id>http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/</id>
    <published>2019-02-17T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。</p><p>题目来源：<a href="https://leetcode.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode.com/problems/jewels-and-stones/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/4</p><p>代码效率：93.10%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>把 J 和S 转换成字符数组，遍历 J 数组中的字符是否等于 S 中的 字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charJ = J.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charS = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> <span class="keyword">var</span> : charJ)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;charS.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">var</span> == charS[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人还有更好的做法：</p><ul><li>遍历 J 把字符放入 set 集合</li><li>遍历 S 字符是否出现在 set 中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Set setJ = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> j: J.toCharArray()) setJ.add(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> s: S.toCharArray()) <span class="keyword">if</span> (setJ.contains(s)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>第一次开始刷 Leetcode ,虽然做的是 easy 的题目，但还是没有参考其他人的答案自己完成了。开始有一点新鲜感和成就感了，希望可以坚持下去。</p><p>刚开始刷题使用的是 VS CODE 码代码，在网上看了一些网友的建议，为了应对后续面试可能要求手写编程的情况，所以现在是先用 IDE 把代码写出来，再手写输入 Leetcode 提交答案。</p><p>加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/jewels-and-stones/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/jewels-and-stones/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Tips</title>
    <link href="http://yoursite.com/2019/02/15/Leetcode-tips/"/>
    <id>http://yoursite.com/2019/02/15/Leetcode-tips/</id>
    <published>2019-02-15T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.234Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。</p><p>数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：<br><a id="more"></a></p><ul><li><p>数据结构与算法之美</p><p>极客时间的一个专栏，内容通俗易懂，适合入门</p></li><li><p>数据结构与算法分析：Java语言描述</p><p>下一步打算看的书籍</p></li><li><p>经典大作：算法，算法导论</p></li></ul><p>附数据结构与算法之美推荐书单：<br><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407333793.png" alt></p><h3 id="Leetcode-刷题方法"><a href="#Leetcode-刷题方法" class="headerlink" title="Leetcode 刷题方法"></a>Leetcode 刷题方法</h3><p>在刚开始刷 Leetcode 时，很多人只有在看完答案才知道要怎么做，如果不看答案的话完全没有思路。这是非常正常的现象，并不表示你的思维能力比别人差。人类最擅长的学习方式是模仿，刚开始刷题的时候不会做看看别人怎么做是很正确的做法，模仿多了自然就会做了。</p><p>刷 Leetcode 也有两种流派：龟派和兔派。龟派每道题都要想很久，而且尽可能想出多种解法。兔派是想一会儿就看答案，这样就可以很快地刷题。龟派比较适合思维锻炼，而兔派比较适合短期内快速提高并记忆。如果是为了应对校招的话，比较推荐兔派这种刷题方法，因为校招确实很依赖于短期记忆。选择兔派这种方式的话，就需要反复地进行复习，从而保持记忆并增加理解。但是也不能完全采用兔派这种方法，因为如果习惯于不去思考怎么做的话，会养成惰性的思维方式。</p><p>当你刷题到一定程度的时候，最好每天再刷一两题保持题感。可以选你之前做过的题目，因为你再做一遍的话可以很快做出来，这样子就可以让你对刷题这件事保持积极的一种心态。</p><p>刷 Leetcode 的收益如下图所示，可以看到刷的越多收益增长的越小。刷 200 题就足够应对大多数互联网公司的校招，但是如果时间不够的话刷 100 题也是有很大的收益，可以刷一下 <a href="https://leetcode.com/problemset/top-100-liked-questions/" target="_blank" rel="noopener">Top 100 Liked Questions</a>。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407398105.png" alt></p><ul><li>排序：大部分要求能手写，并分析时间空间复杂度，以及稳定性</li><li>树：红黑树的原理以及在 JDK 的使用；B+ 树以及在数据库索引中的使用</li><li>图：拓扑排序；并查集；最短路径；最小生成树</li><li>散列表：实现原理，以及在 JDK 中的使用</li><li>字符串：KMP；AC 自动机；Trie 树</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。&lt;/p&gt;
&lt;p&gt;数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 20 Summary. Red Black Tree</title>
    <link href="http://yoursite.com/2019/02/13/beauty-of-algorithms-20-summary-red-black-tree/"/>
    <id>http://yoursite.com/2019/02/13/beauty-of-algorithms-20-summary-red-black-tree/</id>
    <published>2019-02-12T16:45:30.000Z</published>
    <updated>2019-03-31T15:02:57.218Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树的数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n,所以它是近似平衡， 插入、删除、查找操作的时间复杂度都是O(logn)。<br><a id="more"></a><br>红黑树非常复杂，无法永久记忆它的平衡调整策略。</p><p>有时间深入了解一下 :)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树的数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n,所以它是近似平衡， 插入、删除、查找操作的时间复杂度都是O(logn)。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Red Black Tree" scheme="http://yoursite.com/tags/Red-Black-Tree/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 19 Summary. Binarytree</title>
    <link href="http://yoursite.com/2019/02/09/beauty-of-algorithms-19-summary-binarytree/"/>
    <id>http://yoursite.com/2019/02/09/beauty-of-algorithms-19-summary-binarytree/</id>
    <published>2019-02-08T16:45:30.000Z</published>
    <updated>2019-03-31T15:02:57.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li><p>节点</p><p>树中的元素称之为节点</p></li><li><p>高度</p><ul><li><p>节点的高度</p><p>节点到叶子节点的最长路径</p></li><li><p>树的高度</p><p>跟节点的高度</p></li></ul></li><li><p>深度</p><p>根节点到这个节点所经历的边的个数</p></li><li><p>层</p><p>节点的深度+1</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797246423.png" alt></p><h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3></li><li><p>满二叉树</p><p>除了叶子结点外每个节点都有左右两个子节点</p></li><li><p>完全二叉树</p><p>叶子结点都在最低下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797311876.png" alt></p><h3 id="表示、存储一棵二叉树"><a href="#表示、存储一棵二叉树" class="headerlink" title="表示、存储一棵二叉树"></a>表示、存储一棵二叉树</h3><p><strong>链式存储法</strong></p><p>每个结点有三个字段，其中一个存储数据，另两个是指向左右子节点的指针。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797363532.png" alt></p><p><strong>顺序存储法(基于数组)</strong></p><p>根节点存储在下标i=1的位置，左子节点存储在下标2<em>i=2的位置，右子节点存储在2</em>i+1=3的位置，以此类推。</p><p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 的位置存储的就是右子节点。<br>我们只要知道根节点存储的位置，这样就可以通过下标计算，把整棵树都串起来。</p><p>为了方便计算子节点，根节点会存储在下标为 1 的位置</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797402073.png" alt></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>前序遍历</p><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></li><li><p>中序遍历</p><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></li><li><p>后序遍历</p><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p></li><li><p>层序遍历</p><p>从树的第一层开始从左到右打印节点</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797580379.png" alt></p><p>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</p><p>比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p><h3 id="二叉树以及二叉树遍历代码实现"><a href="#二叉树以及二叉树遍历代码实现" class="headerlink" title="二叉树以及二叉树遍历代码实现"></a><strong>二叉树以及二叉树遍历代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BinaryTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            root.data = data;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add(root, <span class="keyword">new</span> Node(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node root, Node newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode.data &lt; root.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.leftNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.leftNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.leftNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.rightNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.rightNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHigh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前序遍历："</span>);</span><br><span class="line">        pre(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            pre(node.leftNode);</span><br><span class="line">            pre(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"中序遍历："</span>);</span><br><span class="line">        in(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            in(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            in(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后序遍历："</span>);</span><br><span class="line">        post(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            post(node.rightNode);</span><br><span class="line">            post(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node leftNode;</span><br><span class="line">        <span class="keyword">private</span> Node rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.leftNode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rightNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        BinaryTree t = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        t.add(<span class="number">40</span>);</span><br><span class="line">        t.add(<span class="number">25</span>);</span><br><span class="line">        t.add(<span class="number">78</span>);</span><br><span class="line">        t.add(<span class="number">10</span>);</span><br><span class="line">        t.add(<span class="number">32</span>);</span><br><span class="line">        t.add(<span class="number">50</span>);</span><br><span class="line">        t.add(<span class="number">93</span>);</span><br><span class="line">        t.add(<span class="number">3</span>);</span><br><span class="line">        t.add(<span class="number">17</span>);</span><br><span class="line">        t.add(<span class="number">30</span>);</span><br><span class="line">        t.add(<span class="number">38</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t.getLow());</span><br><span class="line">        System.out.println(t.getHigh());</span><br><span class="line">        System.out.println(<span class="string">"Size-"</span> + t.size);</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        t.inOrder();</span><br><span class="line">        t.preOrder();</span><br><span class="line">        t.postOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 Binary Search Tree"></a>二叉查找树 Binary Search Tree</h2><h3 id="二叉查找树的定义"><a href="#二叉查找树的定义" class="headerlink" title="二叉查找树的定义"></a>二叉查找树的定义</h3><p>二叉查找树又称二叉搜索树。其要求在二叉树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树的节点的值都大于这个节点的值。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550049430176.png" alt></p><h3 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h3><p><strong>二叉树类、节点类以及查找方法的代码实现</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064373887.png" alt></p><p>先取根节点，如果它等于我们要查找的数据，那就返回。</p><p>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</p><p>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉查找树的插入操作</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064441773.png" alt></p><p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p><p>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉查找树的删除操作</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064532346.png" alt></p><p>第一种情况，删除的节点没有子节点直接将其父节点指向置为null。</p><p>第二种情况，删除的节点只有一个子节点，将其父节点指向其子节点。</p><p>第三种情况，删除的节点有两个子节点，首先找到该节点右子树中最小的的节点把他替换掉要删除的节点 然后再删除这个最小的节点，该节点必定没有子节点，否则就不是最小的节点了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 先找到要删除的节点 </span></span><br><span class="line"><span class="comment"> * 2. 如果这个节点有两个叶子节点，找到右子树的最小值，替换当前的这个节点值，同时删除这个最小值 </span></span><br><span class="line"><span class="comment"> * 3.如果这个节点只有一个叶子节点，用叶子节点的值替换当前节点的值 </span></span><br><span class="line"><span class="comment"> * 4. 如果这个节点没有叶子节点，直接删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = root;</span><br><span class="line">    Node pp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node minP = p;</span><br><span class="line">        Node minPP = pp;</span><br><span class="line">        <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p.data = minP.data;</span><br><span class="line">        p = minP;</span><br><span class="line">        pp = minpp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node child;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">        pp.left = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pp.right = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。</p><p>这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><h3 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a><strong>二叉查找树的其他操作</strong></h3><p>二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。</p><p>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</p><h3 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h3><p>前面的二叉查找树的操作，我们默认树中节点存储的都是数字，针对的都是不存在键值相同的情况。</p><p>我们可以通过两种办法来构建支持重复数据的二叉查找树。</p><ul><li><p>第一种方法</p><p>二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p></li><li><p>第二种方法</p><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p><p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p></li></ul><h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p><strong>最坏、最好情况</strong></p><p>如果根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p><p>最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。而完全二叉树的高度小于等于 log2n。</p><p><strong>平衡二叉查找树</strong></p><p>我们需要构建一种不管怎么删除、插入数据，在任何时候都能保持任意节点左右子树都比较平衡的二叉查找树，这就是一种特殊的二叉查找树，平衡二叉查找树。</p><p>平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)。</p><h3 id="二叉查找树相比散列表的优势"><a href="#二叉查找树相比散列表的优势" class="headerlink" title="二叉查找树相比散列表的优势"></a>二叉查找树相比散列表的优势</h3><p><strong>散列表中的数据是无序存储的</strong></p><p>如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</p><p><strong>散列表扩容耗时很多</strong></p><p>而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p><p><strong>散列表存在哈希冲突</strong></p><p>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。</p><p>加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p><strong>散列表装载因子不能太大</strong></p><p>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h3&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 18 Summary. Hash</title>
    <link href="http://yoursite.com/2019/02/08/beauty-of-algorithms-18-summary-hash/"/>
    <id>http://yoursite.com/2019/02/08/beauty-of-algorithms-18-summary-hash/</id>
    <published>2019-02-07T16:45:30.000Z</published>
    <updated>2019-04-05T07:12:48.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哈希算法的定义和原理"><a href="#哈希算法的定义和原理" class="headerlink" title="哈希算法的定义和原理"></a>哈希算法的定义和原理</h3><p>将任意长度的二进制串映射为固定长度的二进制串。</p><p>这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值。</p><p>设计一个优秀的哈希算法需要满足：</p><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值<a id="more"></a></li></ul><h4 id="MD5哈希算法"><a href="#MD5哈希算法" class="headerlink" title="MD5哈希算法"></a>MD5哈希算法</h4><p>MD5的哈希值是128位的bit长度，为了方便转换成了16进制编码。</p><p>可以看出无论哈希值文本有多长多短，通过MD5哈希之后，得到的哈希值的长度都是一样的，</p><p>而且得到的哈希值看起来像一堆随机数完全没有规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(&quot; 今天我来讲哈希算法 &quot;) = bb4767201ad42c74e650c1b6c03d78fa</span><br><span class="line">MD5(&quot;jiajia&quot;) = cd611a31ea969b908932d44d126d195b</span><br></pre></td></tr></table></figure><h3 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h3><h4 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a><strong>安全加密</strong></h4><p><strong>加密算法</strong></p><p>最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。</p><p>对用于加密的哈希算法来说，有两点格外重要：</p><ul><li>很难根据哈希值反向推导出原始数据</li><li>散列冲突的概率要很小</li></ul><p>实际上，不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。</p><p><strong>鸽巢理论</strong></p><p>这里就基于组合数学中一个非常基础的理论，鸽巢原理（也叫抽屉原理）。</p><p>这个原理本身很简单，它是说如果有 10 个鸽巢，有 11 只鸽子那肯定有 1 个鸽巢中的鸽子数量多于 1 个。</p><p>换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p><p>我们知道，哈希算法产生的哈希值的长度是固定且有限的。</p><p>哈希值是固定的 128 位二进制串，能表示的数据是有限的最多能表示 2^128 个数据。</p><p>基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。</p><h4 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a><strong>唯一标识</strong></h4><p><strong>在图库中搜索图片</strong></p><p>如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对。</p><p>因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。</p><p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。</p><p>比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节。</p><p>然后将这 300 个字节放到一块，通过哈希算法（比如 MD5)得到一个哈希字符串，用它作为图片的唯一标识。</p><p>通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量</p><p><strong>性能提升</strong><br>如果还想继续提高效率，我们可以把每个图片的唯一标识和相应的图片文件在图库中的路径信息，都存储在散列表中。</p><p>当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p><h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a><strong>数据校验</strong></h4><p><strong>P2P文件快校验</strong></p><p>BT 下载的原理是基于 P2P 协议的。</p><p>我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成100 块，每块大约 20MB）。</p><p>等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p><p>网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。</p><p><strong>解决方法</strong></p><p>我们通过哈希算法，对 100 个文件块分别取哈希值并且保存在种子文件中。</p><p>当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。</p><p>如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a><strong>散列函数</strong></h4><p><strong>散列函数是一种哈希算法</strong></p><p>实际上，散列函数也是哈希算法的一种应用。</p><p>散列函数是设计一个散列表的关键。</p><p>它直接决定了散列冲突的概率和散列表的性能。</p><p>不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。</p><p>即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p><p><strong>散列函数追求平均分布</strong></p><p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。</p><p>散列函数中用到的散列算法，更加关注散列后的值是否能平均分布。</p><p>也就是一组数据是否能均匀地散列在各个槽中。</p><p>除此之外，散列函数执行的快慢，也会影响散列表的性能，</p><p>所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h4><p>我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p><p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。</p><p>客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p><ul><li>如果客户端很多，映射表可能会很大，比较浪费内存空间</li><li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大</li></ul><p>如果借助哈希算法，这些问题都可以非常完美地解决。</p><p>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</p><p>这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a><strong>数据分片</strong></h4><p><strong>统计“搜索关键词”出现的次数</strong></p><p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，</p><p>我们想要快速统计出每个关键词被搜索的次数。</p><p>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p><p>为了提高处理的速度，我们用 n 台机器并行处理。</p><p>我们从搜索记录的日志文件中，依次读出每个搜索关键词，</p><p>并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p><p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。</p><p>也就是说，同一个搜索关键词会被分配到同一个机器上。</p><p>每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p><p><strong>快速判断图片是否在图库中</strong></p><p>假设现在我们的图库中有 1 亿张图片，在单台机器上构建散列表是行不通的。</p><p>我们同样可以对数据进行分片，然后采用多机处理。</p><p>我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。</p><p>我们每次从图库中读取一个图片，计算唯一标识，</p><p>然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，</p><p>然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p><p>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，</p><p>计算这个图片的唯一标识，然后与机器个数 n 求余取模。</p><p>假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p><h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a><strong>分布式存储</strong></h4><p>我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。</p><p>我们需要将数据分布在多台机器上通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号</p><p>如果数据增多，原来的 10 个机器已经无法承受，我们需要扩容，假如扩到 11 个机器。</p><p>原来的数据是通过与 10 来取模的，比如 13 这个数据，存储在编号为 3 这台机器上。</p><p>新加了一台机器后，我们对数据按照 11 取模，原来 13 这个数据被分配到了 2 号这台机器上。</p><p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。</p><p>所有的数据请求都会穿透缓存，直接去请求数据库，可能会发生雪崩效应，压垮数据库。</p><p>我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。</p><p>这时候，一致性哈希算法就要登场了。</p><p><strong>一致性哈希算法</strong></p><p><a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">参考</a></p><p>假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。</p><p>我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。</p><p>当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。</p><p>这样既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;哈希算法的定义和原理&quot;&gt;&lt;a href=&quot;#哈希算法的定义和原理&quot; class=&quot;headerlink&quot; title=&quot;哈希算法的定义和原理&quot;&gt;&lt;/a&gt;哈希算法的定义和原理&lt;/h3&gt;&lt;p&gt;将任意长度的二进制串映射为固定长度的二进制串。&lt;/p&gt;
&lt;p&gt;这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值。&lt;/p&gt;
&lt;p&gt;设计一个优秀的哈希算法需要满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）&lt;/li&gt;
&lt;li&gt;对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同&lt;/li&gt;
&lt;li&gt;散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小&lt;/li&gt;
&lt;li&gt;哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
      <category term="哈希算法" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 17 Summary. HashTable</title>
    <link href="http://yoursite.com/2019/02/07/beauty-of-algorithms-17-summary-hash-table/"/>
    <id>http://yoursite.com/2019/02/07/beauty-of-algorithms-17-summary-hash-table/</id>
    <published>2019-02-06T16:45:30.000Z</published>
    <updated>2019-03-31T15:02:57.210Z</updated>
    
    <content type="html"><![CDATA[<p>散列表Hash Table来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。</p><p>需要存储在散列表中的数据我们称为键key，将键转化为数组下标的方法hash(key)称为散列函数，散列函数的计算结果称为散列值。</p><p>将数据存储在散列值对应的数组下标位置。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549419113789.png" alt><br><a id="more"></a></p><h3 id="设计散列函数"><a href="#设计散列函数" class="headerlink" title="设计散列函数"></a>设计散列函数</h3><p><strong>设计散列函数的基本要求</strong></p><p>散列函数计算得到的散列值是一个非负整数。</p><p>若key1=key2，则hash(key1)=hash(key2)。</p><p>若key≠key2，则hash(key1)≠hash(key2)。</p><p>当空闲位置越来越少，散列值冲突的概率越来越大，也就无法满足第三条。</p><h3 id="散列冲突的解决方法"><a href="#散列冲突的解决方法" class="headerlink" title="散列冲突的解决方法"></a>散列冲突的解决方法</h3><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a><strong>开放寻址法</strong></h4><ul><li><p><strong>线性探测</strong></p><p>开放寻址法会导致占用删除元素的位置，这样会导致原来的算法失效。</p><p>所以线性探测法的删除操作是将要删除的元素标记为deleted，当要插入数据时遇到这种位置就继续向下探测。</p></li><li><p><strong>二次探测</strong></p><p>线性探测法每次探测的步长为1，即在数组中一个一个探测，比如hash(key)+1,hash(key)+2…</p><p>而二次探测的步长变为原来的平方hash(key)+1^2,hash(key)+2^2…</p></li><li><p><strong>双重散列</strong></p><p>使用一组散列函数，先使用第一个，如果有冲突就换下一个，直到找到空闲位置为止。</p></li></ul><p><strong>性能描述</strong></p><p>我们使用装载因子来表示空位多少：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子 = 填入表中的元素个数 / 散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><ul><li><p><strong>插入数据</strong></p><p>当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)</p></li><li><p><strong>查找或删除数据</strong></p><p>对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数。当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除，两操作与链表长度k成正比，即时间复杂度为O(k)。</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549419411662.png" alt></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>假设我们有10万条URL访问日志，如何按照访问次数给URL排序</strong></p><p>遍历 10 万条日志，将 URL 做为 KEY ，声明一个访问次数 count 作为散列表值，存入散列表，每次遇到重复的 count++ ,然后对散列表值进行桶排序或者快速排序。</p><p><strong>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串</strong></p><p>将其中一个数组以字符串为 KEY， 默认值 value 为 0 存入散列表。然后用第二个数组的元素为 KEY 遍历这个散列表，如果找到相同的KEY ，那么 value  +1 ，最后统计 value&gt;0 的所有 KEY.</p><h2 id="散列表碰撞攻击"><a href="#散列表碰撞攻击" class="headerlink" title="散列表碰撞攻击"></a>散列表碰撞攻击</h2><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。</p><p>如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p><h3 id="散列函数的设计"><a href="#散列函数的设计" class="headerlink" title="散列函数的设计"></a>散列函数的设计</h3><ul><li>散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能</li><li>散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况</li><li>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。</li><li>散列函数的设计方法有很多：数据分析法、直接寻址法、平方取中法、折叠法、随机数等等</li></ul><p><strong>装载因子</strong></p><p>装载因子越大，散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。</p><p>插入数据的过程要多次寻址或者拉很长的链，查找的过程也会变得很慢。</p><p>动态散列表的数据集合是频繁变动的，我们事先无法预估数据个数，无法事先申请一个足够大的散列表。</p><p>数据慢慢加入，装载因子就会慢慢变大，当装载因子大到一定程度之后，散列冲突变得不可接受。</p><p>当装载因子过大时，我们可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。</p><p>假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，扩容之后新散列表的装载因子就下降为原来的一半变成了 0.4。</p><p><strong>避免低效地扩容</strong></p><p>当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。</p><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。</p><p>当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。</p><p>每次插入一个数据到散列表，我们都重复上面的过程。</p><p>经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。</p><p>对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><h3 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h3><p><strong>开放寻址法</strong></p><ul><li>优点<ul><li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li><li>种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易</li></ul></li><li>缺点<ul><li>在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高</li><li>使用开放寻址法解决冲突的散列表，装载因子的上限不能太大</li><li>这种方法比链表法更浪费内存空间</li></ul></li></ul><p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</p><p>这也是 Java 中的 <code>ThreadLocalMap</code> 使用开放寻址法解决散列冲突的原因。</p><p><strong>链表法</strong></p><ul><li>优点<ul><li>链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</li><li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多</li></ul></li><li>缺点<ul><li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍</li><li>而且，因为链表中的结点是零散分布在内存中的，不是连续的。所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响</li></ul></li></ul><p>当如果我们存储的是大对象，即存储的对象的大小远远大于一个指针的大小。那么链表中指针的内存消耗在大对象面前就可以忽略了。</p><p>链表法比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p><h3 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a><strong>工业级散列表举例分析</strong></h3><p><strong>初始大小</strong></p><p><code>HashMap</code> 默认的初始大小是 16，这个默认值是可以设置的。可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 <code>HashMap</code> 的性能。</p><p><strong>装载因子和动态扩容</strong></p><p>最大装载因子默认是 <code>0.75</code>，当 <code>HashMap</code> 中元素个数超过 <code>0.75*capacity</code>（<code>capacity</code> 表示散列的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><p><strong>散列冲突解决方法</strong></p><p><code>HashMap</code> 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 <code>HashMap</code> 的性能。</p><p>于是，在 <code>JDK1.8</code> 版本中，为了对 <code>HashMap</code> 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。</p><p><strong>散列函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>); <span class="comment">//capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashCode()</code> 返回的是 Java 对象的 <code>hash code</code>。</p><p>比如 String 类型的对象的 hashCode() 就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hash = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如何设计的一个工业级的散列函数？</strong></p></blockquote><p><strong>如果这是一道面试题或者是摆在你面前的实际开发问题，从哪几个方面思考呢</strong></p><p>结合已经学习过的散列知识，我觉得应该有这样几点要求：</p><ul><li>支持快速的查询、插入、删除操作</li><li>内存占用合理，不能浪费过多的内存空间</li><li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况</li></ul><p>如何实现这样一个散列表呢？根据前面讲到的知识从这三个方面来考虑设计思路</p><ul><li>设计一个合适的散列函数</li><li>定义装载因子阈值，并且设计动态扩容策略</li><li>选择合适的散列冲突解决方法</li></ul><h2 id="散列表和链表组合使用"><a href="#散列表和链表组合使用" class="headerlink" title="散列表和链表组合使用"></a>散列表和链表组合使用</h2><h3 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h3><p>借助散列表，我们可以把LRU缓存淘汰算法的时间复杂度降为O(1)。</p><p>一个缓冲cache系统主要包含以下操作</p><ul><li>往缓存中添加一个数据</li><li>从缓存中删除一个数据</li><li>在缓存中查找一个数据</li></ul><p>单纯采用链表，时间复杂度只能是O(n)。</p><p>将散列表和双向链表结合，就可以降为O(1)，其结构如下图所示：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549420745673.png" alt></p><p>其中，我们使用双向链表存储数据，<code>data</code>存储数据，<code>prev</code>前驱指针，<code>next</code>后继指针。</p><p>此外，新增加了<code>hnext</code>指针，这个指针就是链表法散列表中的拉链的后继指针。</p><h3 id="如何做到O-1"><a href="#如何做到O-1" class="headerlink" title="如何做到O(1)"></a>如何做到O(1)</h3><ul><li><p><strong>查找</strong></p><p>因为是散列表所以查找一个数据的操作时间复杂度就接近于O(1)</p></li><li><p><strong>删除</strong></p><p>删除一个数据，我们借助散列表再O(1)的时间复杂度里找到该结点，而双向链表有前驱指针，可以直接删除该节点，时间复杂度为O(1)</p></li><li><p><strong>添加</strong></p><p>添加一个数据比较复杂，首先要看其是否已经在缓存中，如果在就将其移动到双向链表的尾部，如果不在就检查缓存满了没，满了就删除双向链表的头结点，再将数据放到双向链表的尾部，如果没有满就直接将数据放大双向链表的尾部</p></li></ul><p>以上操作中，设计查找的操作是散列表完成的，删除节点、插入节点是双向链表完成的，所以时间复杂度是O(1)。</p><h3 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h3><p>在有序集合中，每个成员对象有两个重要的属性，键<code>key</code>和分值<code>score</code>。</p><p>我们不仅需要key来查找数据，还会需要用score查找数据。</p><p>细化一下Redis有序集合的操作：</p><ul><li>添加一个成员对象</li><li>按照键值来删除一个成员对象</li><li>按照键值来查找一个成员对象</li><li>按照分值区间查找数据，比如查找积分在[100, 356] 之间的成员对象</li><li>按照分值从小到大排序成员变量</li></ul><p>如果只按照分支将成员对象组织成跳表的结构，那么按照键值删除、查询对象就会很慢。</p><p>我们可以按照键值构建一个散列表，这样按照key来删除、查找一个对象的时间复杂度就都变成了O(1)。</p><h3 id="Java中的LinkedHashMap"><a href="#Java中的LinkedHashMap" class="headerlink" title="Java中的LinkedHashMap"></a>Java中的LinkedHashMap</h3><p>Java 中的<code>LinkedHashMap</code>中的<code>Linked</code>并不是链表法表示散列表的意思，而是双向链表和散列表结合。</p><p><code>LinkedHashMap</code>本身就是一个支持LRU缓存淘汰策略的缓存系统，其数据的存取移动删除规则和LRU一样。</p><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p><strong>今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？</strong></p><p>不能，影响查询性能</p><p><strong>假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。</strong></p><p><strong>假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</strong></p><ul><li><p>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息</p><p>ID 为 KEY，散列表可以实现快速查询，链表法可以实现删除更新。</p></li><li><p>查找积分在某个区间的猎头 ID 列表</p><p>遍历散列表查询积分对应的 ID 列表</p></li><li><p>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 …</p><p>遍历散列表</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;散列表Hash Table来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。&lt;/p&gt;
&lt;p&gt;需要存储在散列表中的数据我们称为键key，将键转化为数组下标的方法hash(key)称为散列函数，散列函数的计算结果称为散列值。&lt;/p&gt;
&lt;p&gt;将数据存储在散列值对应的数组下标位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549419113789.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="散列表" scheme="http://yoursite.com/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
</feed>
