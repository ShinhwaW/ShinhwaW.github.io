<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shinhwa&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-16T09:05:52.571Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shinhwa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 169. Majority Element</title>
    <link href="http://yoursite.com/2019/04/16/leetcode-169-majority-element/"/>
    <id>http://yoursite.com/2019/04/16/leetcode-169-majority-element/</id>
    <published>2019-04-16T09:01:43.000Z</published>
    <updated>2019-04-16T09:05:52.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>找出数组中出现次数超过数组长度一半的那个元素。</p><p>题目来源：<a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/1</p><p>代码效率：20.20%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>哈希表，键存储元素，值存储个数，值大于数组长度 1/2 就返回。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.get(num) &gt; nums.length/<span class="number">2</span>)&#123;</span><br><span class="line">                ret = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;找出数组中出现次数超过数组长度一半的那个元素。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/majority-element/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/majority-element/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>IPA Sounds And Exmaples</title>
    <link href="http://yoursite.com/2019/04/07/phonetic-alphabet/"/>
    <id>http://yoursite.com/2019/04/07/phonetic-alphabet/</id>
    <published>2019-04-07T03:53:21.000Z</published>
    <updated>2019-04-07T13:39:15.601Z</updated>
    
    <content type="html"><![CDATA[<p>Examples of IPA use in common English words.<br>List of challenging English sounds and words especially for Chinese people.<br><a id="more"></a></p><h3 id="Diphthong-Vowels"><a href="#Diphthong-Vowels" class="headerlink" title="Diphthong Vowels"></a>Diphthong Vowels</h3><p>The key is to pronounce two symbols clearly</p><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">aʊ</td><td style="text-align:center">Mouth, house, brown, cow, out, downtown</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">əʊ</td><td style="text-align:center">No, don’t, stones, alone, hole, ghost</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">eɪ</td><td style="text-align:center">Face, space, rain , case, eight, name</td><td style="text-align:center">two symbols</td></tr><tr><td style="text-align:center">aɪ</td><td style="text-align:center">My, sight, pride, kind, flight, time</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɔɪ</td><td style="text-align:center">Joy, employ, toy, coil, oyster, point, coin</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʊə</td><td style="text-align:center">lure, tour</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">eə</td><td style="text-align:center">Hair, there, care, stairs, pear, fair, stare</td><td style="text-align:center">tongue back enough</td></tr></tbody></table><h3 id="Short-Vowels-Or-Single-Vowels"><a href="#Short-Vowels-Or-Single-Vowels" class="headerlink" title="Short Vowels Or Single Vowels"></a>Short Vowels Or Single Vowels</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">æ</td><td style="text-align:center">Cat, hand, nap, flat, have, apple</td><td style="text-align:center">tongue back enough</td></tr><tr><td style="text-align:center">e</td><td style="text-align:center">Went, intend, send, letter, bed, step</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʌ</td><td style="text-align:center">Fun, love, money, one, London, come, hungry, but</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɒ</td><td style="text-align:center">Rob, top, watch, squat, sausage, job</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ə</td><td style="text-align:center">Alive, again, mother, toward, banana</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʊ</td><td style="text-align:center">Put, look, should, cook, book, look, good</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɪ</td><td style="text-align:center">city, skin, kill, sit</td><td style="text-align:center">expand mouth</td></tr></tbody></table><h3 id="Long-Vowels"><a href="#Long-Vowels" class="headerlink" title="Long Vowels"></a>Long Vowels</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">ɑ:</td><td style="text-align:center">Fast, car, hard, bath, garden, park</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ɔ:</td><td style="text-align:center">Talk, law, bored, yawn, jaw, soft, loft</td><td style="text-align:center">tongue back enough</td></tr><tr><td style="text-align:center">ɜ:</td><td style="text-align:center">Nurse, heard, third, turn, earth, earn</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">u:</td><td style="text-align:center">Few, boot, lose, gloomy, fruit, chew, do</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">i:</td><td style="text-align:center">Need, beat, team, me, keen</td><td style="text-align:center">expand mouth</td></tr></tbody></table><h3 id="Consonants-Sounds"><a href="#Consonants-Sounds" class="headerlink" title="Consonants Sounds"></a>Consonants Sounds</h3><table><thead><tr><th style="text-align:center"><strong>IPA Symbol</strong></th><th style="text-align:center"><strong>Word examples</strong></th><th style="text-align:center">remark</th></tr></thead><tbody><tr><td style="text-align:center">l</td><td style="text-align:center">large, milk, pill, chill, melt</td><td style="text-align:center">Approximants / tongue touch teeth</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">Room, mother, mad, more</td><td style="text-align:center">Nasals</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">Now, nobody, knew, turn</td><td style="text-align:center">Nasals</td></tr><tr><td style="text-align:center">ŋ</td><td style="text-align:center">King, thing, song, swimming, long, rank</td><td style="text-align:center">tongue touch roof of back mouth</td></tr><tr><td style="text-align:center">θ</td><td style="text-align:center">Thank, Think, Bath, Mouth</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ð</td><td style="text-align:center">There, those, brothers, others</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">snake, sense</td><td style="text-align:center">expand mouth</td></tr><tr><td style="text-align:center">z</td><td style="text-align:center">Zoo, crazy, lazy, zigzag, nose, close</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ts</td><td style="text-align:center">treats, tweets</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dz</td><td style="text-align:center">ends, bends, friends</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">f</td><td style="text-align:center">Full, Friday, fish, knife, fair, fine</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">Vest, village, view, cave, live, very</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">Cash, quick, cricket, sock, kind, clock</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">Girl, green, grass, flag, great, egg</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">Time, train, tow, late, tour</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">Door, day, drive, down, feed, dog</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">Pin, cap, purpose, pause, pet</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">Bag, bubble, build, robe, bus</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʈʃ</td><td style="text-align:center">Choose, cheese, church, watch, chance</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dʒ</td><td style="text-align:center">Joy, juggle, juice, stage, jar</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʃ</td><td style="text-align:center">Shirt, rush, shop, cash, shut, shall</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ʒ</td><td style="text-align:center">Television, delusion, casual, leisure</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">tr</td><td style="text-align:center">trend, treasure</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">dr</td><td style="text-align:center">drive, dry</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">High, help, hello, have</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">Road, roses, river, ring, ride, rare, rest</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">Wall, walk, wine, world, where, what</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">j</td><td style="text-align:center">Yellow, usual, yield, yesterday, yard.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Examples of IPA use in common English words.&lt;br&gt;List of challenging English sounds and words especially for Chinese people.&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="http://yoursite.com/categories/English/"/>
    
    
      <category term="International Phonetic Alphabet" scheme="http://yoursite.com/tags/International-Phonetic-Alphabet/"/>
    
      <category term="IPA" scheme="http://yoursite.com/tags/IPA/"/>
    
      <category term="Pronunciation" scheme="http://yoursite.com/tags/Pronunciation/"/>
    
  </entry>
  
  <entry>
    <title>notes-on-network-protocol-https</title>
    <link href="http://yoursite.com/2019/04/06/notes-on-network-protocol-https/"/>
    <id>http://yoursite.com/2019/04/06/notes-on-network-protocol-https/</id>
    <published>2019-04-06T10:24:47.000Z</published>
    <updated>2019-04-17T08:08:40.506Z</updated>
    
    <content type="html"><![CDATA[<p>Https 总结 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a></p><p><em><a id="more"></a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Https 总结 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Binary tree B tree B+ Tree</title>
    <link href="http://yoursite.com/2019/04/04/binary-tree-B-tree/"/>
    <id>http://yoursite.com/2019/04/04/binary-tree-B-tree/</id>
    <published>2019-04-04T10:29:05.000Z</published>
    <updated>2019-04-08T13:38:31.594Z</updated>
    
    <content type="html"><![CDATA[<p>平衡二叉树、B树、B+树、B*树 </p><a id="more"></a><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><strong>平衡二叉树</strong></h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p><ul><li>非叶子节点只能允许最多两个子节点存在</li><li>每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)</li></ul><p>平衡树的层级结构：因为平衡二叉树查询性能和树的层级（h高度）成反比，h值越小查询越快、为了保证树的结构左右两端数据大致平衡降低二叉树的查询难度一般会采用一种算法机制实现节点数据结构的平衡，实现了这种算法的有比如AVL、<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/Treap" target="_blank" rel="noopener">Treap</a>、红黑树，使用平衡二叉树能保证数据的左右两边的节点层级相差不会大于1.，通过这样避免树形结构由于删除增加变成线性链表影响查询效率，保证数据平衡的情况下查找数据的速度近于二分法查找；</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115440.png" alt></p><p>总结平衡二叉树特点：</p><ul><li>非叶子节点最多拥有两个子节点</li><li>非叶子节值大于左边子节点、小于右边子节点</li><li>树的左右两边的层级数相差不会大于1</li><li>没有值相等重复的节点</li></ul><h2 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a><strong>B树(B-tree)</strong></h2><p>注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li><li>节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）</li><li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)</li><li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</li></ul><p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115645.png" alt></p><h4 id="B树的查询流程"><a href="#B树的查询流程" class="headerlink" title="B树的查询流程"></a><strong>B树的查询流程</strong></h4><p>如上图我要从上图中找到E字母，查找流程如下</p><ul><li>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）</li><li>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点</li><li>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）</li></ul><h4 id="B树的插入节点流程"><a href="#B树的插入节点流程" class="headerlink" title="B树的插入节点流程"></a><strong>B树的插入节点流程</strong></h4><p>定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来</p><p>遵循规则</p><ul><li>节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&lt;=5-1（这里关键字数&gt;4就要进行节点拆分）</li><li>排序规则：满足节点本身比左边节点大，比右边节点小的排序规则</li></ul><p>先插入 3、8、31、11</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405115817.png" alt></p><p>再插入23、29</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405144609.png" alt></p><p>再插入50、28</p><p><img src="C:\develop\blog\newblog\source\_posts\assets\1554446788867.png" alt="1554446788867"></p><h4 id="B树节点的删除"><a href="#B树节点的删除" class="headerlink" title="B树节点的删除"></a><strong>B树节点的删除</strong></h4><p><strong>规则</strong></p><ul><li>节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&lt;2就要进行节点合并）</li><li>满足节点本身比左边节点大，比右边节点小的排序规则</li><li>关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405144759.png" alt></p><p><strong>特点</strong></p><p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a><strong>B+ 树</strong></h2><p><strong>概念</strong></p><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p><p><strong>规则</strong></p><ul><li>B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加</li><li>B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样</li><li>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针</li><li>非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405145634.png" alt></p><p><strong>（百度百科算法结构示意图）</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405150344.png" alt></p><p><strong>（维基百科算法结构示意图）</strong></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快</li><li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定</li><li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描</li><li><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快</li></ul><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a><strong>B*树</strong></h2><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a><strong>规则</strong></h4><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ul><li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</li><li>B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来</li></ul><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h4><p>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405150527.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li><p><strong>相同思想和策略</strong></p><p>从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分法和数据平衡策略来提升查找数据的速度</p></li><li><p><strong>不同的方式的磁盘空间利用</strong></p><p>不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的</p></li></ul><p>文章转载自 <a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27700617</a></p><p>参考</p><p>附（二分法查找）：<a href="https://zhuanlan.zhihu.com/p/27597160" target="_blank" rel="noopener">二分法查找原理 - 知乎专栏</a></p><p>附（B、B+、B* 树）：<a href="https://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="noopener">从 B 树、B+ 树谈到 R 树</a></p><p>附（B、B+、B* 树）：<a href="https://blog.csdn.net/endlu/article/details/51720299" target="_blank" rel="noopener">end’s coding life</a></p><p>附：<a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener"> B 树和 B+ 树的插入、删除图文详解 - nullzx - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平衡二叉树、B树、B+树、B*树 &lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>notes-on-network-protocol-http</title>
    <link href="http://yoursite.com/2019/04/03/notes-on-network-protocol-http/"/>
    <id>http://yoursite.com/2019/04/03/notes-on-network-protocol-http/</id>
    <published>2019-04-03T10:24:47.000Z</published>
    <updated>2019-04-17T08:08:47.201Z</updated>
    
    <content type="html"><![CDATA[<p>Http 总结 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a></p><p><em><a id="more"></a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Http 总结 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Network Protocol Socket</title>
    <link href="http://yoursite.com/2019/04/01/notes-on-network-protocol-socket/"/>
    <id>http://yoursite.com/2019/04/01/notes-on-network-protocol-socket/</id>
    <published>2019-04-01T12:23:19.000Z</published>
    <updated>2019-04-17T08:06:24.673Z</updated>
    
    <content type="html"><![CDATA[<p>Socket 总结 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a></p><p>Talk is cheap, show me the code</p><p><em><a id="more"></a></em></p><h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><p>基于<code>TCP</code>和<code>UDP</code>协议。</p><blockquote><p>可以理解为，弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。在通信之前，双方都要建立一个<code>socket</code>。</p></blockquote><h4 id="socket-参数"><a href="#socket-参数" class="headerlink" title="socket 参数"></a>socket 参数</h4><p>能够设置的参数, 也只能是端到端协议之上<strong>网络层</strong>和<strong>传输层</strong>的。</p><ul><li>AF_INET: IPv4</li><li>AF_INET6: IPv6</li><li>TCP: SOCK_STREAM( 数据流 )</li><li>UDP: SOCK_DGRAM( 数据报 )</li></ul><h3 id="基于-TCP-协议IDE-Socket-程序函数调用过程"><a href="#基于-TCP-协议IDE-Socket-程序函数调用过程" class="headerlink" title="基于 TCP 协议IDE Socket 程序函数调用过程"></a>基于 TCP 协议IDE Socket 程序函数调用过程</h3><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190416202934.png" alt></p><ul><li>服务端<ul><li>TCP 的服务端要先监听一个端口, 调用<code>bind</code>函数, 给这个 Socket 赋予一个 IP 地址和端口<ul><li>端口: 通过端口找到应用程序</li><li>IP: 可能有多个网卡（只有发给这个网卡的包才会给你)</li></ul></li><li>调用<code>listen</code>函数进行监听, 即是<code>TCP</code>的状态图里面的<code>listen</code>状态</li><li>内核中, 为每个<code>Socket</code>维护<strong>两个</strong>队列<ul><li>一个是<strong>已经建立了连接</strong>的队列, 这时候连接三次握手已经完毕, 处于<code>established</code>状态</li><li>一个是<strong>还没有完全建立连接</strong>的队列, 三次握手还没完成, 处于<code>syn_rcvd</code>状态</li></ul></li><li>调用 <code>accept</code> 函数, 拿出一个已经完成的连接进行处理. 如果没有完成, 等待</li></ul></li><li>客户端<ul><li>调用 <code>connect</code> 函数发起连接(三次握手<ul><li>IP 地址</li><li>端口号</li></ul></li><li>内核会给客户端分配一个<strong>临时的</strong>端口</li><li>握手成功, 服务端的 <code>accept</code> 就会返回<strong>另一个</strong> <code>Socket</code></li></ul></li></ul><h4 id="两个-Socket"><a href="#两个-Socket" class="headerlink" title="两个 Socket"></a>两个 Socket</h4><blockquote><p>知识点：监听的<code>Socket</code>和真正用来传数据的<code>Socket</code>是<strong>两个</strong>不同的 <code>Socket</code>。</p></blockquote><ul><li><strong>监听</strong>Socket</li><li><strong>已连接</strong>Socket</li></ul><h4 id="连接成功后"><a href="#连接成功后" class="headerlink" title="连接成功后"></a>连接成功后</h4><p>双方通过 <code>read</code> 和 <code>write</code> 函数来读写数据, <strong>就像往一个文件流里面写东西一样</strong></p><h4 id="Socket-函数调用过程"><a href="#Socket-函数调用过程" class="headerlink" title="Socket 函数调用过程"></a>Socket 函数调用过程</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190416203326.png" alt></p><p><code>Socket</code> 在 <code>Linux</code> 中就是以文件形式存在的.</p><p>在内核中,Socket 是一个文件,那对应就有文件描述符. 每一个进程都有一个数据结构 <code>task_struct</code>, 里面指向一个文件描述符数组, 来列出这个进程打开的所有文件的文件描述符. <strong>文件描述符是一个整数, 是这个数组的下标</strong>.</p><p>这个数组中的<strong>内容</strong>(下标是文件描述符)是一个指针, 指向内核中所有打开的文件的列表. <code>Socket</code> 对应的 <code>inode</code> 不像真正的文件系统一样, 保存在硬盘上的, 而是在内存中的(叫做<code>in-core inode</code>). 在这个 <code>inode</code> 中, <strong>指向了Socket在内核中的 Socket结构</strong>.</p><h4 id="Socket-结构"><a href="#Socket-结构" class="headerlink" title="Socket 结构"></a>Socket 结构</h4><ul><li>发送队列</li><li>接收队列</li></ul><p>两个队列保存的是一个缓存<code>sk_buff</code>. 这个缓存里面能够看到完整的包的结构.</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190416203809.png" alt></p><h3 id="基于-UDP-协议的-Socket-程序函数调用过程"><a href="#基于-UDP-协议的-Socket-程序函数调用过程" class="headerlink" title="基于 UDP 协议的 Socket 程序函数调用过程"></a>基于 UDP 协议的 Socket 程序函数调用过程</h3><p><code>UDP</code>没有连接的, 不需要调用<code>listen</code>和<code>connect</code>.</p><p><code>UDP</code>仍然需要<code>IP</code>和<code>端口号</code>, 所以需要<strong><code>bind</code></strong>.</p><p><code>UDP</code>是<strong>没有维护连接状态的</strong>, 不需要没对连接建立一组<code>Socket</code>, 而是只要有一个<code>Socket</code>, 就能够和客户端通信.</p><p><strong>因为没有连接状态</strong>, 每次通信的时候, 都调用<code>sento</code> 和 <code>recvfrom</code>, 都可以传入<code>IP</code>地址和端口号.</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190416204040.png" alt></p><h3 id="服务器如何提高连接并发数"><a href="#服务器如何提高连接并发数" class="headerlink" title="服务器如何提高连接并发数"></a>服务器如何提高连接并发数</h3><h4 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h4><p>四元组来标识一个 <code>TCP</code> 连接.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;本机 IP, 本机端口, 对端 IP, 对端端口&#125;</span><br></pre></td></tr></table></figure><p>服务端可以一个端口来监听，只有客户端<code>IP</code>和客户端端口是可变的.</p><p><code>最大 TCP 连接数 = 客户端 IP 数 x 客户端端口数</code>.</p><ul><li><code>IPv4</code><ul><li>IP数最大: 2^32</li><li>端口数最多: 2^16</li></ul></li></ul><p><strong>理论上</strong>服务器单机最大 <code>TCP</code> 连接数为 <code>2^48</code>.</p><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ul><li>文件描述符限制: <code>Socket</code>都是文件, 首先要通过<code>ulimit</code>配置文件描述符的数目.</li><li>内存: 每个<code>TCP</code>链接都要占用一定内存, 操作系统是有限的.</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p><strong>将项目外包给其他公司(多进程方式)</strong></p><p>创建子进程, 将基于已链接<code>Socket</code>的交互给这个新的子进程来做.</p><p>在 Linux 下,创建子进程使用 fork 函数.通过名字可以看出,这是在父进程的基础上完全拷贝一个子进程.在 Linux 内核中,会复制文件描述符的列表,也会复制内存空间,还会<strong>复制一条记录当前执行到了哪一行程序的进程</strong>.显然,复制的时候在调用 fork,复制完毕之后,父进程和子进程都会记录当前刚刚执行完 fork.这两个进程刚复制完的时候,几乎一模一样,只是根据 fork 的返回值来区分到底是父进程,还是子进程.如果返回值是 0,则是子进程；如果返回值是其他的整数,就是父进程.</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190416204613.png" alt></p><p>因为复制了文件描述符列表, 文件描述符都指向整个内核统一的打开文件列表. <strong>因而父进程刚才因为accept创建的已连接Socket也是一个文件描述符, 同样也会被子进程获得</strong>.</p><ul><li>子进程通过这个已连接<code>Socket</code>和客户端进行互通</li><li>通信完毕之后, 退出进程.</li><li>因为父进程知道子进程的<code>ID</code>(fork后父进程获取返回值), 通过 ID 查看子进程是否完成.</li></ul></li><li><p><strong>将项目转包给独立的项目组(多线程方式)</strong></p><p><strong>多进程</strong>: 每次接一个项目,都申请一个新公司,然后干完了,就注销掉这个公司,实在是太麻烦了.毕竟一个新公司要有新公司的资产,有新的办公家具,每次都买了再卖,不划算.</p><p>通过<code>pthread_create</code>创建一个线程. 在<code>task</code>列表会创建一项, 但是很多资源, 如文件描述符列表, 进程空间, 还是共享的. 只不过多了一个引用.</p><p><img src="C:\develop\blog\newblog\source\_posts\assets\1555418853419.png" alt="1555418853419"></p><blockquote><p>c10k：新来一个<code>TCP</code>连接, 就需要分配一个进程或者线程. <strong>一台机器无法创建很多进程或者线程</strong>,<strong>c10k</strong>它的意思是一台机器要维护 1 万个连接,就要创建 1 万个进程或者线程,那么操作系统是无法承受的.如果维持 1 亿用户在线需要 10 万台服务器,成本也太高了.</p></blockquote><h5 id="进程和线程类比"><a href="#进程和线程类比" class="headerlink" title="进程和线程类比"></a>进程和线程类比</h5><ul><li>创建进程: 成立新公司, 购买新办公家具.</li><li>创建线程, 在<strong>同一个公司</strong>成立项目组.</li></ul></li><li><p><strong>一个项目组支撑多个项目(IO 多路复用, 一个线程维护多个 Socket )</strong></p><p><code>Socket</code>是文件描述符, 某个线程盯的所有<code>Socket</code>, 都放在一个文件描述符集合<code>fd_set</code>中<strong>项目进度墙</strong>, 调用<code>select</code>函数来监听文件描述符集合是否有变化. <strong>一旦有变化, 就会依次查看每个文件描述符</strong>.</p><p>发生变化的文件描述符在 <code>fd_set</code> 对应的位都设为1, 表示<code>Socket</code>可读或者可写, 从而可以进行读写操作, 然后再调用<code>select</code>, 接着盯着下一轮的变化.</p></li><li><p><strong>一个项目支撑多个项目(IO 多路复用, 从”派人盯着”到”有事通知”)</strong></p><p><code>select</code>是通过轮询的方式, <code>select</code>所能监控的数量有<code>FD_SETSIZE</code>限制.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果项目进度方式变化, 不需要监控, 而是主动通知项目组, 然后项目组再根据项目进展情况做相应的操作</span><br></pre></td></tr></table></figure><p>能完成这件事情的函数叫<code>epoll</code>, 是通过注册<code>callback</code>函数的方式, 当某个文件描述符发生变化的时候, 就会主动通知.</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190416205123.png" alt></p><p>假设进程打开了 Socket m, n, x 等多个文件描述符,现在需要通过 epoll 来监听是否这些 Socket 都有事件发生.其中 epoll_create 创建一个 epoll_create 创建一个 epoll 对象,也是一个文件,也对应一个文件描述符,同样也对应着打开文件列表中的一项.在这项里面有一个红黑树,在红黑树里,要保存这个 epoll 要监听的所有 Socket.</p><p>当 epoll_ctl 添加一个 Socket 的时候,其实是加入这个红黑树,同时红黑树里面的节点指向一个结构,将这个结构挂在被监听的 Socket 的事件列表中.当一个 Socket 来了一个事件的时候,可以从这个列表中得到 epoll 对象,并调用 call back 通知它.</p><blockquote><p><strong>epll被称为解决c10k问题的利器</strong></p></blockquote></li></ol><hr><p>References:</p><ul><li><a href="https://stackoverflow.com/questions/152457/what-is-the-difference-between-a-port-and-a-socket" target="_blank" rel="noopener">What is the difference between a port and a socket?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Socket 总结 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Talk is cheap, show me the code&lt;/p&gt;
&lt;p&gt;&lt;em&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Network Protocol UDP and TCP</title>
    <link href="http://yoursite.com/2019/03/15/notes-on-network-protocol-udp-and-tcp/"/>
    <id>http://yoursite.com/2019/03/15/notes-on-network-protocol-udp-and-tcp/</id>
    <published>2019-03-15T14:06:44.000Z</published>
    <updated>2019-04-15T15:36:12.126Z</updated>
    
    <content type="html"><![CDATA[<p>UDP 和 TCP from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a><br><a id="more"></a></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h4 id="UDP-包头格式"><a href="#UDP-包头格式" class="headerlink" title="UDP 包头格式"></a>UDP 包头格式</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190415154349.png" alt></p><blockquote><p><code>IP</code>头里面有个8位协议, 里面会存放, 数据里面到底是<code>TCP</code>还是<code>UDP</code>。处理完<strong>传输层</strong>的事情, <strong>内核的事情基本就干完了</strong>, 里面的数据应该交给应用程序自己去处理。<strong>根据端口号, 将数据交给响应的应用程序</strong>。</p></blockquote><h4 id="UDP-的三大特点"><a href="#UDP-的三大特点" class="headerlink" title="UDP 的三大特点"></a>UDP 的三大特点</h4><ul><li>沟通简单, 没有复杂的数据结构, 处理逻辑, 包头字段. 相信网络通路默认就是很容易送达的，不容易被丢弃的。</li><li>轻信他人, 它不会建立连接，虽然有端口号，但是监听在这个地方，谁都可以传给他数据，他也可以传给任何人数据，甚至可以同时传给多个人数据。</li><li>愣头青, 做事不懂权变。它不会根据网络的情况进行发包的拥塞控制，无论网络丢包丢成啥样了，它该怎么发还怎么发。</li></ul><h4 id="UDP的三大使用场景"><a href="#UDP的三大使用场景" class="headerlink" title="UDP的三大使用场景"></a>UDP的三大使用场景</h4><ul><li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。<ul><li><code>DHCP</code>就是基于<code>UDP</code>协议的(广播形式)。一般的获取 IP 地址都是内网请求，而且一次获取不到 IP 又没事，过一会儿还有机会。</li><li><code>PXE</code>操作系统镜像的下载使用的<code>TFTP</code>，这个也是基于 UDP 协议。</li></ul></li><li>不需要一对一沟通，建立连接，而是可以广播的应用。<ul><li><code>UDP</code>不面向连接, 使得可以继承广播或多播协议。</li><li><code>D</code>类地址(组播地址), 使用这个地址, 可以将包组播给一批机器。当一台机器上的某个进程想监听某个组播地址的时候，需要发送 IGMP 包，所在网络的路由器就能收到这个包，知道有个机器上有个进程在监听这个组播地址。当路由器收到这个组播地址的时候，会将包转发给这台机器，这样就实现了跨路由器的组播。</li></ul></li><li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。</li></ul><blockquote><p>如果实现的应用需要有自己的连接策略, 可靠保证, 时延要求, 使用<code>UDP</code>, 然后在应用层实现这些是再好不过了。</p></blockquote><h4 id="UDP使用的五个例子"><a href="#UDP使用的五个例子" class="headerlink" title="UDP使用的五个例子"></a>UDP使用的五个例子</h4><ul><li><p>网页或者APP的访问</p><p>HTTP 协议是基于 TCP 的，建立连接都需要多次交互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移动中，TCP 可能还会断了重连，也是很耗时的。而且目前的 HTTP 协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 TCP 的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。</p><p><code>QUIC</code>（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是<code>Google</code>提出的一种基于<code>UDP</code>改进的通信协议, 目的是降低网络通信的延迟, 提供更好的用户互动体验。</p></li><li><p>流媒体协议</p><p>直播协议多使用<code>RTMP</code>。 <code>RTMP</code>协议也是基于<code>TCP</code>的。</p><p>很多直播应用，都基于<code>UDP</code>实现了自己的视频传输协议。</p><p>网络层不好, 应用选择性丢帧。</p></li><li><p>实时游戏</p><p>在异步<code>IO</code>机制引入之前, <code>UDP</code>尝尝是应对海量客户端链接的策略。</p><p>游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p></li><li><p>IoT 物联网</p><p>物联网领域终端资源少, 维护<code>TCP</code>协议代价太大. 物联网对实时性要求也很高.</p><p><code>Google</code>推出的物联网通信协议<code>Thread</code>就是基于<code>UDP</code>协议的</p></li><li><p>移动通信领域</p><p>在<code>4G</code>王国利, 移动流量上网的数据面对的协议<code>GTP-U</code>是基于<code>UDP</code>的。<code>GTP</code>协议本身就包含复杂的手机上线下线的通信协议。</p></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote><p><code>TCP</code>天然认为网络环境是恶劣的，丢包，乱序，重传，拥塞都是常用的事情，一言不合就可能送达不到了，<strong>因此要从算法层面来保证可靠性</strong>。</p></blockquote><h4 id="TCP-包头格式"><a href="#TCP-包头格式" class="headerlink" title="TCP 包头格式"></a>TCP 包头格式</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190415155518.png" alt></p><p><strong>序号</strong>：解决乱序问题，确认哪个先来哪个后到。</p><p><strong>确认序号</strong>：确认发出去的包，如果没有收到就应该重新发送，知道送达。<strong>解决不丢包的问题</strong>。</p><p><strong>TCP 状态位</strong></p><ul><li><code>SYN</code>发起一个链接</li><li><code>ACK</code>是回复</li><li><code>RST</code>重新连接</li><li><code>FIN</code>结束链接</li></ul><blockquote><p><code>TCP</code>是面向连接的，因而双方要维护连接的状态，这些<strong>带状态位的包的发送，会引起双方的状态变更</strong>。<strong>就像人与人之间的信任会经过多次交互才能建立</strong>。</p></blockquote><p><strong>窗口大小(流量控制)</strong>：<code>TCP</code>要做流量控制, 通信双方各声明一个窗口，标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><p><strong>拥塞控制</strong>：<code>TCP</code>拥塞控制。控制自己，也即<strong>控制发送速度</strong>。不能改变世界，就改变自己。</p><h4 id="TCP-特点"><a href="#TCP-特点" class="headerlink" title="TCP 特点"></a>TCP 特点</h4><ul><li>顺序问题，稳重不乱</li><li>丢包问题，承诺靠谱</li><li>连接维护，有始有终</li><li>流量控制，把握分寸</li><li>拥塞控制，知进知退</li></ul><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><p><strong>请求-&gt;应答-&gt;应答之应答</strong></p><ul><li>A 发起一个连接请求<ul><li>第一个请求杳无音信<ul><li>包丢了</li><li>包饶弯路, 超时了</li><li>B没有响应, 不想和我连接</li></ul></li><li>再次发送</li><li>终于到达 B, A 暂时还不知道</li></ul></li><li>B 收到了请求包, 知道了 A 的存在, 知道 A 要和它建立链接. 应答<ul><li>B 不乐意建立连接, A 会重试一阵后放弃, 连接建立失败</li><li>B 乐意建立链接, 则会发送应答包给 A<ul><li>不能认为连接建立好<ul><li>应答包会丢失</li><li>应答包会饶弯路</li><li>A 已经挂了</li></ul></li></ul></li><li>B 发送的应答包可能会发送多次, 但是只要一次到达 A, <strong>A 就认为连接已经建立了</strong>, <strong>对于A来说, 他的消息有去有回</strong></li></ul></li><li>A 给 B 发送应答之应答<ul><li>B 也在等待这个消息, 才能确认连接的建立, 只有等到了这个消息, 对于 B 来讲, 才算他的<strong>消息有去有回</strong></li><li><strong>应答之应答</strong>也会丢失, 绕路, 甚至 B 挂了. 只要<strong>双方的消息都有去有回, 就基本可以了</strong>.</li></ul></li></ul><p><strong>需要双方发送的消息都有去有回</strong>.</p><p>大部分情况下, A 和 B 建立了连接之后, A 会马上发送数据, 一旦 A 发送数据就解决了问题.</p><ul><li><strong>应答之应答</strong>丢失. 当 A 连续发送数据的时候, B 可以认为这个连接已经建立.</li><li>B 挂了. A 发送的数据, 会报错, 说 B 不可达, A 就知道 B 出事情了.</li></ul><p><strong>keepalive</strong>, 即使没有真实的数据包, 也有<strong>探活包</strong>.</p><blockquote><p>如果 A 长时间不发包, B 可以主动关闭。</p></blockquote><h4 id="为什么两次握手不行"><a href="#为什么两次握手不行" class="headerlink" title="为什么两次握手不行"></a>为什么两次握手不行</h4><ul><li>A 和 B 原来建立了连接, 做了简单通信, 结束了连接<ul><li>最早 A 第一次发起<strong>请求</strong>的时候, 重复发了很多次包, 如果这个时候<strong>请求</strong>到达. B 会认为这也是一个正常的请求的话, 因此<strong>建立了连接</strong>(如果两次握手就建立链接), 就没有终结了.</li></ul></li></ul><h4 id="TCP-包的序号问题"><a href="#TCP-包的序号问题" class="headerlink" title="TCP 包的序号问题"></a>TCP 包的序号问题</h4><ul><li>A 要告诉 B, 发起包的<strong>序号</strong></li><li>B 同样要高速 A, 发起包的<strong>序号</strong></li></ul><p><strong>序号不能从1开始</strong>, 这样往往会冲突.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A 发送 1 2 3. </span><br><span class="line"></span><br><span class="line">丢了 或者 绕路了.</span><br><span class="line"></span><br><span class="line">A 重新发送 1 2 (这次不发3）</span><br><span class="line"></span><br><span class="line">但是上次绕路的3 又回来了, 发给了B. B 就会错误的认为是下一个包. </span><br><span class="line"></span><br><span class="line"># 不能每次从1开始</span><br></pre></td></tr></table></figure><ul><li>每个连接都要有不同的序号.</li><li>这个序号的起始序号是随着时间变化的.<ul><li>32位的计数器, 每<code>4ms</code>加一.如果到重复, 需要4个多小时, 绕路的包早都死了. 以为<code>IP</code>包头里有个<code>TTL</code>, 也即生存时间.</li></ul></li></ul><h4 id="连接连接过程的状态变化"><a href="#连接连接过程的状态变化" class="headerlink" title="连接连接过程的状态变化"></a>连接连接过程的状态变化</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190415165124.png" alt></p><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ul><li>A: B 不玩了</li><li>B: 你不玩了, 我知道了</li></ul><p>B 不能在 ACK 的时候, 直接关闭. <strong>有可能A是发完了最后的数据就准备不玩了, 但是 B 还没做完自己的事情, 还是可能在发送数据的</strong>, 所以称为<strong>半关闭</strong>的状态.</p><p>A 可以选择不再接收数据, 也可以选择最后再接收一段数据, 等待 B 也主动关闭.</p><ul><li>B: A 好啊, 我也不玩了, 拜拜</li><li>A: 好的, 拜拜</li></ul><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li>A : B 不玩了</li><li>B: 你不玩了, 我知道了</li><li>A 没收到回复<ul><li>重新发送”不玩了”</li></ul></li><li>A 收到回复<ul><li>A 跑路了, B 发起的请求得不到A的应答</li><li>B 跑路了, A 不知道 B 是还有事情要处理, 还是过一会会发送结束</li></ul></li></ul><h4 id="断开时序图"><a href="#断开时序图" class="headerlink" title="断开时序图"></a>断开时序图</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190415165210.png" alt></p><ul><li><p>A : B 不玩了, <strong>FIN-WAIT-1</strong></p></li><li><p>B: 你不玩了, 我知道了 <strong>CLOSE-WAIT</strong></p></li><li><p>A 收到回复 <strong>FIN-WAIT-2</strong></p><ul><li>B 跑路了, <code>Linux</code>调整<code>tcp_fin_timeout</code>这个参数, 设置超时时间</li></ul></li><li><p>B: A 好啊, 我也不玩了, 拜拜 <strong>LAST_ACK</strong></p></li><li>A: 好的, 拜拜<ul><li>发送 ACK, <strong>FIN-WAIT-2</strong>结束.</li><li>如果这个 ACK, B 收不到<ul><li>B 重新发送一个 <code>A 好啊, 我也不玩了</code>, 如果这个时候 A 已经跑路了, B 就再也收不到 ACK 了</li></ul></li><li><code>TCP</code>协议要求 A 最后等待一段时间<strong>TIME-WAIT</strong>, 这个时间要足够长到如果 B 没收到 ACK, B说 <code>A 好啊, 我也不玩了</code>会重发的<ul><li>A 会重新发一个 ACK 并且足够时间到达 B</li></ul></li><li>如果 A 直接跑路, 端口就直接空出来了, 但是 B 不知道, B 原来发过的很多包可能都还在路上. 如果 A 的端口被一个新的应用占用了, 就会收到 B 发过来的包(虽然需要会重新生成). <strong>双保险, 为了防止混乱, 需要等足够长的时间, 等待原来B发送的所有包都死翘翘, 再空出端口</strong>.</li></ul></li></ul><p><strong>等待时间</strong>：等待时间设为<code>2MSL</code></p><blockquote><p><strong>MSL 是 Maximum Segment Liftetime</strong>, 报文最大生存时间. 它是任何报文在网络上存在的最长时间, 超过这个时间报文将被丢弃.</p><p><code>IP</code>头中有一个<code>TTL</code>, 是<code>IP</code>数据报可以经过的<strong>最大路由数</strong>, 每经过一个处理他的路由器此值就减1, 当此值为0则数据报将被丢弃, 同时发送<code>ICMP</code>报文通知主机.</p><p>协议规定<code>MSL</code>为2分钟, 实际应用中常用的是30秒, 1分钟和2分钟等.</p></blockquote><p><strong>超过了 2MSL</strong></p><ul><li>按照 TCP 的原理, B 重发<code>FIN</code></li><li>A 收到<code>FIN</code>, 表示超过时间了. 直接发送 <code>RST</code></li></ul><h4 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190415165717.png" alt></p><ul><li><p>数字是连接状态变化</p></li><li><p>虚线是 A 的连接</p></li><li>实线是 B 的连接</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UDP 和 TCP from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes On MySQL Locking</title>
    <link href="http://yoursite.com/2019/03/08/notes-on-MySQL-locking/"/>
    <id>http://yoursite.com/2019/03/08/notes-on-MySQL-locking/</id>
    <published>2019-03-08T13:43:42.000Z</published>
    <updated>2019-04-08T14:15:30.684Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL里面的锁可以分为：全局锁、表级锁、行级锁<br><a id="more"></a></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul><li>对整个数据库实例加锁。</li><li>使用场景：做全库逻辑备份时，为了保证备份期间的库在同一个逻辑时间点，即一致性视图（类似于可重复读隔离级别的效果）</li></ul><p>全局锁两种方式：</p><ul><li><em>Flush tables with read lock(FTWRL)</em> 使数据库处于只读状态，数据的增删改、数据定义语句和更新类事务的提交语句都会被阻塞</li><li><em>mysqldump</em> 官方自带的逻辑备份工具，参数 <em>-single-transaction</em> 会在导数据之前启动一个事务，确保拿到一致性视图</li></ul><p>以上两种方式不同点：</p><p>使用 <em>mysqldump</em> 前提是 <strong>引擎支持隔离级别</strong> ，所以<em>single-transaction</em>方法只适用于支持事务引擎的库；MyISAM不支持事务，所以只能使用FTWRL命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global readonly = true</span><br></pre></td></tr></table></figure><p>这条语句也可以做到全库只读，但是不建议使用：</p><ul><li>有时 readonly 会用来判断库是主库还是备库，因此修改global变量的方式影响会比较大</li><li>异常处理方面：FTWRL后客户端异常断开，MySQL会自动释放全局锁，库恢复正常；设置readonly，客户端异常，则会保持readonly，会导致长时间处于不可写状态，风险较高</li></ul><blockquote><p>以上哪种方式，一个库被全局上锁后，对立面任何一个表做字段操作，都会被锁住的</p></blockquote><p>即使没有全局加锁，有了表级锁，加字段也会遇到问题</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL有两种表级别的锁：一种是表锁、另一种是元数据锁( metadata lock，MDL )</p><h4 id="表级锁的语法："><a href="#表级锁的语法：" class="headerlink" title="表级锁的语法："></a>表级锁的语法：</h4><p><code>lock tables xxx read/write</code></p><p>例如 线程A执行了<code>lock table t1 read,t2 write</code> 效果是 <strong>包括A线程在内的所有线程对于t1表只可读，写被阻塞；t2表读写都被阻塞</strong></p><p>lock tables 操作可以用 unlock tables 主动释放，也可以在客户端断开的时候自动释放。  </p><blockquote><p>该操作不仅阻塞其他线程的操作，也阻塞了当前线程的操作</p></blockquote><p>对于innoDB这种支持行锁的引擎，一般不使用<code>lock tables</code>命令控制并发，影响过大</p><h4 id="另一种表级锁：MDL-metadata-lock"><a href="#另一种表级锁：MDL-metadata-lock" class="headerlink" title="另一种表级锁：MDL(metadata lock)"></a>另一种表级锁：<code>MDL(metadata lock)</code></h4><p>MDL在访问一个表的时候会自动加上，MDL的作用是，保证读写的正确性。当表做增删改查操作时，加MDL读锁；当对表结构变更的时候，加MDL写锁。</p><ul><li>读锁之间不互斥，多线程可对同一张表增删改查</li><li>读写锁之间、写锁之间互斥。两个线程同时给一个表增加字段，则第二个需要等待第一个执行完才能继续</li><li>MDL锁在语句执行开始时申请，事务结束后释放</li></ul><h4 id="如何给小锁安全的加字段"><a href="#如何给小锁安全的加字段" class="headerlink" title="如何给小锁安全的加字段"></a>如何给小锁安全的加字段</h4><ul><li><p>解决长事务，当做DDL变更的表中正好在执行长事务，则从information_schema库的innodb_trx找到当前执行长事务，先kill掉长事务或者暂停DDL</p></li><li><p>比较理想的状态：修改表结构语句alter table可以设置等待时间，如果该时间内拿不到MDL锁，则该时间内拿不到MDL锁，则放弃执行，不会阻塞后面的语句</p><p>MariaDB/ALiSQL已经支持 <code>DDL NOWAIT/WAIT n</code> 这个语法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table tb1_name NOWAIT add column...</span><br><span class="line">alter table tb1_name WAIT N add column...</span><br></pre></td></tr></table></figure><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul><li><p>定义：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放， 而是要等到事务结束时才释放</p></li><li><p>建议：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</p></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>定义：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态</li><li>解决方案<ul><li>通过参数 <code>innodb_lock_wait_timeout</code> 根据实际业务场景来设置超时时间，InnoDB 引擎默认值是50s</li><li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑（默认是开启状态）。</li></ul></li></ul><h4 id="如何解决热点行更新导致的性能问题？"><a href="#如何解决热点行更新导致的性能问题？" class="headerlink" title="如何解决热点行更新导致的性能问题？"></a>如何解决热点行更新导致的性能问题？</h4><ul><li>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用</li><li>控制并发度，对应相同行的更新，在进入引擎之前排队。这样在InnoDB内部就不会有大量的死锁检测工作了</li><li>将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高</li></ul><p>Innodb 行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL里面的锁可以分为：全局锁、表级锁、行级锁&lt;br&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Network Protocol 7 layers</title>
    <link href="http://yoursite.com/2019/03/08/notes-on-network-protocol-7-layers/"/>
    <id>http://yoursite.com/2019/03/08/notes-on-network-protocol-7-layers/</id>
    <published>2019-03-08T10:24:47.000Z</published>
    <updated>2019-04-17T08:03:06.560Z</updated>
    
    <content type="html"><![CDATA[<p>网络七层协议总结 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a></p><a id="more"></a><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="电脑和电脑使用网线连接"><a href="#电脑和电脑使用网线连接" class="headerlink" title="电脑和电脑使用网线连接"></a>电脑和电脑使用网线连接</h3><p><strong>1-3，2-6</strong>交叉接法。</p><p>水晶头的第 1、2 和第 3、6 脚， 它们分别起着收、发信号的作用。 将一端的 1 号和 3 号线、2 号和 6 号线互换一下位置， 就能够在物理层实现一端发送的信号， 另一端能收到。</p><h3 id="Hub-集线器"><a href="#Hub-集线器" class="headerlink" title="Hub 集线器"></a>Hub 集线器</h3><p>采取的是广播模。遗留的几个问题:</p><ul><li>这个包是发给谁的？谁应该接收？</li><li>大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</li><li>如果发送的时候出现了错误，怎么办？</li></ul><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p><strong>背景: 上述 HUB 遗留的问题，大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？</strong></p><p>Medium Access Control， 媒体访问控制。</p><p>控制在往媒体发数据的时候， 谁先发， 谁后发的问题。 防止发生混乱。 (解决上述第2个问题)， 学名叫<strong>多路访问</strong>， 下面是解决多路访问的三种算法方式。</p><ul><li><p><strong>信道划分</strong></p><p>分多个车道。 每个车一个车道， 你走你的， 我走我的。 这在计算机网里叫作信道划分。</p></li><li><p><strong>轮流协议</strong></p><p>今天单号出行， 明天双号出行， 轮着来。 这在计算机网络里叫作轮流协议。</p></li><li><p><strong>随机接入协议</strong></p><p>不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作随机接入协议。著名的<strong>以太网，用的就是这个方式</strong>。</p></li></ul><h3 id="链路层地址"><a href="#链路层地址" class="headerlink" title="链路层地址"></a>链路层地址</h3><p><strong>解决: 这个包是发给谁的？谁应该接收？</strong></p><p>物理地址， 叫做<strong>链路层(第一层)地址</strong>。 因为第二层主要解决媒体接入控制的问题， 所以它常被称为<code>MAC</code>地址。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413111538.png" alt></p><h4 id="NGINX-访问示例"><a href="#NGINX-访问示例" class="headerlink" title="NGINX 访问示例"></a>NGINX 访问示例</h4><p>有了这个目标 MAC 地址，，<strong>数据包在链路上广播</strong>，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80，而 nginx 就是监听 80。</p><p>于是将请求提交给 nginx，nginx 返回一个网页。然后将网页内容发回请求的机器。然后层层封装，最后到 MAC 层。因为来的时候有源 MAC 地址，返回的时候，源 MAC 就变成了目标 MAC，再返给请求的机器。</p><h4 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h4><p>循环冗余检测</p><p><strong>解决: 如果发送的时候出现了错误，怎么办？</strong></p><p>通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。</p><h4 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h4><p>已知<code>IP</code>地址， 求<code>MAC</code>地址的协议。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413112027.png" alt></p><p>询问和应答的报文：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413112121.png" alt></p><p>机器本地会进行<code>ARP</code>缓存。 <code>ARP</code>的<code>MAC</code>地址缓存过一段时间就会过期。</p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>一旦机器数目增多， 问题就出现了。 因为 <strong>Hub</strong> 是广播的，不管某个接口是否需要，所有的<code>Bit</code>都会被发送出去，然后让主机来判断是不是需要。 产生冲突的概率就提高了。</p><p><strong>交换机学习</strong></p><p>一台<code>MAC1</code>电脑将一个包发送给另一台 MAC2 电脑，当这个包到达交换机的时候，一开始交换机也不知道 MAC2 的电脑在哪个口， 所以没办法， 它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住， MAC1 是来自一个明确的口。以后有包的目的地址是 MAC1 的， 直接发送到这个口就可以了。</p><p><strong>转发表</strong></p><p>当交换机作为一个关卡一样, 过了一段时间之后, 就有了整个网络的一个结构了, 这个时候, 基本上不用广播了, 全部可以准确转发. 当然, 每个机器的 IP 地址会变, 所在的口也会变,因而交换机上的学习的结果,我们称为转发表, 是有一个过期时间的.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>MAC</code>层是用来解决多路访问堵车问题的</li><li><code>APR</code>是通过吼的方式来寻找目标的<code>MAC</code>地址的，吼完之后记住一段时间,，这个叫做缓存</li><li>交换机是有<code>MAC</code>地址学习能力的,，学完了它就知道谁在哪儿了，不用广播了</li></ul><h3 id="交换机与-VLAN"><a href="#交换机与-VLAN" class="headerlink" title="交换机与 VLAN"></a>交换机与 VLAN</h3><p>多台交换机之间连接起来, 形成一个<strong>拓扑结构</strong>。</p><p><strong>环路问题</strong>：交换机之间重复发送 ARP 广播</p><p>解决方式：STP (最小生成树)</p><p>多个交换机之间的<strong>广播问题和安全问题</strong></p><ul><li>一大堆机器广播, 性能下降</li><li>有的需要保密, 所有包都会在一个局域网传输, 如果没有加密会有安全问题.</li></ul><p><code>VLAN</code>，<strong>虚拟局域网</strong>。</p><p>使用<code>VLAN</code>, 一个交换机会连属于多个局域网的机器，在原来的二层的头上加一个<code>TAG</code>，里面有一个<code>VLAN ID</code>来区分不同的局域网。<strong>交换机之间可以通过 <code>Trunk</code> 口互相连接</strong></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>也即 IP 层</p><h3 id="ICMP-协议的格式"><a href="#ICMP-协议的格式" class="headerlink" title="ICMP 协议的格式"></a>ICMP 协议的格式</h3><p><code>ICMP</code>全称<code>Internet Control Message Protocol</code>，互联网控制报文协议。是封装在<code>IP</code>报文里面的。</p><p><strong>ICMP</strong>属于网络层(IP)协议。 发送不涉及到传输层， 没有端口的概念。</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190413220937.png" alt></p><h3 id="MAC-头和-IP-头的细节"><a href="#MAC-头和-IP-头的细节" class="headerlink" title="MAC 头和 IP 头的细节"></a>MAC 头和 IP 头的细节</h3><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190414204325.png" alt></p><p>任何一台机器，当腰访问另一个IP地址的时候， 会先判断, 这个目标 IP 地址，和当前机器的 IP 地址，是否在同一个网段.。(通过CIDR, 子网掩码)</p><ul><li>如果是同一个网段：<strong>不经过网关</strong>直接将源地址和目标地址放入<code>IP</code>头中。然后通过 ARP 获得 MAC 地址， 将源 <code>MAC</code> 和目的 <code>MAC</code> 放入 <code>MAC</code> 头中，发出去就可以了。</li><li>如果不是同一个网段：需要<strong>发往默认网关GateWay</strong>。Gateway 的地址一定是和源 IP 地址是一个网段的。往往不是第一个，就是第二个。例如 <code>192.168.1.0/24</code> 这个网段，Gateway 往往会是<code>192.168.1.1/24</code> 或者 <code>192.168.1.2/24</code>。(通过 ARP 获得网关 MAC 地址, 然后发送)</li></ul><p>网关往往是一个路由器，是一个三层转发的设备(网络层)。</p><ul><li>一个路由器有多个网口</li><li>一台服务器做这个网关则会有多个网卡, 其中一个网卡是和源IP同网段的</li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 <code>IP</code>地址都和局域网的<code>IP</code>地址相同的网段，每只手都是它握住的那个局域网的网关。</p><p>任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。</p><blockquote><p>MAC 地址是一个局域网内才有效的地址。<code>MAC</code>地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于<code>IP</code>地址是否改变。不改变<code>IP</code>地址的网关，我们称为转发网关；改变<code>IP</code>地址的网关，我们称为<code>NAT</code>网关。</p></blockquote><ul><li><p>静态路由</p><p>配置复杂的策略路由, 控制转发策略</p></li><li><p>动态路由</p><ul><li>距离矢量算法<strong>BGP</strong></li><li>链路状态算法<strong>OSPF</strong></li></ul></li></ul><p>路由器是一台网络设备, 有多张网卡. 当一个口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为<strong>路由表</strong>。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>如果离开本局域网，就需要经过网关，网关是路由器的一个网口</li><li>路由器是一个三层设备，里面有如何寻找下一跳的规则</li><li>转发网关, <strong>MAC变 IP不变</strong></li><li>NAT网关, <strong>IP变</strong></li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层里比较重要的两个协议， <a href="https://www.shinhwa.wang/2019/03/15/notes-on-network-protocol-udp-and-tcp/" target="_blank" rel="noopener">TCP 和 UDP</a></p><h4 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h4><ul><li><p>面向连接</p><p>在互通之前, 面向连接的协议会先<strong>建立连接</strong>。<code>TCP</code>会三次握手，<code>UDP</code>不会</p><blockquote><p>是为了在客户端和服务端维护连接,，而<strong>建立一定的数据结构来维护双方交互的状态, 用这样的数据结构来保证所谓的面向连接的特性</strong>。</p></blockquote></li><li><p>可靠性</p><ul><li>TCP提供可靠交付, 通过<code>TCP</code>连接传输的数据，无差错、不丢失、不重复、并且按序到达</li><li><code>IP</code>包没有任何可靠性。<code>UDP</code>继承了<code>IP</code>包的特性, 不保证不丢失, 不保证按顺序到达</li></ul></li><li>传输<ul><li><code>TCP</code>是面向字节流的。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的<code>IP</code>包。之所以变成了流, 这也是<code>TCP</code>自己的状态维护做的事情</li><li><code>UDP</code>继承了<code>IP</code>的特性, 基于数据报的, 一个一个地发, 一个一个地收</li></ul></li><li>拥塞控制<ul><li><code>TCP</code>是可以拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点</li><li><code>UDP</code>应用让我发，我就发，管它洪水滔天</li></ul></li><li>有状态服务<ul><li><code>TCP</code>其实是一个有状态服务。精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行</li><li><code>UDP</code>是无状态服务, 发出去就发出去了</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>MAC</code>层定义了本地局域网的传输行为,<code>IP</code>层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：</p><p><strong>网络传输</strong>是以<strong>包</strong>为单位的</p><ul><li>二层传输叫<strong>帧</strong></li><li>网络层叫<strong>包</strong></li><li>传输层叫<strong>段</strong></li></ul><h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a><a href="https://www.shinhwa.wang/2019/04/01/notes-on-network-protocol-socket/" target="_blank" rel="noopener">套接字</a></h4><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>Http 和 Https 总结</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络七层协议总结 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Network Protocol Overview</title>
    <link href="http://yoursite.com/2019/03/07/notes-on-network-protocol-overview/"/>
    <id>http://yoursite.com/2019/03/07/notes-on-network-protocol-overview/</id>
    <published>2019-03-07T15:00:17.000Z</published>
    <updated>2019-04-14T14:09:06.246Z</updated>
    
    <content type="html"><![CDATA[<p>网络协议大致框架 from <a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener">极客时间 - 趣谈网络协议</a><br><a id="more"></a></p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li><p>应用层</p><p>浏览器输入网址，DNS 查找目标 IP。HTTPS 协议打包请求信息。此处包含 HTTP 头和报文信息。</p></li><li><p>传输层</p><p>通过 socket 编程来实现 TCP ( 面向连接 ) 和 UDP 两种协议。TCP 头包含客户端和服务器监听端口。如果发生丢包，客户端会发包重试。</p></li><li><p>网络层</p><p>操作系统的网络层使用 IP 协议封装 IP 头，包括客户端和服务端 IP。</p></li><li><p>数据链路层</p><p>操作系统通过 ARP 协议查找网关 MAC，封装 MAC 头，包括客户端 MAC 和网关 MAC.</p></li><li><p>物理层</p><p>通过路由协议寻找目标服务器 IP 以及 MAC 地址</p></li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>和客户端相反的方向，服务器校验 MAC 地址正确，取 MAC 头，然后交给操作系统网络层检验 IP ，取 IP 头，再交给传输层，即 TCP 层。这一层里服务端收到的每一个包都要原路返回回复给客户端。TCP 头中包含服务器的端口号，找到服务端的进程对请求处理（此处处理往往通过 RPC 即远程调用方式来实现不同进程间调用通信）。最后再将处理结果原路返回给客户端浏览器。</p><h4 id="网络分层的理解"><a href="#网络分层的理解" class="headerlink" title="网络分层的理解"></a>网络分层的理解</h4><ul><li><strong>只要在网络上跑的包，都是完整的</strong>。<strong>可以有下层没上层，绝不可能有上层没下层</strong></li><li>二层设备收到的是整个网络包。包括 HTTP, TCP, IP, MAC都有。二层设备只把 MAC 头摘下来，看看到底是丢弃、转发、还是自己留着。二层设备是工作在数据链路层的设备，通常是交换机，可以通过地址表确定 MAC 地址和对应端口。如果都不存在会更新地址表。</li><li>三层设备就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发、还是自己留着。三层设备是工作在网络层的设备，通常是指路由器。</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190408174305.png" alt></p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><ul><li>IP 是地址，有定位功能； MAC 是身份证，误定位功能</li><li>CIDR 无类型域间选路。把 IP 分为网络号和主机号，中间斜杠 / 区分</li><li>IP 分公有 IP 和私有 IP</li></ul><h4 id="DHCP-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP ( Dynamic Host Configuration Protocol )"></a>DHCP ( Dynamic Host Configuration Protocol )</h4><p>动态主机配置协议。新机器加入会发送一个广播包，里面封装了 MAC 头，IP 头，UDP 头，BOOTP 头，以及请求内容。MAC 地址是唯一的身份，可以确定是否需要分配新的 IP。DHCP server 会广播返回消息包。包括 MAC 头，IP 头，UDP 头，BOOTP 头，同时包含新 IP 地址的合法租用信息和其他配置信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络协议大致框架 from &lt;a href=&quot;https://time.geekbang.org/column/intro/85&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on MySQL Overview</title>
    <link href="http://yoursite.com/2019/03/02/notes-on-MySQL-overview/"/>
    <id>http://yoursite.com/2019/03/02/notes-on-MySQL-overview/</id>
    <published>2019-03-02T10:29:57.000Z</published>
    <updated>2019-04-08T13:42:11.446Z</updated>
    
    <content type="html"><![CDATA[<p>读书笔记：《 MySQL 实战 45 讲》，MySQL 基本原理介绍，极客时间笔记</p><p><em><a id="more"></a></em></p><h2 id="MySQL-基础架构，主要包括-Server-层和储存引擎层"><a href="#MySQL-基础架构，主要包括-Server-层和储存引擎层" class="headerlink" title="MySQL 基础架构，主要包括 Server 层和储存引擎层"></a>MySQL 基础架构，主要包括 Server 层和储存引擎层</h2><ul><li>Server 端<ul><li>连接器：管理连接、权限验证</li><li>分析器：词法分析、语法分析</li><li>优化器：执行计划生成、索引选择</li><li>执行器：操作引擎、返回结果</li></ul></li><li>存储引擎层负责数据的存储和提取。场景的存储引擎有 <strong>InnoDB</strong>( 5.5 之后为默认)、MyISAM、Memory</li></ul><p>逻辑架构图：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190402184504.png" alt></p><h2 id="日志系统-redo-log-和-binLog"><a href="#日志系统-redo-log-和-binLog" class="headerlink" title="日志系统 redo log 和 binLog"></a>日志系统 redo log 和 binLog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> create table T(ID int primary key, c int);</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><h4 id="InnodDB-redo-log"><a href="#InnodDB-redo-log" class="headerlink" title="InnodDB redo log"></a>InnodDB redo log</h4><p>如果每次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候，这就像打烊以后掌柜做的事。</p><ul><li>WAL技术：Write-Ahead Logging，先写日志，再写磁盘</li><li>当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里，并更新内存。其它合适时间再写入磁盘</li></ul><p>有了redo log，Inno DB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p><h4 id="MySQL-binlog（归档日志）"><a href="#MySQL-binlog（归档日志）" class="headerlink" title="MySQL binlog（归档日志）"></a>MySQL binlog（归档日志）</h4><p>redo log是 InnoDB 引擎特有的日志，而Server层也有自己的日志，称为binlog。</p><h4 id="redo-log-和-binlog-不同点"><a href="#redo-log-和-binlog-不同点" class="headerlink" title="redo log 和 binlog 不同点"></a>redo log 和 binlog 不同点</h4><ul><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL的 Server 层实现的，所有引擎都能用</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的，写到一定大小会切换到下一个文件，不会覆盖以前的日志</li></ul><p>我们来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ul><li>执行器先找引擎取 ID = 2 这一行。 ID 是主键，引擎直接用树搜索找到这一行。如果ID = 2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</li><li>执行器拿到引擎给的行数据，把这个值加上 1 ，比如原来是 N ， 现在就是 N+1 ，得到新的一行数据，再调用引擎接口写入这行新数据</li><li>引擎将这行数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状体啊。然后告知执行期执行完成了，随时可以提交事务</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成 提交（commit）状态，更新完成</li></ul><h4 id="redolog两阶段提交"><a href="#redolog两阶段提交" class="headerlink" title="redolog两阶段提交"></a>redolog两阶段提交</h4><p>redo log 和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>事务：ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><p>隔离级别：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）</p><p>事务隔离的实现：在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>长事务：系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h4 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h4><ul><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback</li><li>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit  或  rollback 语句，或者断开连接</li></ul><p>建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。避免长连接导致长事务。</p><h4 id="查询长事务"><a href="#查询长事务" class="headerlink" title="查询长事务"></a>查询长事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60; -- 查找持续时间超过60s的事务</span><br></pre></td></tr></table></figure><h2 id="深入浅出索引"><a href="#深入浅出索引" class="headerlink" title="深入浅出索引"></a>深入浅出索引</h2><h4 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h4><ul><li>哈希表 ( 查询效率不高 )</li><li>有序数组 （ 增删效率低，适合静态存储 ）</li><li><strong>搜索树</strong></li></ul><h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul><li><p>主键索引</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）</p></li><li><p>非主键索引</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 <a href="https://www.shinhwa.wang/2019/04/04/binary-tree-B-tree-B+-Tree/" target="_blank" rel="noopener">B+ 树</a> ；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该<strong>尽量使用主键查询</strong>。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果执行的语句是select ID from T where k between 3 and 5，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><h4 id="索引下推-（index-condition-pushdown"><a href="#索引下推-（index-condition-pushdown" class="headerlink" title="索引下推 （index condition pushdown)"></a>索引下推 （index condition pushdown)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> select * from tuser where name like '张%' and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/20190405153458.png" alt></p><p><strong>InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读书笔记：《 MySQL 实战 45 讲》，MySQL 基本原理介绍，极客时间笔记&lt;/p&gt;
&lt;p&gt;&lt;em&gt;
    
    </summary>
    
      <category term="Database" scheme="http://yoursite.com/categories/Database/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Notes On Tcpdump and Wireshark</title>
    <link href="http://yoursite.com/2019/02/27/notes-on-tcpdump-and-Wireshark/"/>
    <id>http://yoursite.com/2019/02/27/notes-on-tcpdump-and-Wireshark/</id>
    <published>2019-02-27T13:44:24.000Z</published>
    <updated>2019-04-07T15:05:54.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tcpdump-和-Wireshark"><a href="#tcpdump-和-Wireshark" class="headerlink" title="tcpdump 和 Wireshark"></a>tcpdump 和 Wireshark</h3><p>这个例子只是执行 ping 指令的一个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn udp port 53 or host x.x.x.x -w ping.pcap</span><br></pre></td></tr></table></figure><ul><li>-nn 不解析抓包中的域名（不反向解析）、协议以及端口号</li><li>udp port 53 只显示 UDP 协议的端口号（包括源端口和目的端口）为 53 的包</li><li>host x.x.x.x 只显示 IP 地址（包括原地址和目的地址）为 x.x.x.x 的包</li><li>or 或的关系</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900591970.png" alt></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900605148.png" alt></p><p>HTTP 的一个例子，便于理解 TCP 三次握手和四次挥手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn host example.com -w web.pcap</span><br><span class="line">curl example.com</span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901484205.png" alt></p><p>可以看到TCP 三次握手和四次挥手的请求</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901518443.png" alt></p><p>顺便复习一下流程：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901543490.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tcpdump-和-Wireshark&quot;&gt;&lt;a href=&quot;#tcpdump-和-Wireshark&quot; class=&quot;headerlink&quot; title=&quot;tcpdump 和 Wireshark&quot;&gt;&lt;/a&gt;tcpdump 和 Wireshark&lt;/h3&gt;&lt;p&gt;这个
      
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Tcpdump" scheme="http://yoursite.com/tags/Tcpdump/"/>
    
      <category term="Wireshark" scheme="http://yoursite.com/tags/Wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 206. Reverse Linked List</title>
    <link href="http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/"/>
    <id>http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/</id>
    <published>2019-02-26T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>单链表反转</p><p>题目来源：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/?</p><p>代码效率：100%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>迭代法：将当前节点的后继节点指向前一个节点，移动当前节点</p><p>递归法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nonesense"><a href="#Nonesense" class="headerlink" title="Nonesense"></a>Nonesense</h3><p>最简单的单链表居然花费了我半天的时间，最后还是参考别人的答案才写出来。。。智商捉急</p><p>总结一下问题：</p><ul><li>太急躁，要静下心来慢慢梳理过程，整理成代码输出</li><li><strong>java变量指针等概念感觉还是不清晰</strong>，今天抽空需要补一下</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;单链表反转&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 448 Find All Numbers Disappeared in an Array</title>
    <link href="http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/"/>
    <id>http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/</id>
    <published>2019-02-24T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：</p><p>题目来源：<a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/N</p><p>代码效率： 95.58%</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>取负法：不管一个元素出现一次还是两次，只要出现它对应的位置就会被取负。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[val] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nums[val] = -nums[val];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>感觉这个题就是单纯考虑数学技巧，做起来比较吃力，看答案的时候豁然开朗，还是慢慢积累吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 283 Move Zeroes</title>
    <link href="http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/"/>
    <id>http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/</id>
    <published>2019-02-23T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变</p><p>题目来源：<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一个快指针，一个慢指针，快指针指向不为0的元素，快慢指针值交换，同时向后移动一位。这样可以保证下面两个条件：</p><ul><li>快慢指针之间的元素都是0</li><li>慢指针之前的元素都不为0<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>一开始理解错误，以为把0都放到后面之后还是要对前面从大到小进行排序。。。结果想了半天</p><p>以后还是要仔细审题，不要怀疑自己，先用自己的想法暴力实现</p><p>写代码之前可以举个栗子来一步一步推敲，想好边界和规律再写代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 136. Single Number</title>
    <link href="http://yoursite.com/2019/02/22/leetcode-136-single-number/"/>
    <id>http://yoursite.com/2019/02/22/leetcode-136-single-number/</id>
    <published>2019-02-22T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。</p><p>题目来源：<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用异或 <code>^</code></p><ul><li>两个相同的数异或后为0</li><li>0和一个数异或后为那个数</li><li>异或运算满足交换律</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            result^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 226. Invert Binary Tree</title>
    <link href="http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/"/>
    <id>http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/</id>
    <published>2019-02-21T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>反转二叉树左右子树</p><p>题目来源：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/ N</p><p>代码效率：100.00%</p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>左子树和右子树递归互换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>对递归还是理解不透彻，总结一下如何处理递归问题：</p><blockquote><p>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;反转二叉树左右子树&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/invert-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/invert-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 104. Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/"/>
    <id>http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/</id>
    <published>2019-02-20T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>计算二叉树的深度</p><p>题目来源：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：思路很乱，参考 Discuss 的答案</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>递归左右子树，对深度最大的子树进行递归调用并+1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;计算二叉树的深度&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-depth-of-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 617 Merge Two Binary Trees</title>
    <link href="http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/"/>
    <id>http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/</id>
    <published>2019-02-19T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。</p><p>题目来源：<a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-binary-trees/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/1</p><p>代码效率：98.24%</p><p>耗时：25分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>主要考察对递归算法的理解。</p><ul><li>首先考虑边界，如果两个子二叉树都为空，则新的二叉树必定为空</li><li>考虑其中一个子二叉树为空，则新的二叉树直接等于另外一个子二叉树</li><li>如果两个子二叉树都不为空，新二叉树节点值为两个子二叉树对应节点的值的和，同时对两个子二叉树的左右子树进行递归调用，仔细想想就明白了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode ret;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">            ret.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">            ret.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然别人思路的总是最好的 o(╥﹏╥)o</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    TreeNode result = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    result.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    result.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>学习数据结构的时候，总感觉递归对自己来说是弱项，智商不够用。今天居然一次性直接做出来了。学习数据结构和算法真的能培养思维逻辑和解决问题的能力。fighting !!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-two-binary-trees/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 461 Hamming Distance</title>
    <link href="http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/"/>
    <id>http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/</id>
    <published>2019-02-18T13:44:24.000Z</published>
    <updated>2019-03-31T15:02:57.233Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>统计两个整数转换成二进制位时位数不同的个数。</p><p>题目来源：<a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/hamming-distance/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/2 (少写了 return 语句。。)</p><p>代码效率：91.77%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>二进制的每一位的值不是 0 就是 1，就是整数除以 2 取余的结果，判断是否相等。然后再取模（相当于向左移动一位），再取余作比较。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span> || y != <span class="number">0</span>)&#123;</span><br><span class="line">            i = x % <span class="number">2</span>;</span><br><span class="line">            j = y % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">            y = y / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人的一行代码实现Orz：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;统计两个整数转换成二进制位时位数不同的个数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/hamming-distance/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
</feed>
