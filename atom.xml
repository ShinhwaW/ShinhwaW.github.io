<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shinhwa&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T16:13:33.950Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shinhwa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes On Network</title>
    <link href="http://yoursite.com/2019/02/27/notes-on-network/"/>
    <id>http://yoursite.com/2019/02/27/notes-on-network/</id>
    <published>2019-02-27T13:44:24.000Z</published>
    <updated>2019-03-27T16:13:33.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h3><ul><li><p>带宽</p><p>表示链路的最大传输速率，单位是 b/s （ 比特 / 秒 ) 。常见的带宽有 1000M、10G、40G、100G 等。</p></li><li><p>吞吐量</p><p>表示没有丢包时的最大数据传输速率，单位通常是 b/s （ 比特 / 秒 )  或者 B/s ( 字节 / 秒 ) 。</p></li><li><p>延时</p><p>表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。</p></li><li><p>PPS ( Packet Per Second )<br>表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力。</p><a id="more"></a></li></ul><h3 id="tcpdump-和-Wireshark"><a href="#tcpdump-和-Wireshark" class="headerlink" title="tcpdump 和 Wireshark"></a>tcpdump 和 Wireshark</h3><p>这个例子只是执行 ping 指令的一个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn udp port 53 or host x.x.x.x -w ping.pcap</span><br></pre></td></tr></table></figure><ul><li>-nn 不解析抓包中的域名（不反向解析）、协议以及端口号</li><li>udp port 53 只显示 UDP 协议的端口号（包括源端口和目的端口）为 53 的包</li><li>host x.x.x.x 只显示 IP 地址（包括原地址和目的地址）为 x.x.x.x 的包</li><li>or 或的关系</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900591970.png" alt></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900605148.png" alt></p><p>HTTP 的一个例子，便于理解 TCP 三次握手和四次挥手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn host example.com -w web.pcap</span><br><span class="line">curl example.com</span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901484205.png" alt></p><p>可以看到TCP 三次握手和四次挥手的请求</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901518443.png" alt></p><p>顺便复习一下流程：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901543490.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络性能指标&quot;&gt;&lt;a href=&quot;#网络性能指标&quot; class=&quot;headerlink&quot; title=&quot;网络性能指标&quot;&gt;&lt;/a&gt;网络性能指标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;带宽&lt;/p&gt;
&lt;p&gt;表示链路的最大传输速率，单位是 b/s （ 比特 / 秒 ) 。常见的带宽有 1000M、10G、40G、100G 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;吞吐量&lt;/p&gt;
&lt;p&gt;表示没有丢包时的最大数据传输速率，单位通常是 b/s （ 比特 / 秒 )  或者 B/s ( 字节 / 秒 ) 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;延时&lt;/p&gt;
&lt;p&gt;表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PPS ( Packet Per Second )&lt;br&gt;表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 206. Reverse Linked List</title>
    <link href="http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/"/>
    <id>http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/</id>
    <published>2019-02-26T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:14.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>单链表反转</p><p>题目来源：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/?</p><p>代码效率：100%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>迭代法：将当前节点的后继节点指向前一个节点，移动当前节点</p><p>递归法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nonesense"><a href="#Nonesense" class="headerlink" title="Nonesense"></a>Nonesense</h3><p>最简单的单链表居然花费了我半天的时间，最后还是参考别人的答案才写出来。。。智商捉急</p><p>总结一下问题：</p><ul><li>太急躁，要静下心来慢慢梳理过程，整理成代码输出</li><li><strong>java变量指针等概念感觉还是不清晰</strong>，今天抽空需要补一下</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;单链表反转&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 448 Find All Numbers Disappeared in an Array</title>
    <link href="http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/"/>
    <id>http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/</id>
    <published>2019-02-24T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:03.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：</p><p>题目来源：<a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/N</p><p>代码效率： 95.58%</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>取负法：不管一个元素出现一次还是两次，只要出现它对应的位置就会被取负。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[val] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nums[val] = -nums[val];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>感觉这个题就是单纯考虑数学技巧，做起来比较吃力，看答案的时候豁然开朗，还是慢慢积累吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 283 Move Zeroes</title>
    <link href="http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/"/>
    <id>http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/</id>
    <published>2019-02-23T13:44:24.000Z</published>
    <updated>2019-03-27T03:50:41.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变</p><p>题目来源：<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一个快指针，一个慢指针，快指针指向不为0的元素，快慢指针值交换，同时向后移动一位。这样可以保证下面两个条件：</p><ul><li>快慢指针之间的元素都是0</li><li>慢指针之前的元素都不为0<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>一开始理解错误，以为把0都放到后面之后还是要对前面从大到小进行排序。。。结果想了半天</p><p>以后还是要仔细审题，不要怀疑自己，先用自己的想法暴力实现</p><p>写代码之前可以举个栗子来一步一步推敲，想好边界和规律再写代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 136. Single Number</title>
    <link href="http://yoursite.com/2019/02/22/leetcode-136-single-number/"/>
    <id>http://yoursite.com/2019/02/22/leetcode-136-single-number/</id>
    <published>2019-02-22T13:44:24.000Z</published>
    <updated>2019-03-27T03:42:43.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。</p><p>题目来源：<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用异或 <code>^</code></p><ul><li>两个相同的数异或后为0</li><li>0和一个数异或后为那个数</li><li>异或运算满足交换律</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            result^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 226. Invert Binary Tree</title>
    <link href="http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/"/>
    <id>http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/</id>
    <published>2019-02-21T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:11.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>反转二叉树左右子树</p><p>题目来源：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/ N</p><p>代码效率：100.00%</p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>左子树和右子树递归互换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>对递归还是理解不透彻，总结一下如何处理递归问题：</p><blockquote><p>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;反转二叉树左右子树&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/invert-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/invert-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 104. Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/"/>
    <id>http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/</id>
    <published>2019-02-20T13:44:24.000Z</published>
    <updated>2019-03-27T02:35:02.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>计算二叉树的深度</p><p>题目来源：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：思路很乱，参考 Discuss 的答案</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>递归左右子树，对深度最大的子树进行递归调用并+1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;计算二叉树的深度&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-depth-of-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 617 Merge Two Binary Trees</title>
    <link href="http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/"/>
    <id>http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/</id>
    <published>2019-02-19T13:44:24.000Z</published>
    <updated>2019-03-27T02:38:36.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。</p><p>题目来源：<a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-binary-trees/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/1</p><p>代码效率：98.24%</p><p>耗时：25分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>主要考察对递归算法的理解。</p><ul><li>首先考虑边界，如果两个子二叉树都为空，则新的二叉树必定为空</li><li>考虑其中一个子二叉树为空，则新的二叉树直接等于另外一个子二叉树</li><li>如果两个子二叉树都不为空，新二叉树节点值为两个子二叉树对应节点的值的和，同时对两个子二叉树的左右子树进行递归调用，仔细想想就明白了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode ret;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">            ret.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">            ret.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然别人思路的总是最好的 o(╥﹏╥)o</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    TreeNode result = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    result.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    result.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>学习数据结构的时候，总感觉递归对自己来说是弱项，智商不够用。今天居然一次性直接做出来了。学习数据结构和算法真的能培养思维逻辑和解决问题的能力。fighting !!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-two-binary-trees/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 461 Hamming Distance</title>
    <link href="http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/"/>
    <id>http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/</id>
    <published>2019-02-18T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:58.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>统计两个整数转换成二进制位时位数不同的个数。</p><p>题目来源：<a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/hamming-distance/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/2 (少写了 return 语句。。)</p><p>代码效率：91.77%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>二进制的每一位的值不是 0 就是 1，就是整数除以 2 取余的结果，判断是否相等。然后再取模（相当于向左移动一位），再取余作比较。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span> || y != <span class="number">0</span>)&#123;</span><br><span class="line">            i = x % <span class="number">2</span>;</span><br><span class="line">            j = y % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">            y = y / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人的一行代码实现Orz：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;统计两个整数转换成二进制位时位数不同的个数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/hamming-distance/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 771 Jewels And Stones</title>
    <link href="http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/"/>
    <id>http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/</id>
    <published>2019-02-17T13:44:24.000Z</published>
    <updated>2019-03-27T02:34:44.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。</p><p>题目来源：<a href="https://leetcode.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode.com/problems/jewels-and-stones/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/4</p><p>代码效率：93.10%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>把 J 和S 转换成字符数组，遍历 J 数组中的字符是否等于 S 中的 字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charJ = J.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charS = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> <span class="keyword">var</span> : charJ)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;charS.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">var</span> == charS[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人还有更好的做法：</p><ul><li>遍历 J 把字符放入 set 集合</li><li>遍历 S 字符是否出现在 set 中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Set setJ = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> j: J.toCharArray()) setJ.add(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> s: S.toCharArray()) <span class="keyword">if</span> (setJ.contains(s)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>第一次开始刷 Leetcode ,虽然做的是 easy 的题目，但还是没有参考其他人的答案自己完成了。开始有一点新鲜感和成就感了，希望可以坚持下去。</p><p>刚开始刷题使用的是 VS CODE 码代码，在网上看了一些网友的建议，为了应对后续面试可能要求手写编程的情况，所以现在是先用 IDE 把代码写出来，再手写输入 Leetcode 提交答案。</p><p>加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/jewels-and-stones/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/jewels-and-stones/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Tips</title>
    <link href="http://yoursite.com/2019/02/15/Leetcode-tips/"/>
    <id>http://yoursite.com/2019/02/15/Leetcode-tips/</id>
    <published>2019-02-15T13:44:24.000Z</published>
    <updated>2019-03-26T14:25:07.820Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。</p><p>数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：<br><a id="more"></a></p><ul><li><p>数据结构与算法之美</p><p>极客时间的一个专栏，内容通俗易懂，适合入门</p></li><li><p>数据结构与算法分析：Java语言描述</p><p>下一步打算看的书籍</p></li><li><p>经典大作：算法，算法导论</p></li></ul><p>附数据结构与算法之美推荐书单：<br><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407333793.png" alt></p><h3 id="Leetcode-刷题方法"><a href="#Leetcode-刷题方法" class="headerlink" title="Leetcode 刷题方法"></a>Leetcode 刷题方法</h3><p>在刚开始刷 Leetcode 时，很多人只有在看完答案才知道要怎么做，如果不看答案的话完全没有思路。这是非常正常的现象，并不表示你的思维能力比别人差。人类最擅长的学习方式是模仿，刚开始刷题的时候不会做看看别人怎么做是很正确的做法，模仿多了自然就会做了。</p><p>刷 Leetcode 也有两种流派：龟派和兔派。龟派每道题都要想很久，而且尽可能想出多种解法。兔派是想一会儿就看答案，这样就可以很快地刷题。龟派比较适合思维锻炼，而兔派比较适合短期内快速提高并记忆。如果是为了应对校招的话，比较推荐兔派这种刷题方法，因为校招确实很依赖于短期记忆。选择兔派这种方式的话，就需要反复地进行复习，从而保持记忆并增加理解。但是也不能完全采用兔派这种方法，因为如果习惯于不去思考怎么做的话，会养成惰性的思维方式。</p><p>当你刷题到一定程度的时候，最好每天再刷一两题保持题感。可以选你之前做过的题目，因为你再做一遍的话可以很快做出来，这样子就可以让你对刷题这件事保持积极的一种心态。</p><p>刷 Leetcode 的收益如下图所示，可以看到刷的越多收益增长的越小。刷 200 题就足够应对大多数互联网公司的校招，但是如果时间不够的话刷 100 题也是有很大的收益，可以刷一下 <a href="https://leetcode.com/problemset/top-100-liked-questions/" target="_blank" rel="noopener">Top 100 Liked Questions</a>。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407398105.png" alt></p><ul><li>排序：大部分要求能手写，并分析时间空间复杂度，以及稳定性</li><li>树：红黑树的原理以及在 JDK 的使用；B+ 树以及在数据库索引中的使用</li><li>图：拓扑排序；并查集；最短路径；最小生成树</li><li>散列表：实现原理，以及在 JDK 中的使用</li><li>字符串：KMP；AC 自动机；Trie 树</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。&lt;/p&gt;
&lt;p&gt;数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 20 Summary. Red Black Tree</title>
    <link href="http://yoursite.com/2019/02/13/beauty-of-algorithms-20-summary-red-black-tree/"/>
    <id>http://yoursite.com/2019/02/13/beauty-of-algorithms-20-summary-red-black-tree/</id>
    <published>2019-02-12T16:45:30.000Z</published>
    <updated>2019-03-27T18:17:54.820Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树的数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n,所以它是近似平衡， 插入、删除、查找操作的时间复杂度都是O(logn)。<br><a id="more"></a><br>红黑树非常复杂，无法永久记忆它的平衡调整策略。</p><p>有时间深入了解一下 :)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树的数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n,所以它是近似平衡， 插入、删除、查找操作的时间复杂度都是O(logn)。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Red Black Tree" scheme="http://yoursite.com/tags/Red-Black-Tree/"/>
    
      <category term="红黑树" scheme="http://yoursite.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 19 Summary. Binarytree</title>
    <link href="http://yoursite.com/2019/02/09/beauty-of-algorithms-19-summary-binarytree/"/>
    <id>http://yoursite.com/2019/02/09/beauty-of-algorithms-19-summary-binarytree/</id>
    <published>2019-02-08T16:45:30.000Z</published>
    <updated>2019-03-27T18:15:37.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li><p>节点</p><p>树中的元素称之为节点</p></li><li><p>高度</p><ul><li><p>节点的高度</p><p>节点到叶子节点的最长路径</p></li><li><p>树的高度</p><p>跟节点的高度</p></li></ul></li><li><p>深度</p><p>根节点到这个节点所经历的边的个数</p></li><li><p>层</p><p>节点的深度+1</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797246423.png" alt></p><h3 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h3></li><li><p>满二叉树</p><p>除了叶子结点外每个节点都有左右两个子节点</p></li><li><p>完全二叉树</p><p>叶子结点都在最低下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797311876.png" alt></p><h3 id="表示、存储一棵二叉树"><a href="#表示、存储一棵二叉树" class="headerlink" title="表示、存储一棵二叉树"></a>表示、存储一棵二叉树</h3><p><strong>链式存储法</strong></p><p>每个结点有三个字段，其中一个存储数据，另两个是指向左右子节点的指针。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797363532.png" alt></p><p><strong>顺序存储法(基于数组)</strong></p><p>根节点存储在下标i=1的位置，左子节点存储在下标2<em>i=2的位置，右子节点存储在2</em>i+1=3的位置，以此类推。</p><p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 的位置存储的就是右子节点。<br>我们只要知道根节点存储的位置，这样就可以通过下标计算，把整棵树都串起来。</p><p>为了方便计算子节点，根节点会存储在下标为 1 的位置</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797402073.png" alt></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>前序遍历</p><p>对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p></li><li><p>中序遍历</p><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p></li><li><p>后序遍历</p><p>对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p></li><li><p>层序遍历</p><p>从树的第一层开始从左到右打印节点</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549797580379.png" alt></p><p>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</p><p>比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p><h3 id="二叉树以及二叉树遍历代码实现"><a href="#二叉树以及二叉树遍历代码实现" class="headerlink" title="二叉树以及二叉树遍历代码实现"></a><strong>二叉树以及二叉树遍历代码实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BinaryTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            root.data = data;</span><br><span class="line">            size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            add(root, <span class="keyword">new</span> Node(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node root, Node newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newNode.data &lt; root.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.leftNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.leftNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.leftNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.rightNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.rightNode = newNode;</span><br><span class="line">                size++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add(root.rightNode, newNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHigh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">while</span> (parent.rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = parent.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前序遍历："</span>);</span><br><span class="line">        pre(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            pre(node.leftNode);</span><br><span class="line">            pre(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"中序遍历："</span>);</span><br><span class="line">        in(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            in(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">            in(node.rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后序遍历："</span>);</span><br><span class="line">        post(root);</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            post(node.rightNode);</span><br><span class="line">            post(node.leftNode);</span><br><span class="line">            System.out.print(node.data + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node leftNode;</span><br><span class="line">        <span class="keyword">private</span> Node rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.leftNode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rightNode = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        BinaryTree t = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        t.add(<span class="number">40</span>);</span><br><span class="line">        t.add(<span class="number">25</span>);</span><br><span class="line">        t.add(<span class="number">78</span>);</span><br><span class="line">        t.add(<span class="number">10</span>);</span><br><span class="line">        t.add(<span class="number">32</span>);</span><br><span class="line">        t.add(<span class="number">50</span>);</span><br><span class="line">        t.add(<span class="number">93</span>);</span><br><span class="line">        t.add(<span class="number">3</span>);</span><br><span class="line">        t.add(<span class="number">17</span>);</span><br><span class="line">        t.add(<span class="number">30</span>);</span><br><span class="line">        t.add(<span class="number">38</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t.getLow());</span><br><span class="line">        System.out.println(t.getHigh());</span><br><span class="line">        System.out.println(<span class="string">"Size-"</span> + t.size);</span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">        t.inOrder();</span><br><span class="line">        t.preOrder();</span><br><span class="line">        t.postOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树 Binary Search Tree"></a>二叉查找树 Binary Search Tree</h2><h3 id="二叉查找树的定义"><a href="#二叉查找树的定义" class="headerlink" title="二叉查找树的定义"></a>二叉查找树的定义</h3><p>二叉查找树又称二叉搜索树。其要求在二叉树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树的节点的值都大于这个节点的值。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550049430176.png" alt></p><h3 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h3><p><strong>二叉树类、节点类以及查找方法的代码实现</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064373887.png" alt></p><p>先取根节点，如果它等于我们要查找的数据，那就返回。</p><p>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</p><p>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉查找树的插入操作</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064441773.png" alt></p><p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p><p>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉查找树的删除操作</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550064532346.png" alt></p><p>第一种情况，删除的节点没有子节点直接将其父节点指向置为null。</p><p>第二种情况，删除的节点只有一个子节点，将其父节点指向其子节点。</p><p>第三种情况，删除的节点有两个子节点，首先找到该节点右子树中最小的的节点把他替换掉要删除的节点 然后再删除这个最小的节点，该节点必定没有子节点，否则就不是最小的节点了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 先找到要删除的节点 </span></span><br><span class="line"><span class="comment"> * 2. 如果这个节点有两个叶子节点，找到右子树的最小值，替换当前的这个节点值，同时删除这个最小值 </span></span><br><span class="line"><span class="comment"> * 3.如果这个节点只有一个叶子节点，用叶子节点的值替换当前节点的值 </span></span><br><span class="line"><span class="comment"> * 4. 如果这个节点没有叶子节点，直接删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = root;</span><br><span class="line">    Node pp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; p.data) &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node minP = p;</span><br><span class="line">        Node minPP = pp;</span><br><span class="line">        <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p.data = minP.data;</span><br><span class="line">        p = minP;</span><br><span class="line">        pp = minpp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node child;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">        pp.left = child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pp.right = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。</p><p>这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><h3 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a><strong>二叉查找树的其他操作</strong></h3><p>二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。</p><p>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</p><h3 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h3><p>前面的二叉查找树的操作，我们默认树中节点存储的都是数字，针对的都是不存在键值相同的情况。</p><p>我们可以通过两种办法来构建支持重复数据的二叉查找树。</p><ul><li><p>第一种方法</p><p>二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p></li><li><p>第二种方法</p><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p><p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p></li></ul><h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p><strong>最坏、最好情况</strong></p><p>如果根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p><p>最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。而完全二叉树的高度小于等于 log2n。</p><p><strong>平衡二叉查找树</strong></p><p>我们需要构建一种不管怎么删除、插入数据，在任何时候都能保持任意节点左右子树都比较平衡的二叉查找树，这就是一种特殊的二叉查找树，平衡二叉查找树。</p><p>平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)。</p><h3 id="二叉查找树相比散列表的优势"><a href="#二叉查找树相比散列表的优势" class="headerlink" title="二叉查找树相比散列表的优势"></a>二叉查找树相比散列表的优势</h3><p><strong>散列表中的数据是无序存储的</strong></p><p>如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</p><p><strong>散列表扩容耗时很多</strong></p><p>而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p><p><strong>散列表存在哈希冲突</strong></p><p>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。</p><p>加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p><strong>散列表装载因子不能太大</strong></p><p>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h2&gt;&lt;h3 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h3&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="BinaryTree" scheme="http://yoursite.com/tags/BinaryTree/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 18 Summary. Hash</title>
    <link href="http://yoursite.com/2019/02/08/beauty-of-algorithms-18-summary-hash/"/>
    <id>http://yoursite.com/2019/02/08/beauty-of-algorithms-18-summary-hash/</id>
    <published>2019-02-07T16:45:30.000Z</published>
    <updated>2019-03-27T18:09:42.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="哈希算法的定义和原理"><a href="#哈希算法的定义和原理" class="headerlink" title="哈希算法的定义和原理"></a>哈希算法的定义和原理</h3><p>将任意长度的二进制串映射为固定长度的二进制串。</p><p>这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值。</p><p>设计一个优秀的哈希算法需要满足：</p><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值<a id="more"></a></li></ul><h4 id="MD5哈希算法"><a href="#MD5哈希算法" class="headerlink" title="MD5哈希算法"></a>MD5哈希算法</h4><p>MD5的哈希值是128位的bit长度，为了方便转换成了16进制编码。</p><p>可以看出无论哈希值文本有多长多短，通过MD5哈希之后，得到的哈希值的长度都是一样的，</p><p>而且得到的哈希值看起来像一堆随机数完全没有规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(&quot; 今天我来讲哈希算法 &quot;) = bb4767201ad42c74e650c1b6c03d78fa</span><br><span class="line">MD5(&quot;jiajia&quot;) = cd611a31ea969b908932d44d126d195b</span><br></pre></td></tr></table></figure><h3 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h3><h4 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a><strong>安全加密</strong></h4><p><strong>加密算法</strong></p><p>最常用于加密的哈希算法是MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和SHA（Secure Hash Algorithm，安全散列算法）。</p><p>对用于加密的哈希算法来说，有两点格外重要：</p><ul><li>很难根据哈希值反向推导出原始数据</li><li>散列冲突的概率要很小</li></ul><p>实际上，不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。</p><p><strong>鸽巢理论</strong></p><p>这里就基于组合数学中一个非常基础的理论，鸽巢原理（也叫抽屉原理）。</p><p>这个原理本身很简单，它是说如果有 10 个鸽巢，有 11 只鸽子那肯定有 1 个鸽巢中的鸽子数量多于 1 个。</p><p>换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p><p>我们知道，哈希算法产生的哈希值的长度是固定且有限的。</p><p>哈希值是固定的 128 位二进制串，能表示的数据是有限的最多能表示 2^128 个数据。</p><p>基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。</p><h4 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a><strong>唯一标识</strong></h4><p><strong>在图库中搜索图片</strong></p><p>如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对。</p><p>因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。</p><p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。</p><p>比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节。</p><p>然后将这 300 个字节放到一块，通过哈希算法（比如 MD5)得到一个哈希字符串，用它作为图片的唯一标识。</p><p>通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量</p><p><strong>性能提升</strong><br>如果还想继续提高效率，我们可以把每个图片的唯一标识和相应的图片文件在图库中的路径信息，都存储在散列表中。</p><p>当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p><h4 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a><strong>数据校验</strong></h4><p><strong>P2P文件快校验</strong></p><p>BT 下载的原理是基于 P2P 协议的。</p><p>我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成100 块，每块大约 20MB）。</p><p>等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p><p>网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。</p><p><strong>解决方法</strong></p><p>我们通过哈希算法，对 100 个文件块分别取哈希值并且保存在种子文件中。</p><p>当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。</p><p>如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a><strong>散列函数</strong></h4><p><strong>散列函数是一种哈希算法</strong></p><p>实际上，散列函数也是哈希算法的一种应用。</p><p>散列函数是设计一个散列表的关键。</p><p>它直接决定了散列冲突的概率和散列表的性能。</p><p>不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。</p><p>即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p><p><strong>散列函数追求平均分布</strong></p><p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。</p><p>散列函数中用到的散列算法，更加关注散列后的值是否能平均分布。</p><p>也就是一组数据是否能均匀地散列在各个槽中。</p><p>除此之外，散列函数执行的快慢，也会影响散列表的性能，</p><p>所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h4><p>我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p><p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。</p><p>客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p><ul><li>如果客户端很多，映射表可能会很大，比较浪费内存空间</li><li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大</li></ul><p>如果借助哈希算法，这些问题都可以非常完美地解决。</p><p>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</p><p>这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a><strong>数据分片</strong></h4><p><strong>统计“搜索关键词”出现的次数</strong></p><p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，</p><p>我们想要快速统计出每个关键词被搜索的次数。</p><p>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p><p>为了提高处理的速度，我们用 n 台机器并行处理。</p><p>我们从搜索记录的日志文件中，依次读出每个搜索关键词，</p><p>并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p><p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。</p><p>也就是说，同一个搜索关键词会被分配到同一个机器上。</p><p>每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p><p><strong>快速判断图片是否在图库中</strong></p><p>假设现在我们的图库中有 1 亿张图片，在单台机器上构建散列表是行不通的。</p><p>我们同样可以对数据进行分片，然后采用多机处理。</p><p>我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。</p><p>我们每次从图库中读取一个图片，计算唯一标识，</p><p>然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，</p><p>然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p><p>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，</p><p>计算这个图片的唯一标识，然后与机器个数 n 求余取模。</p><p>假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p><h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a><strong>分布式存储</strong></h4><p>我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。</p><p>我们需要将数据分布在多台机器上通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号</p><p>如果数据增多，原来的 10 个机器已经无法承受，我们需要扩容，假如扩到 11 个机器。</p><p>原来的数据是通过与 10 来取模的，比如 13 这个数据，存储在编号为 3 这台机器上。</p><p>新加了一台机器后，我们对数据按照 11 取模，原来 13 这个数据被分配到了 2 号这台机器上。</p><p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。</p><p>所有的数据请求都会穿透缓存，直接去请求数据库，可能会发生雪崩效应，压垮数据库。</p><p>我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。</p><p>这时候，一致性哈希算法就要登场了。</p><p><strong>一致性哈希算法</strong></p><p><a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">参考</a></p><p>假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。</p><p>我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。</p><p>当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。</p><p>这样既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;哈希算法的定义和原理&quot;&gt;&lt;a href=&quot;#哈希算法的定义和原理&quot; class=&quot;headerlink&quot; title=&quot;哈希算法的定义和原理&quot;&gt;&lt;/a&gt;哈希算法的定义和原理&lt;/h3&gt;&lt;p&gt;将任意长度的二进制串映射为固定长度的二进制串。&lt;/p&gt;
&lt;p&gt;这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制串就是哈希值。&lt;/p&gt;
&lt;p&gt;设计一个优秀的哈希算法需要满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）&lt;/li&gt;
&lt;li&gt;对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同&lt;/li&gt;
&lt;li&gt;散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小&lt;/li&gt;
&lt;li&gt;哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
      <category term="哈希算法" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 17 Summary. HashTable</title>
    <link href="http://yoursite.com/2019/02/07/beauty-of-algorithms-17-summary-hash-table/"/>
    <id>http://yoursite.com/2019/02/07/beauty-of-algorithms-17-summary-hash-table/</id>
    <published>2019-02-06T16:45:30.000Z</published>
    <updated>2019-03-27T18:09:07.069Z</updated>
    
    <content type="html"><![CDATA[<p>散列表Hash Table来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。</p><p>需要存储在散列表中的数据我们称为键key，将键转化为数组下标的方法hash(key)称为散列函数，散列函数的计算结果称为散列值。</p><p>将数据存储在散列值对应的数组下标位置。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549419113789.png" alt><br><a id="more"></a></p><h3 id="设计散列函数"><a href="#设计散列函数" class="headerlink" title="设计散列函数"></a>设计散列函数</h3><p><strong>设计散列函数的基本要求</strong></p><p>散列函数计算得到的散列值是一个非负整数。</p><p>若key1=key2，则hash(key1)=hash(key2)。</p><p>若key≠key2，则hash(key1)≠hash(key2)。</p><p>当空闲位置越来越少，散列值冲突的概率越来越大，也就无法满足第三条。</p><h3 id="散列冲突的解决方法"><a href="#散列冲突的解决方法" class="headerlink" title="散列冲突的解决方法"></a>散列冲突的解决方法</h3><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a><strong>开放寻址法</strong></h4><ul><li><p><strong>线性探测</strong></p><p>开放寻址法会导致占用删除元素的位置，这样会导致原来的算法失效。</p><p>所以线性探测法的删除操作是将要删除的元素标记为deleted，当要插入数据时遇到这种位置就继续向下探测。</p></li><li><p><strong>二次探测</strong></p><p>线性探测法每次探测的步长为1，即在数组中一个一个探测，比如hash(key)+1,hash(key)+2…</p><p>而二次探测的步长变为原来的平方hash(key)+1^2,hash(key)+2^2…</p></li><li><p><strong>双重散列</strong></p><p>使用一组散列函数，先使用第一个，如果有冲突就换下一个，直到找到空闲位置为止。</p></li></ul><p><strong>性能描述</strong></p><p>我们使用装载因子来表示空位多少：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子 = 填入表中的元素个数 / 散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><ul><li><p><strong>插入数据</strong></p><p>当插入的时候，我们需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，所以插入的时间复杂度为O(1)</p></li><li><p><strong>查找或删除数据</strong></p><p>对于散列比较均匀的散列函数，链表的节点个数k=n/m，其中n表示散列表中数据的个数，m表示散列表中槽的个数。当查找、删除一个元素时，通过散列函数计算对应的槽，然后遍历链表查找或删除，两操作与链表长度k成正比，即时间复杂度为O(k)。</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549419411662.png" alt></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>假设我们有10万条URL访问日志，如何按照访问次数给URL排序</strong></p><p>遍历 10 万条日志，将 URL 做为 KEY ，声明一个访问次数 count 作为散列表值，存入散列表，每次遇到重复的 count++ ,然后对散列表值进行桶排序或者快速排序。</p><p><strong>有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串</strong></p><p>将其中一个数组以字符串为 KEY， 默认值 value 为 0 存入散列表。然后用第二个数组的元素为 KEY 遍历这个散列表，如果找到相同的KEY ，那么 value  +1 ，最后统计 value&gt;0 的所有 KEY.</p><h2 id="散列表碰撞攻击"><a href="#散列表碰撞攻击" class="headerlink" title="散列表碰撞攻击"></a>散列表碰撞攻击</h2><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。</p><p>如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p><h3 id="散列函数的设计"><a href="#散列函数的设计" class="headerlink" title="散列函数的设计"></a>散列函数的设计</h3><ul><li>散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能</li><li>散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况</li><li>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。</li><li>散列函数的设计方法有很多：数据分析法、直接寻址法、平方取中法、折叠法、随机数等等</li></ul><p><strong>装载因子</strong></p><p>装载因子越大，散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。</p><p>插入数据的过程要多次寻址或者拉很长的链，查找的过程也会变得很慢。</p><p>动态散列表的数据集合是频繁变动的，我们事先无法预估数据个数，无法事先申请一个足够大的散列表。</p><p>数据慢慢加入，装载因子就会慢慢变大，当装载因子大到一定程度之后，散列冲突变得不可接受。</p><p>当装载因子过大时，我们可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。</p><p>假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，扩容之后新散列表的装载因子就下降为原来的一半变成了 0.4。</p><p><strong>避免低效地扩容</strong></p><p>当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。</p><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。</p><p>当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。</p><p>每次插入一个数据到散列表，我们都重复上面的过程。</p><p>经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。</p><p>对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><h3 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h3><p><strong>开放寻址法</strong></p><ul><li>优点<ul><li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li><li>种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易</li></ul></li><li>缺点<ul><li>在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高</li><li>使用开放寻址法解决冲突的散列表，装载因子的上限不能太大</li><li>这种方法比链表法更浪费内存空间</li></ul></li></ul><p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</p><p>这也是 Java 中的 <code>ThreadLocalMap</code> 使用开放寻址法解决散列冲突的原因。</p><p><strong>链表法</strong></p><ul><li>优点<ul><li>链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</li><li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多</li></ul></li><li>缺点<ul><li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍</li><li>而且，因为链表中的结点是零散分布在内存中的，不是连续的。所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响</li></ul></li></ul><p>当如果我们存储的是大对象，即存储的对象的大小远远大于一个指针的大小。那么链表中指针的内存消耗在大对象面前就可以忽略了。</p><p>链表法比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p><h3 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a><strong>工业级散列表举例分析</strong></h3><p><strong>初始大小</strong></p><p><code>HashMap</code> 默认的初始大小是 16，这个默认值是可以设置的。可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 <code>HashMap</code> 的性能。</p><p><strong>装载因子和动态扩容</strong></p><p>最大装载因子默认是 <code>0.75</code>，当 <code>HashMap</code> 中元素个数超过 <code>0.75*capacity</code>（<code>capacity</code> 表示散列的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><p><strong>散列冲突解决方法</strong></p><p><code>HashMap</code> 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 <code>HashMap</code> 的性能。</p><p>于是，在 <code>JDK1.8</code> 版本中，为了对 <code>HashMap</code> 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。</p><p><strong>散列函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>); <span class="comment">//capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashCode()</code> 返回的是 Java 对象的 <code>hash code</code>。</p><p>比如 String 类型的对象的 hashCode() 就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hash = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>如何设计的一个工业级的散列函数？</strong></p></blockquote><p><strong>如果这是一道面试题或者是摆在你面前的实际开发问题，从哪几个方面思考呢</strong></p><p>结合已经学习过的散列知识，我觉得应该有这样几点要求：</p><ul><li>支持快速的查询、插入、删除操作</li><li>内存占用合理，不能浪费过多的内存空间</li><li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况</li></ul><p>如何实现这样一个散列表呢？根据前面讲到的知识从这三个方面来考虑设计思路</p><ul><li>设计一个合适的散列函数</li><li>定义装载因子阈值，并且设计动态扩容策略</li><li>选择合适的散列冲突解决方法</li></ul><h2 id="散列表和链表组合使用"><a href="#散列表和链表组合使用" class="headerlink" title="散列表和链表组合使用"></a>散列表和链表组合使用</h2><h3 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h3><p>借助散列表，我们可以把LRU缓存淘汰算法的时间复杂度降为O(1)。</p><p>一个缓冲cache系统主要包含以下操作</p><ul><li>往缓存中添加一个数据</li><li>从缓存中删除一个数据</li><li>在缓存中查找一个数据</li></ul><p>单纯采用链表，时间复杂度只能是O(n)。</p><p>将散列表和双向链表结合，就可以降为O(1)，其结构如下图所示：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549420745673.png" alt></p><p>其中，我们使用双向链表存储数据，<code>data</code>存储数据，<code>prev</code>前驱指针，<code>next</code>后继指针。</p><p>此外，新增加了<code>hnext</code>指针，这个指针就是链表法散列表中的拉链的后继指针。</p><h3 id="如何做到O-1"><a href="#如何做到O-1" class="headerlink" title="如何做到O(1)"></a>如何做到O(1)</h3><ul><li><p><strong>查找</strong></p><p>因为是散列表所以查找一个数据的操作时间复杂度就接近于O(1)</p></li><li><p><strong>删除</strong></p><p>删除一个数据，我们借助散列表再O(1)的时间复杂度里找到该结点，而双向链表有前驱指针，可以直接删除该节点，时间复杂度为O(1)</p></li><li><p><strong>添加</strong></p><p>添加一个数据比较复杂，首先要看其是否已经在缓存中，如果在就将其移动到双向链表的尾部，如果不在就检查缓存满了没，满了就删除双向链表的头结点，再将数据放到双向链表的尾部，如果没有满就直接将数据放大双向链表的尾部</p></li></ul><p>以上操作中，设计查找的操作是散列表完成的，删除节点、插入节点是双向链表完成的，所以时间复杂度是O(1)。</p><h3 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h3><p>在有序集合中，每个成员对象有两个重要的属性，键<code>key</code>和分值<code>score</code>。</p><p>我们不仅需要key来查找数据，还会需要用score查找数据。</p><p>细化一下Redis有序集合的操作：</p><ul><li>添加一个成员对象</li><li>按照键值来删除一个成员对象</li><li>按照键值来查找一个成员对象</li><li>按照分值区间查找数据，比如查找积分在[100, 356] 之间的成员对象</li><li>按照分值从小到大排序成员变量</li></ul><p>如果只按照分支将成员对象组织成跳表的结构，那么按照键值删除、查询对象就会很慢。</p><p>我们可以按照键值构建一个散列表，这样按照key来删除、查找一个对象的时间复杂度就都变成了O(1)。</p><h3 id="Java中的LinkedHashMap"><a href="#Java中的LinkedHashMap" class="headerlink" title="Java中的LinkedHashMap"></a>Java中的LinkedHashMap</h3><p>Java 中的<code>LinkedHashMap</code>中的<code>Linked</code>并不是链表法表示散列表的意思，而是双向链表和散列表结合。</p><p><code>LinkedHashMap</code>本身就是一个支持LRU缓存淘汰策略的缓存系统，其数据的存取移动删除规则和LRU一样。</p><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p><strong>今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？</strong></p><p>不能，影响查询性能</p><p><strong>假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。</strong></p><p><strong>假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</strong></p><ul><li><p>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息</p><p>ID 为 KEY，散列表可以实现快速查询，链表法可以实现删除更新。</p></li><li><p>查找积分在某个区间的猎头 ID 列表</p><p>遍历散列表查询积分对应的 ID 列表</p></li><li><p>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 …</p><p>遍历散列表</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;散列表Hash Table来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。&lt;/p&gt;
&lt;p&gt;需要存储在散列表中的数据我们称为键key，将键转化为数组下标的方法hash(key)称为散列函数，散列函数的计算结果称为散列值。&lt;/p&gt;
&lt;p&gt;将数据存储在散列值对应的数组下标位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549419113789.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="散列表" scheme="http://yoursite.com/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 16 Summary. Skiplist</title>
    <link href="http://yoursite.com/2019/02/06/beauty-of-algorithms-16-summary-skiplist/"/>
    <id>http://yoursite.com/2019/02/06/beauty-of-algorithms-16-summary-skiplist/</id>
    <published>2019-02-05T16:45:30.000Z</published>
    <updated>2019-03-27T18:00:53.694Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跳表的概念"><a href="#跳表的概念" class="headerlink" title="跳表的概念"></a>跳表的概念</h3><p>对链表建立n级索引，例如每两个结点提取一个节点到上一层，称之为索引层。<br>图中的down表示down指针，指向下一级结点</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549354564189.png" alt><br><a id="more"></a></p><h3 id="跳表的时间复杂度"><a href="#跳表的时间复杂度" class="headerlink" title="跳表的时间复杂度"></a>跳表的时间复杂度</h3><p><strong>跳表的高度</strong></p><p>跳表的高度是log2n</p><p><strong>跳表的时间复杂度</strong></p><p>跳表中查询某个数据的时间复杂度是O(logn)</p><h3 id="跳表的空间复杂度及优化"><a href="#跳表的空间复杂度及优化" class="headerlink" title="跳表的空间复杂度及优化"></a><strong>跳表的空间复杂度及优化</strong></h3><p><strong>跳表的空间复杂度</strong></p><p>跳表的空间复杂度为O(n)</p><p><strong>优化时间复杂度</strong></p><p>如果链表有n个节点，每3或5个节点抽取抽出一个节点作为上一级索引的节点，</p><p>虽然跳表的空间复杂度仍然是O(n)，但和每2个节点抽取一次相比占用的内存空间少了很多。</p><h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p><strong>时间复杂度</strong></p><p>跳表本质上就是链表，所以仅插作，插入和删除操时间复杂度就为O(1)，</p><p>但在实际情况中，要插入或删除某个节点，需要先查找到指定位置，而这个查找操作比较费时。</p><p>在跳表中查找操作的时间复杂度是O(logn)，因此跳表的插入和删除操作的是时间复杂度也是O(logn)。</p><p><strong>跳表索引动态更新</strong></p><p>当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中，</p><p>可以通过随机函数来决定将这个节点插入到哪几级索引中，比如随机函数生成了值K，那就可以把这个节点添加到第1级到第K级索引中。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549354676649.png" alt></p><h3 id="跳表代码实现"><a href="#跳表代码实现" class="headerlink" title="跳表代码实现"></a>跳表代码实现</h3><p><a href="https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;跳表的概念&quot;&gt;&lt;a href=&quot;#跳表的概念&quot; class=&quot;headerlink&quot; title=&quot;跳表的概念&quot;&gt;&lt;/a&gt;跳表的概念&lt;/h3&gt;&lt;p&gt;对链表建立n级索引，例如每两个结点提取一个节点到上一层，称之为索引层。&lt;br&gt;图中的down表示down指针，指向下一级结点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549354564189.png&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="SkipList" scheme="http://yoursite.com/tags/SkipList/"/>
    
      <category term="跳表" scheme="http://yoursite.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 15 Summary. BinarySearch</title>
    <link href="http://yoursite.com/2019/02/05/beauty-of-algorithms-15-summary-binary-search/"/>
    <id>http://yoursite.com/2019/02/05/beauty-of-algorithms-15-summary-binary-search/</id>
    <published>2019-02-04T16:45:30.000Z</published>
    <updated>2019-03-27T18:00:44.376Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。</p><p><strong>时间复杂度</strong>是O(logn)<br><a id="more"></a></p><h3 id="二分查找实现"><a href="#二分查找实现" class="headerlink" title="二分查找实现"></a>二分查找实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; value) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        BinarySearch binarySearch = <span class="keyword">new</span> BinarySearch(array);</span><br><span class="line">        System.out.println(binarySearch.binarySearch(<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>循环退出条件是：<code>start&lt;=end</code>，而不是start&lt;end。</p><p>mid的取值可以优化，如使用<code>mid=start + (end - start) / 2</code>，而不用<code>mid=(start + end)/2</code>，因为如果start和end比较大的话，求和可能会发生int类型的值超出最大范围。</p><p>为了把性能优化到极致，可以将除以2转换成位运算，即start + ((end - start) &gt;&gt; 1)，相比除法运算来说，计算机处理位运算要快得多。</p><p>start和end的更新：start = mid - 1，end = mid + 1，若直接写成start = mid，end=mid，就可能会发生死循环。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>二分查找依赖的是顺序表结构，即数组</li><li>二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中</li><li>数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧</li><li>数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间</li></ul><h3 id="四种常见的二分查找变形问题"><a href="#四种常见的二分查找变形问题" class="headerlink" title="四种常见的二分查找变形问题"></a>四种常见的二分查找变形问题</h3><p><strong>查找第一个值等于给定值的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] &gt; value)&#123;</span><br><span class="line">            hi = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (array[mid]&lt;value)&#123;</span><br><span class="line">            lo = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || array[mid -<span class="number">1</span>]!= value)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找最后一个值等于给定值的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch3</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] &gt; value) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; value) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == array.length - <span class="number">1</span> || array[mid + <span class="number">1</span>] != value) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找第一个大于等于给定值的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] &gt;= value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || array[mid - <span class="number">1</span>] &lt; value) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找最后一个小于等于给定值的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch5</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] &lt;= value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == (array.length - <span class="number">1</span>) || array[mid + <span class="number">1</span>] &gt; value) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="适用性分析"><a href="#适用性分析" class="headerlink" title="适用性分析"></a>适用性分析</h3><p>凡是能用二分查找解决的，绝大部分我们更倾向于用散列表或者二叉查找树，</p><p>即便二分查找在内存上更节省，但是毕竟内存如此紧缺的情况并不多。</p><p>求“值等于给定值”的二分查找确实不怎么用到，二分查找更适合用在”近似“查找问题上。比如上面讲几种变体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找针对的是一个有序的数据集合，每次通过跟区间中间的元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间缩小为0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;是O(logn)&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="BinarySearch" scheme="http://yoursite.com/tags/BinarySearch/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 14 Summary. Sorting Enhancement</title>
    <link href="http://yoursite.com/2019/02/04/beauty-of-algorithms-14-summary-sorting-enhancement/"/>
    <id>http://yoursite.com/2019/02/04/beauty-of-algorithms-14-summary-sorting-enhancement/</id>
    <published>2019-02-03T16:45:30.000Z</published>
    <updated>2019-03-27T17:55:09.198Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法的选择与优化<br><a id="more"></a></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549177800363.png" alt></p><h3 id="选择排序算法的原则"><a href="#选择排序算法的原则" class="headerlink" title="选择排序算法的原则"></a>选择排序算法的原则</h3><ul><li>线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序</li><li>为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数</li><li>同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排</li></ul><h3 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h3><p>导致快排时间复杂度降为O(n^2)的原因是分区点选择不合理，最理想的分区点是：</p><p><strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p><p>优化分区点有2种常用方法：</p><ul><li><p><strong>三数取中法</strong></p><p>从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点</p><p>如果要排序的数组比较大，那三数取中可能就不够用了，可能要五数取中或者十数取中</p></li><li><p><strong>随机法</strong></p><p>每次从要排序的区间中，随机选择一个元素作为分区点</p></li><li><p><strong>递归发生堆栈溢出的解决方法</strong></p><p>限制递归深度，一旦递归超过了设置的阈值就停止递归</p><p>在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制</p></li></ul><h3 id="通用排序函数实现技巧"><a href="#通用排序函数实现技巧" class="headerlink" title="通用排序函数实现技巧"></a>通用排序函数实现技巧</h3><ul><li>数据量不大时，可以采取用空间换时间的思路</li><li>数据量大时，优化快排分区点的选择</li><li>防止堆栈溢出，可以选择在堆上手动模拟调用栈解决</li><li>在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序</li><li>用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法的选择与优化&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 13 Summary. Linear Sorting</title>
    <link href="http://yoursite.com/2019/02/03/beauty-of-algorithms-13-summary-linear-sorting/"/>
    <id>http://yoursite.com/2019/02/03/beauty-of-algorithms-13-summary-linear-sorting/</id>
    <published>2019-02-02T16:45:30.000Z</published>
    <updated>2019-03-27T16:55:56.777Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线性排序的概念</strong></p><p>线性排序算法包括桶排序、计数排序、基数排序。</p><p>线性排序算法的时间复杂度为O(n)。<br><a id="more"></a><br><strong>线性排序的特点</strong></p><p>此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。</p><p>对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。</p><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p><strong>算法原理</strong></p><ul><li>将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序</li><li>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176304232.png" alt></p><p><strong>使用条件</strong></p><ul><li>要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序</li><li>数据在各个桶之间分布是均匀的</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序 </span></span><br><span class="line"><span class="comment"> * BucketSort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buckets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">//声明成绩在1-10范围的10个桶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> range,<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buckets = <span class="keyword">new</span> <span class="keyword">int</span>[range];</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array!=<span class="keyword">null</span> &amp;&amp; array.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                buckets[array[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buckets[i]; j++) &#123;</span><br><span class="line">                System.out.print(i +<span class="string">" \t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        BucketSort bucketSort = <span class="keyword">new</span> BucketSort(<span class="number">10</span>, array);</span><br><span class="line">        bucketSort.sort()</span><br><span class="line">        bucketSort.sortOut();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>适用场景</strong></p><ul><li>桶排序比较适合用在外部排序中</li><li>外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中</li></ul><h5 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h5><ul><li><p>需求描述</p><p>有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序，但内存有限，仅几百MB</p></li><li><p>解决思路</p><ul><li>扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶</li><li>第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推</li><li>每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）</li><li>将100个小文件依次放入内存并用快排排序</li><li>所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可</li></ul></li><li><p>若单个文件无法全部载入内存，则针对该文件继续细分数据过多的部分，按照前面的思路进行处理</p></li></ul><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><strong>算法原理</strong></p><ul><li>计数其实就是桶排序的一种特殊情况</li><li>当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶</li><li>每个桶内的数据值都是相同的，就省掉了桶内排序的时间</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组 c，下标大小 [0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 c 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 临时数组 r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 将结果拷贝给 a 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>案例分析</strong></p><p>假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。</p><p>使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176782867.png" alt></p><p>C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。</p><p>对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176821302.png" alt></p><p>数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176877893.png" alt></p><p>从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。</p><p>当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。</p><p>以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176950926.png" alt></p><p><strong>使用条件</strong></p><ul><li>只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序</li><li>计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数</li><li>比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数</li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><strong>算法原理</strong></p><p>以排序10万个手机号为例来说明</p><ul><li>比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序</li><li>经过11次排序后，手机号码就变为有序的了</li><li>每次排序有序数据范围较小，可以使用桶排序或计数排序来完成</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549177032618.png" alt></p><p><strong>使用条件</strong></p><ul><li>要求数据可以分割独立的“位”来比较</li><li>位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了</li><li>每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线性排序的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线性排序算法包括桶排序、计数排序、基数排序。&lt;/p&gt;
&lt;p&gt;线性排序算法的时间复杂度为O(n)。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LinearSorting" scheme="http://yoursite.com/tags/LinearSorting/"/>
    
      <category term="线性排序" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 12 Summary. Sorting 2</title>
    <link href="http://yoursite.com/2019/02/02/beauty-of-algorithms-12-summary-sorting-2/"/>
    <id>http://yoursite.com/2019/02/02/beauty-of-algorithms-12-summary-sorting-2/</id>
    <published>2019-02-01T16:45:30.000Z</published>
    <updated>2019-03-27T16:49:05.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h3><p>分治，顾明思意就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。</p><p><strong>分治与递归的区别</strong></p><p>分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。<br><a id="more"></a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><strong>算法原理</strong></h4><p><strong>归并的思想</strong></p><p>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。</p><p>这就是归并排序的核心思想。如何用递归实现归并排序呢？</p><p>写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549120088746.png" alt></p><p><strong>递推公式</strong></p><p>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</p><p><strong>终止条件</strong></p><p>p = r 不用再继续分解</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>使用哨兵可以简化代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">            merge(a, begin, mid);</span><br><span class="line">            merge(a, mid + <span class="number">1</span>, end);</span><br><span class="line">            mergeAndSort(a, begin, mid, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeAndSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[mid - begin + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[end - mid + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">                left[i - begin] = a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right[i - mid - <span class="number">1</span>] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left[mid - begin + <span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        right[end - mid] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = begin;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= end) &#123;</span><br><span class="line">            a[index++] = left[i] &lt; right[j] ? left[i++] : right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">24</span>&#125;;</span><br><span class="line">        merge(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="comment">//打印结果为：[1, 3, 4, 5, 6, 7, 8, 9, 11, 24]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>算法稳定性</strong></p><p>归并排序是一种稳定排序算法。</p><p><strong>时间复杂度</strong></p><p>归并排序的时间复杂度是O(nlogn)。</p><p><strong>空间复杂度</strong></p><p>归并排序算法不是原地排序算法，空间复杂度是O(n)</p><p>因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>一般情况下，快速排序被认为是最快的排序算法（人如其名啊），因此可以说是最常用的排序算法，并受大多数公司的青睐，是一定要熟练掌握的。</p><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><p><strong>快排的思想</strong></p><p>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。</p><p>经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。</p><p>根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549121842206.png" alt></p><p><strong>递推公式</strong></p><p>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</p><p><strong>终止条件</strong></p><p>p &gt;= r</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>左右两个指针分别向左向右移动，取最后一位做临界值，左边遇到比这个值大的，就交换，换反方向指针比较，遇到比这个值小的，再次交换。</p><p><a href="https://huntfor.iteye.com/blog/2026625" target="_blank" rel="noopener">参考这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= begin) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = begin;</span><br><span class="line">        <span class="keyword">int</span> j = end;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[end];</span><br><span class="line">        <span class="keyword">boolean</span> tag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &lt;= tmp) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[j] = a[i];</span><br><span class="line">                    j--;</span><br><span class="line">                    tag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt;= tmp) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    i++;</span><br><span class="line">                    tag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = tmp;</span><br><span class="line">        quickSort(a, begin, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">125</span>, <span class="number">6</span>, <span class="number">41</span>, <span class="number">341</span>, <span class="number">34</span>, <span class="number">63</span>, <span class="number">28</span>, <span class="number">97</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>算法稳定性</strong></p><p>快速排序是不稳定的排序算法。</p><p><strong>时间复杂度</strong></p><p>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，</p><p>那快排的时间复杂度递推求解公式跟归并的相同。快排的时间复杂度也是O(nlogn)。</p><p>如果数组中的元素原来已经有序了，快排的时间复杂度就是O(n^2)。</p><p>前面两种情况，一个是分区及其均衡，一个是分区极不均衡，</p><p>它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。</p><p>T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)。</p><p><strong>空间复杂度</strong></p><p>快排是一种原地排序算法，空间复杂度是O(1)</p><h3 id="归并排序与快速排序的区别"><a href="#归并排序与快速排序的区别" class="headerlink" title="归并排序与快速排序的区别"></a>归并排序与快速排序的区别</h3><p><strong>归并排序</strong></p><p>先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。</p><p>何为自下而上？就是先解决子问题，再解决父问题。</p><p><strong>快速排序</strong></p><p>先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。</p><p>何为自上而下？就是先解决父问题，再解决子问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分治思想&quot;&gt;&lt;a href=&quot;#分治思想&quot; class=&quot;headerlink&quot; title=&quot;分治思想&quot;&gt;&lt;/a&gt;分治思想&lt;/h3&gt;&lt;p&gt;分治，顾明思意就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分治与递归的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="MergeSorting" scheme="http://yoursite.com/tags/MergeSorting/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
