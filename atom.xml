<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shinhwa&#39;s Site</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T16:13:33.950Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shinhwa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes On Network</title>
    <link href="http://yoursite.com/2019/02/27/notes-on-network/"/>
    <id>http://yoursite.com/2019/02/27/notes-on-network/</id>
    <published>2019-02-27T13:44:24.000Z</published>
    <updated>2019-03-27T16:13:33.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h3><ul><li><p>带宽</p><p>表示链路的最大传输速率，单位是 b/s （ 比特 / 秒 ) 。常见的带宽有 1000M、10G、40G、100G 等。</p></li><li><p>吞吐量</p><p>表示没有丢包时的最大数据传输速率，单位通常是 b/s （ 比特 / 秒 )  或者 B/s ( 字节 / 秒 ) 。</p></li><li><p>延时</p><p>表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。</p></li><li><p>PPS ( Packet Per Second )<br>表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力。</p><a id="more"></a></li></ul><h3 id="tcpdump-和-Wireshark"><a href="#tcpdump-和-Wireshark" class="headerlink" title="tcpdump 和 Wireshark"></a>tcpdump 和 Wireshark</h3><p>这个例子只是执行 ping 指令的一个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn udp port 53 or host x.x.x.x -w ping.pcap</span><br></pre></td></tr></table></figure><ul><li>-nn 不解析抓包中的域名（不反向解析）、协议以及端口号</li><li>udp port 53 只显示 UDP 协议的端口号（包括源端口和目的端口）为 53 的包</li><li>host x.x.x.x 只显示 IP 地址（包括原地址和目的地址）为 x.x.x.x 的包</li><li>or 或的关系</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900591970.png" alt></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552900605148.png" alt></p><p>HTTP 的一个例子，便于理解 TCP 三次握手和四次挥手</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn host example.com -w web.pcap</span><br><span class="line">curl example.com</span><br></pre></td></tr></table></figure><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901484205.png" alt></p><p>可以看到TCP 三次握手和四次挥手的请求</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901518443.png" alt></p><p>顺便复习一下流程：</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1552901543490.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络性能指标&quot;&gt;&lt;a href=&quot;#网络性能指标&quot; class=&quot;headerlink&quot; title=&quot;网络性能指标&quot;&gt;&lt;/a&gt;网络性能指标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;带宽&lt;/p&gt;
&lt;p&gt;表示链路的最大传输速率，单位是 b/s （ 比特 / 秒 ) 。常见的带宽有 1000M、10G、40G、100G 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;吞吐量&lt;/p&gt;
&lt;p&gt;表示没有丢包时的最大数据传输速率，单位通常是 b/s （ 比特 / 秒 )  或者 B/s ( 字节 / 秒 ) 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;延时&lt;/p&gt;
&lt;p&gt;表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PPS ( Packet Per Second )&lt;br&gt;表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 206. Reverse Linked List</title>
    <link href="http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/"/>
    <id>http://yoursite.com/2019/02/26/leetcode-206-reverse-linked-list/</id>
    <published>2019-02-26T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:14.642Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>单链表反转</p><p>题目来源：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/?</p><p>代码效率：100%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>迭代法：将当前节点的后继节点指向前一个节点，移动当前节点</p><p>递归法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Nonesense"><a href="#Nonesense" class="headerlink" title="Nonesense"></a>Nonesense</h3><p>最简单的单链表居然花费了我半天的时间，最后还是参考别人的答案才写出来。。。智商捉急</p><p>总结一下问题：</p><ul><li>太急躁，要静下心来慢慢梳理过程，整理成代码输出</li><li><strong>java变量指针等概念感觉还是不清晰</strong>，今天抽空需要补一下</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;单链表反转&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 448 Find All Numbers Disappeared in an Array</title>
    <link href="http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/"/>
    <id>http://yoursite.com/2019/02/24/leetcode-448-find-all-numbers-disappeared-in-an-array/</id>
    <published>2019-02-24T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:03.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：</p><p>题目来源：<a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/N</p><p>代码效率： 95.58%</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>取负法：不管一个元素出现一次还是两次，只要出现它对应的位置就会被取负。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[val] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            nums[val] = -nums[val];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>感觉这个题就是单纯考虑数学技巧，做起来比较吃力，看答案的时候豁然开朗，还是慢慢积累吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个长度为N整形数组，元素取值 范围从1到N，其中有可能有重复出现两次的元素，找出丢失的元素：&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 283 Move Zeroes</title>
    <link href="http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/"/>
    <id>http://yoursite.com/2019/02/23/leetcode-283-move-zeroes/</id>
    <published>2019-02-23T13:44:24.000Z</published>
    <updated>2019-03-27T03:50:41.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变</p><p>题目来源：<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一个快指针，一个慢指针，快指针指向不为0的元素，快慢指针值交换，同时向后移动一位。这样可以保证下面两个条件：</p><ul><li>快慢指针之间的元素都是0</li><li>慢指针之前的元素都不为0<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>一开始理解错误，以为把0都放到后面之后还是要对前面从大到小进行排序。。。结果想了半天</p><p>以后还是要仔细审题，不要怀疑自己，先用自己的想法暴力实现</p><p>写代码之前可以举个栗子来一步一步推敲，想好边界和规律再写代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个整形数组，将0都移动到最后，保持其他数组相对位置不变&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 136. Single Number</title>
    <link href="http://yoursite.com/2019/02/22/leetcode-136-single-number/"/>
    <id>http://yoursite.com/2019/02/22/leetcode-136-single-number/</id>
    <published>2019-02-22T13:44:24.000Z</published>
    <updated>2019-03-27T03:42:43.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。</p><p>题目来源：<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/N</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用异或 <code>^</code></p><ul><li>两个相同的数异或后为0</li><li>0和一个数异或后为那个数</li><li>异或运算满足交换律</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class="line">            result^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定一个非空数组，除了唯一个单独的元素外，每个元素出现两次。找出这个单独的元素。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 226. Invert Binary Tree</title>
    <link href="http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/"/>
    <id>http://yoursite.com/2019/02/21/leetcode-226-invert-binary-tree/</id>
    <published>2019-02-21T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:11.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>反转二叉树左右子树</p><p>题目来源：<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/ N</p><p>代码效率：100.00%</p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>左子树和右子树递归互换</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = invertTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>对递归还是理解不透彻，总结一下如何处理递归问题：</p><blockquote><p>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;反转二叉树左右子树&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/invert-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/invert-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 104. Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/"/>
    <id>http://yoursite.com/2019/02/20/leetcode-104-maximum-depth-of-binary-tree/</id>
    <published>2019-02-20T13:44:24.000Z</published>
    <updated>2019-03-27T02:35:02.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>计算二叉树的深度</p><p>题目来源：<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：思路很乱，参考 Discuss 的答案</p><p>代码效率：100.00%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>递归左右子树，对深度最大的子树进行递归调用并+1</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;计算二叉树的深度&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/maximum-depth-of-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-depth-of-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 617 Merge Two Binary Trees</title>
    <link href="http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/"/>
    <id>http://yoursite.com/2019/02/19/leetcode-617-merge-two-binary-trees/</id>
    <published>2019-02-19T13:44:24.000Z</published>
    <updated>2019-03-27T02:38:36.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。</p><p>题目来源：<a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-binary-trees/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/1</p><p>代码效率：98.24%</p><p>耗时：25分钟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>主要考察对递归算法的理解。</p><ul><li>首先考虑边界，如果两个子二叉树都为空，则新的二叉树必定为空</li><li>考虑其中一个子二叉树为空，则新的二叉树直接等于另外一个子二叉树</li><li>如果两个子二叉树都不为空，新二叉树节点值为两个子二叉树对应节点的值的和，同时对两个子二叉树的左右子树进行递归调用，仔细想想就明白了</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        TreeNode ret;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 != <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="keyword">null</span> &amp;&amp; t2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ret = t2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">            ret.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">            ret.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然别人思路的总是最好的 o(╥﹏╥)o</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    TreeNode result = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    result.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    result.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>学习数据结构的时候，总感觉递归对自己来说是弱项，智商不够用。今天居然一次性直接做出来了。学习数据结构和算法真的能培养思维逻辑和解决问题的能力。fighting !!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;合并两个给定的子二叉树，新的二叉树每个节点是两个二叉树对应节点的和，如果某一个二叉树的节点不存在，则取另外一个二叉树对应节点的值作为新的二叉树对应节点的值。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-two-binary-trees/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 461 Hamming Distance</title>
    <link href="http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/"/>
    <id>http://yoursite.com/2019/02/18/leetcode-461-hamming-distance/</id>
    <published>2019-02-18T13:44:24.000Z</published>
    <updated>2019-03-27T02:33:58.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>统计两个整数转换成二进制位时位数不同的个数。</p><p>题目来源：<a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/hamming-distance/</a></p><p>标记难度：Easy<br><a id="more"></a><br>提交次数：1/2 (少写了 return 语句。。)</p><p>代码效率：91.77%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>二进制的每一位的值不是 0 就是 1，就是整数除以 2 取余的结果，判断是否相等。然后再取模（相当于向左移动一位），再取余作比较。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span> || y != <span class="number">0</span>)&#123;</span><br><span class="line">            i = x % <span class="number">2</span>;</span><br><span class="line">            j = y % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">            y = y / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人的一行代码实现Orz：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;统计两个整数转换成二进制位时位数不同的个数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/hamming-distance/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 771 Jewels And Stones</title>
    <link href="http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/"/>
    <id>http://yoursite.com/2019/02/17/leetcode-771-jewels-and-stones/</id>
    <published>2019-02-17T13:44:24.000Z</published>
    <updated>2019-03-27T02:34:44.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。</p><p>题目来源：<a href="https://leetcode.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode.com/problems/jewels-and-stones/</a></p><p>标记难度：Easy<br><a id="more"></a></p><p>提交次数：1/4</p><p>代码效率：93.10%</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>把 J 和S 转换成字符数组，遍历 J 数组中的字符是否等于 S 中的 字符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charJ = J.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charS = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> <span class="keyword">var</span> : charJ)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;charS.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">var</span> == charS[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>别人还有更好的做法：</p><ul><li>遍历 J 把字符放入 set 集合</li><li>遍历 S 字符是否出现在 set 中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Set setJ = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> j: J.toCharArray()) setJ.add(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> s: S.toCharArray()) <span class="keyword">if</span> (setJ.contains(s)) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="一些废话"><a href="#一些废话" class="headerlink" title="一些废话"></a>一些废话</h3><p>第一次开始刷 Leetcode ,虽然做的是 easy 的题目，但还是没有参考其他人的答案自己完成了。开始有一点新鲜感和成就感了，希望可以坚持下去。</p><p>刚开始刷题使用的是 VS CODE 码代码，在网上看了一些网友的建议，为了应对后续面试可能要求手写编程的情况，所以现在是先用 IDE 把代码写出来，再手写输入 Leetcode 提交答案。</p><p>加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给定两个字符串 J 和 S，找出 J 中的字母出现在 S 中的次数。&lt;/p&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode.com/problems/jewels-and-stones/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/jewels-and-stones/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标记难度：Easy&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Tips</title>
    <link href="http://yoursite.com/2019/02/15/Leetcode-tips/"/>
    <id>http://yoursite.com/2019/02/15/Leetcode-tips/</id>
    <published>2019-02-15T13:44:24.000Z</published>
    <updated>2019-03-26T14:25:07.820Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。</p><p>数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：<br><a id="more"></a></p><ul><li><p>数据结构与算法之美</p><p>极客时间的一个专栏，内容通俗易懂，适合入门</p></li><li><p>数据结构与算法分析：Java语言描述</p><p>下一步打算看的书籍</p></li><li><p>经典大作：算法，算法导论</p></li></ul><p>附数据结构与算法之美推荐书单：<br><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407333793.png" alt></p><h3 id="Leetcode-刷题方法"><a href="#Leetcode-刷题方法" class="headerlink" title="Leetcode 刷题方法"></a>Leetcode 刷题方法</h3><p>在刚开始刷 Leetcode 时，很多人只有在看完答案才知道要怎么做，如果不看答案的话完全没有思路。这是非常正常的现象，并不表示你的思维能力比别人差。人类最擅长的学习方式是模仿，刚开始刷题的时候不会做看看别人怎么做是很正确的做法，模仿多了自然就会做了。</p><p>刷 Leetcode 也有两种流派：龟派和兔派。龟派每道题都要想很久，而且尽可能想出多种解法。兔派是想一会儿就看答案，这样就可以很快地刷题。龟派比较适合思维锻炼，而兔派比较适合短期内快速提高并记忆。如果是为了应对校招的话，比较推荐兔派这种刷题方法，因为校招确实很依赖于短期记忆。选择兔派这种方式的话，就需要反复地进行复习，从而保持记忆并增加理解。但是也不能完全采用兔派这种方法，因为如果习惯于不去思考怎么做的话，会养成惰性的思维方式。</p><p>当你刷题到一定程度的时候，最好每天再刷一两题保持题感。可以选你之前做过的题目，因为你再做一遍的话可以很快做出来，这样子就可以让你对刷题这件事保持积极的一种心态。</p><p>刷 Leetcode 的收益如下图所示，可以看到刷的越多收益增长的越小。刷 200 题就足够应对大多数互联网公司的校招，但是如果时间不够的话刷 100 题也是有很大的收益，可以刷一下 <a href="https://leetcode.com/problemset/top-100-liked-questions/" target="_blank" rel="noopener">Top 100 Liked Questions</a>。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1550407398105.png" alt></p><ul><li>排序：大部分要求能手写，并分析时间空间复杂度，以及稳定性</li><li>树：红黑树的原理以及在 JDK 的使用；B+ 树以及在数据库索引中的使用</li><li>图：拓扑排序；并查集；最短路径；最小生成树</li><li>散列表：实现原理，以及在 JDK 中的使用</li><li>字符串：KMP；AC 自动机；Trie 树</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构和算法是编程中很重要的一部分，学习了这些知识之后，对解题思路有很大的帮助。&lt;/p&gt;
&lt;p&gt;数据结构和算法也是其他技术的实现基础，要理解这些技术的实现原理就必须学习数据结构和算法。推荐学习书籍：&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 13 Summary. Linear Sorting</title>
    <link href="http://yoursite.com/2019/02/03/beauty-of-algorithms-13-summary-linear-sorting/"/>
    <id>http://yoursite.com/2019/02/03/beauty-of-algorithms-13-summary-linear-sorting/</id>
    <published>2019-02-02T16:45:30.000Z</published>
    <updated>2019-03-27T16:55:56.777Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线性排序的概念</strong></p><p>线性排序算法包括桶排序、计数排序、基数排序。</p><p>线性排序算法的时间复杂度为O(n)。<br><a id="more"></a><br><strong>线性排序的特点</strong></p><p>此3种排序算法都不涉及元素之间的比较操作，是非基于比较的排序算法。</p><p>对排序数据的要求很苛刻，重点掌握此3种排序算法的适用场景。</p><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p><strong>算法原理</strong></p><ul><li>将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行快速排序</li><li>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176304232.png" alt></p><p><strong>使用条件</strong></p><ul><li>要排序的数据需要很容易就能划分成m个桶，并且桶与桶之间有着天然的大小顺序</li><li>数据在各个桶之间分布是均匀的</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序 </span></span><br><span class="line"><span class="comment"> * BucketSort</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buckets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">//声明成绩在1-10范围的10个桶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> range,<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buckets = <span class="keyword">new</span> <span class="keyword">int</span>[range];</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array!=<span class="keyword">null</span> &amp;&amp; array.length &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                buckets[array[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buckets[i]; j++) &#123;</span><br><span class="line">                System.out.print(i +<span class="string">" \t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        BucketSort bucketSort = <span class="keyword">new</span> BucketSort(<span class="number">10</span>, array);</span><br><span class="line">        bucketSort.sort()</span><br><span class="line">        bucketSort.sortOut();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>适用场景</strong></p><ul><li>桶排序比较适合用在外部排序中</li><li>外部排序就是数据存储在外部磁盘且数据量大，但内存有限无法将整个数据全部加载到内存中</li></ul><h5 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h5><ul><li><p>需求描述</p><p>有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序，但内存有限，仅几百MB</p></li><li><p>解决思路</p><ul><li>扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶</li><li>第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推</li><li>每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）</li><li>将100个小文件依次放入内存并用快排排序</li><li>所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可</li></ul></li><li><p>若单个文件无法全部载入内存，则针对该文件继续细分数据过多的部分，按照前面的思路进行处理</p></li></ul><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><strong>算法原理</strong></p><ul><li>计数其实就是桶排序的一种特殊情况</li><li>当要排序的n个数据所处范围并不大时，比如最大值为k，则分成k个桶</li><li>每个桶内的数据值都是相同的，就省掉了桶内排序的时间</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组 c，下标大小 [0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入 c 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 临时数组 r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 将结果拷贝给 a 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>案例分析</strong></p><p>假设只有8个考生分数在0-5分之间，成绩存于数组A[8] = [2，5，3，0，2，3，0，3]。</p><p>使用大小为6的数组C[6]表示桶，下标对应分数，即0，1，2，3，4，5。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176782867.png" alt></p><p>C[6]存储的是考生人数，只需遍历一边考生分数，就可以得到C[6] = [2，0，2，3，0，1]。</p><p>对C[6]数组顺序求和则C[6]=[2，2，4，7，7，8]，c[k]存储的是小于等于分数k的考生个数。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176821302.png" alt></p><p>数组R[8] = [0，0，2，2，3，3，3，5]存储考生名次。那么如何得到R[8]的呢？</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176877893.png" alt></p><p>从后到前依次扫描数组A，比如扫描到3时，可以从数组C中取出下标为3的值7，也就是说，到目前为止，包括自己在内，分数小于等于3的考生有7个，也就是说3是数组R的第7个元素（也就是数组R中下标为6的位置）。</p><p>当3放入数组R后，小于等于3的元素就剩下6个了，相应的C[3]要减1变成6。</p><p>以此类推，当扫描到第二个分数为3的考生时，就会把它放入数组R中第6个元素的位置（也就是下标为5的位置）。当扫描完数组A后，数组R内的数据就是按照分数从小到大排列的了。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549176950926.png" alt></p><p><strong>使用条件</strong></p><ul><li>只能用在数据范围不大的场景中，若数据范围k比要排序的数据n大很多，就不适合用计数排序</li><li>计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数</li><li>比如如果考试成绩精确到小数后一位，就需要将所有分数乘以10，转换为整数</li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><strong>算法原理</strong></p><p>以排序10万个手机号为例来说明</p><ul><li>比较两个手机号码a，b的大小，如果在前面几位中a已经比b大了，那后面几位就不用看了借助稳定排序算法的思想，可以先按照最后一位来排序手机号码，然后再按照倒数第二位来重新排序，以此类推，最后按照第一个位重新排序</li><li>经过11次排序后，手机号码就变为有序的了</li><li>每次排序有序数据范围较小，可以使用桶排序或计数排序来完成</li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549177032618.png" alt></p><p><strong>使用条件</strong></p><ul><li>要求数据可以分割独立的“位”来比较</li><li>位之间由递进关系，如果a数据的高位比b数据大，那么剩下的地位就不用比较了</li><li>每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线性排序的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线性排序算法包括桶排序、计数排序、基数排序。&lt;/p&gt;
&lt;p&gt;线性排序算法的时间复杂度为O(n)。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LinearSorting" scheme="http://yoursite.com/tags/LinearSorting/"/>
    
      <category term="线性排序" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 12 Summary. Sorting 2</title>
    <link href="http://yoursite.com/2019/02/02/beauty-of-algorithms-12-summary-sorting-2/"/>
    <id>http://yoursite.com/2019/02/02/beauty-of-algorithms-12-summary-sorting-2/</id>
    <published>2019-02-01T16:45:30.000Z</published>
    <updated>2019-03-27T16:49:05.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h3><p>分治，顾明思意就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。</p><p><strong>分治与递归的区别</strong></p><p>分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。<br><a id="more"></a></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><strong>算法原理</strong></h4><p><strong>归并的思想</strong></p><p>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。</p><p>这就是归并排序的核心思想。如何用递归实现归并排序呢？</p><p>写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549120088746.png" alt></p><p><strong>递推公式</strong></p><p>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</p><p><strong>终止条件</strong></p><p>p = r 不用再继续分解</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>使用哨兵可以简化代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">            merge(a, begin, mid);</span><br><span class="line">            merge(a, mid + <span class="number">1</span>, end);</span><br><span class="line">            mergeAndSort(a, begin, mid, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeAndSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[mid - begin + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[end - mid + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">                left[i - begin] = a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right[i - mid - <span class="number">1</span>] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left[mid - begin + <span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line">        right[end - mid] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = begin;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= end) &#123;</span><br><span class="line">            a[index++] = left[i] &lt; right[j] ? left[i++] : right[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">24</span>&#125;;</span><br><span class="line">        merge(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="comment">//打印结果为：[1, 3, 4, 5, 6, 7, 8, 9, 11, 24]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>算法稳定性</strong></p><p>归并排序是一种稳定排序算法。</p><p><strong>时间复杂度</strong></p><p>归并排序的时间复杂度是O(nlogn)。</p><p><strong>空间复杂度</strong></p><p>归并排序算法不是原地排序算法，空间复杂度是O(n)</p><p>因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>一般情况下，快速排序被认为是最快的排序算法（人如其名啊），因此可以说是最常用的排序算法，并受大多数公司的青睐，是一定要熟练掌握的。</p><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><p><strong>快排的思想</strong></p><p>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot（分区点）。然后遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将povit放到中间。</p><p>经过这一步之后，数组p到r之间的数据就分成了3部分，前面p到q-1之间都是小于povit的，中间是povit，后面的q+1到r之间是大于povit的。</p><p>根据分治、递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549121842206.png" alt></p><p><strong>递推公式</strong></p><p>quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</p><p><strong>终止条件</strong></p><p>p &gt;= r</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>左右两个指针分别向左向右移动，取最后一位做临界值，左边遇到比这个值大的，就交换，换反方向指针比较，遇到比这个值小的，再次交换。</p><p><a href="https://huntfor.iteye.com/blog/2026625" target="_blank" rel="noopener">参考这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt;= begin) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = begin;</span><br><span class="line">        <span class="keyword">int</span> j = end;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[end];</span><br><span class="line">        <span class="keyword">boolean</span> tag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &lt;= tmp) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[j] = a[i];</span><br><span class="line">                    j--;</span><br><span class="line">                    tag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt;= tmp) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    i++;</span><br><span class="line">                    tag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = tmp;</span><br><span class="line">        quickSort(a, begin, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">125</span>, <span class="number">6</span>, <span class="number">41</span>, <span class="number">341</span>, <span class="number">34</span>, <span class="number">63</span>, <span class="number">28</span>, <span class="number">97</span>&#125;;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>算法稳定性</strong></p><p>快速排序是不稳定的排序算法。</p><p><strong>时间复杂度</strong></p><p>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，</p><p>那快排的时间复杂度递推求解公式跟归并的相同。快排的时间复杂度也是O(nlogn)。</p><p>如果数组中的元素原来已经有序了，快排的时间复杂度就是O(n^2)。</p><p>前面两种情况，一个是分区及其均衡，一个是分区极不均衡，</p><p>它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。</p><p>T(n)大部分情况下是O(nlogn)，只有在极端情况下才是退化到O(n^2)。</p><p><strong>空间复杂度</strong></p><p>快排是一种原地排序算法，空间复杂度是O(1)</p><h3 id="归并排序与快速排序的区别"><a href="#归并排序与快速排序的区别" class="headerlink" title="归并排序与快速排序的区别"></a>归并排序与快速排序的区别</h3><p><strong>归并排序</strong></p><p>先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。</p><p>何为自下而上？就是先解决子问题，再解决父问题。</p><p><strong>快速排序</strong></p><p>先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。</p><p>何为自上而下？就是先解决父问题，再解决子问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分治思想&quot;&gt;&lt;a href=&quot;#分治思想&quot; class=&quot;headerlink&quot; title=&quot;分治思想&quot;&gt;&lt;/a&gt;分治思想&lt;/h3&gt;&lt;p&gt;分治，顾明思意就是分而治之，将一个大问题分解成小的子问题来解决，小的子问题解决了，大问题也就解决了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分治与递归的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治算法一般都用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="MergeSorting" scheme="http://yoursite.com/tags/MergeSorting/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 11 Summary. Sorting 1</title>
    <link href="http://yoursite.com/2019/02/01/beauty-of-algorithms-11-summary-sorting-1/"/>
    <id>http://yoursite.com/2019/02/01/beauty-of-algorithms-11-summary-sorting-1/</id>
    <published>2019-01-31T16:40:05.000Z</published>
    <updated>2019-03-27T16:45:07.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><p>冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。<br><a id="more"></a></p><h3 id="复杂度归类"><a href="#复杂度归类" class="headerlink" title="复杂度归类"></a>复杂度归类</h3><p>冒泡排序、插入排序、选择排序 O(n^2)</p><p>快速排序、归并排序 O(nlogn)</p><p>计数排序、基数排序、桶排序 O(n)</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549118055203.png" alt></p><h3 id="算法的执行效率"><a href="#算法的执行效率" class="headerlink" title="算法的执行效率"></a>算法的执行效率</h3><ul><li>最好、最坏、平均情况时间复杂度</li><li>时间复杂度的系数、常数和低阶</li><li>比较次数，交换（或移动）次数</li></ul><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a><strong>排序算法的稳定性</strong></h3><p><strong>稳定性概念</strong></p><p>如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p><strong>稳定性重要性</strong></p><p>可针对对象的多种属性进行有优先级的排序。</p><p><strong>排序算法的内存损耗</strong></p><p>原地排序算法：特指空间复杂度是O(1)的排序算法。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换。</p><p><strong>稳定性</strong></p><p>冒泡排序是稳定的排序算法。</p><p><strong>空间复杂度</strong></p><p>冒泡排序是原地排序算法。</p><p><strong>时间复杂度</strong></p><p>最好情况：O(n)。</p><p>最坏情况：O(n^2)。</p><p>平均情况：平均时间复杂度为O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = num.length;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; !isSorted; i--) &#123;</span><br><span class="line">            isSorted=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;i ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(num[j+<span class="number">1</span>],num[j]))&#123;</span><br><span class="line">                    isSorted=<span class="keyword">false</span>;</span><br><span class="line">                    swap(num,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序将数组数据分成已排序区间和未排序区间。初始已排序区间只有一个元素，即数组第一个元素。</p><p>在未排序区间取出一个元素插入到已排序区间的合适位置，直到未排序区间为空。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549118736604.png" alt></p><p><strong>稳定性</strong></p><p>插入排序是稳定的排序算法。</p><p><strong>空间复杂度</strong></p><p>插入排序是原地排序算法。</p><p><strong>时间复杂度</strong></p><p>\1. 最好情况：O(n)。</p><p>\2. 最坏情况：O(n^2)。</p><p>\3. 平均情况：O(n^2)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = num.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(num[j], num[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">            swap(num, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序将数组分成已排序区间和未排序区间。初始已排序区间为空。</p><p>每次从未排序区间中选出最小的元素插入已排序区间的末尾，直到未排序区间为空。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549118907766.png" alt></p><p><strong>稳定性</strong></p><p>选择排序不是稳定的排序算法。</p><p><strong>空间复杂度</strong></p><p>选择排序是原地排序算法。</p><p><strong>时间复杂度</strong></p><p>都是O(n^2)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min])) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><strong>冒泡排序和插入排序的时间复杂度相同都是O(n^2)，为什么插入排序比冒泡排序更受欢迎？</strong></p><p><a href="https://www.cnblogs.com/yeguo/archive/2013/05/14/3078202.html" target="_blank" rel="noopener">参考这里</a></p><ul><li>对于部分有序的小区间 N，冒泡排序需要排序 N次，而插入排序效率更高</li><li>对于冒泡排序可以改进（参考代码），如果循环完没有做任何交换，说明已经是有序的</li></ul><p><strong>如果数据存储在链表中，三种排序方法的时间复杂会变成怎样？</strong></p><p>假定只能改变节点位置</p><p>冒泡排序，比较次数不变，因为指针，交换数据更加复杂。</p><p>插入排序，比较次数不变，但可以直接插入数据，不需要一个个地后移数据。</p><p>选择排序，比较次数不变，因为指针，交换数据更加复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序方法&quot;&gt;&lt;a href=&quot;#排序方法&quot; class=&quot;headerlink&quot; title=&quot;排序方法&quot;&gt;&lt;/a&gt;排序方法&lt;/h3&gt;&lt;p&gt;冒泡排序、插入排序、选择排序、快速排序、归并排序、计数排序、基数排序、桶排序。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Sorting" scheme="http://yoursite.com/tags/Sorting/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 10 Summary. Recursion</title>
    <link href="http://yoursite.com/2019/01/31/beauty-of-algorithms-10-summary-recursion/"/>
    <id>http://yoursite.com/2019/01/31/beauty-of-algorithms-10-summary-recursion/</id>
    <published>2019-01-31T13:44:24.000Z</published>
    <updated>2019-03-27T16:41:52.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h4><p>递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法。</p><p>比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。</p><p>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。</p><p>基本上，所有的递归问题都可以用递推公式来表示，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n-1) + 1;</span><br><span class="line">f(n) = f(n-1) + f(n-2);</span><br><span class="line">f(n)=n*f(n-1);</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="递归需要满足三个条件"><a href="#递归需要满足三个条件" class="headerlink" title="递归需要满足三个条件"></a>递归需要满足三个条件</h4><ul><li>一个问题的解可以分解为几个子问题的解。</li><li>问题与分解后的子问题除了数据规模不同，求解思路完全相同。</li><li>存在递归终止条件。</li></ul><h4 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h4><ul><li><p>优点</p><p>代码的表达力很强，写起来简洁。</p></li><li><p>缺点</p><p>空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</p></li></ul><h3 id="实现递归"><a href="#实现递归" class="headerlink" title="实现递归"></a>实现递归</h3><h4 id="递归代码的编写"><a href="#递归代码的编写" class="headerlink" title="递归代码的编写"></a>递归代码的编写</h4><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><h4 id="递归代码理解"><a href="#递归代码理解" class="headerlink" title="递归代码理解"></a>递归代码理解</h4><p>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。</p><p>那该如何理解递归代码呢？如果一个问题A可以分解为若干个子问题B、C、D，你可以假设子问题B、C、D已经解决。而且，你只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><p>因此，理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p><h4 id="递归的常见问题及解决方案"><a href="#递归的常见问题及解决方案" class="headerlink" title="递归的常见问题及解决方案"></a>递归的常见问题及解决方案</h4><ul><li>警惕堆栈溢出，可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。</li><li>警惕重复计算通过某种数据结构来保存已经求解过的值，从而避免重复计算。</li></ul><h3 id="递归改写为非递归代码"><a href="#递归改写为非递归代码" class="headerlink" title="递归改写为非递归代码"></a>递归改写为非递归代码</h3><p>笼统的讲，所有的递归代码都可以改写为迭代循环的非递归写法。</p><p>抽象出递推公式、初始值和边界条件，然后用迭代循环实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;递归的概念&quot;&gt;&lt;a href=&quot;#递归的概念&quot; class=&quot;headerlink&quot; title=&quot;递归的概念&quot;&gt;&lt;/a&gt;递归的概念&lt;/h4&gt;&lt;p&gt;递归是一种非常高效、简洁的编码技巧，一种应用非常广泛的算法。&lt;/p&gt;
&lt;p&gt;比如DFS深度优先搜索、前中后序二叉树遍历等都是使用递归。&lt;/p&gt;
&lt;p&gt;方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。&lt;/p&gt;
&lt;p&gt;基本上，所有的递归问题都可以用递推公式来表示，比如&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;f(n) = f(n-1) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f(n) = f(n-1) + f(n-2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f(n)=n*f(n-1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 9 Summary. Queue</title>
    <link href="http://yoursite.com/2019/01/30/beauty-of-algorithms-9-summary-queue/"/>
    <id>http://yoursite.com/2019/01/30/beauty-of-algorithms-9-summary-queue/</id>
    <published>2019-01-30T13:44:24.000Z</published>
    <updated>2019-03-27T16:41:46.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列的概念"><a href="#队列的概念" class="headerlink" title="队列的概念"></a>队列的概念</h3><ul><li>先进者先出</li><li>支持两个操作：入队 enqueue()，放一个数据到队尾；出队 dequeue()，从队头取一个元素。</li><li>队列也是一种操作受限的线性表<a id="more"></a><h3 id="数组实现-顺序队列"><a href="#数组实现-顺序队列" class="headerlink" title="数组实现 ( 顺序队列 )"></a>数组实现 ( 顺序队列 )</h3></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549012005547.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String item)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is full , cant enter any more !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            System.out.print(items[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ArrayQueue arrayQueue = <span class="keyword">new</span> ArrayQueue(<span class="number">10</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"1"</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"4"</span>);</span><br><span class="line">        arrayQueue.enqueue(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">        arrayQueue.printQueue();</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">        System.out.println(arrayQueue.dequeue());</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line"></span><br><span class="line">        arrayQueue.printQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="假溢出"><a href="#假溢出" class="headerlink" title="假溢出"></a>假溢出</h5><p>以上代码中的出队入队会造成假溢出现象，即随着不断的出队，head在增加，head前面的数组空间是被空着的。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549013381451.png" alt></p><p>修改入队方法</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549013411333.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue2</span><span class="params">(String item)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is full , cant enter any more !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            items[i - head] = items[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tail -= head;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549023779663.png" alt></p><p>链表无需考虑溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T data;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; tail;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(item, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.next = node;</span><br><span class="line">        tail = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Queue is empty, no element to dequeue !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T ret = head.data;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; tem = head;</span><br><span class="line">        <span class="keyword">while</span> (tem!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(tem.data + <span class="string">" "</span>);</span><br><span class="line">            tem = tem.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SingleLinkQueue&lt;String&gt; singleLinkQueue = <span class="keyword">new</span> SingleLinkQueue&lt;&gt;();</span><br><span class="line">        singleLinkQueue.enqueue(<span class="string">"1"</span>);</span><br><span class="line">        singleLinkQueue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        singleLinkQueue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        singleLinkQueue.enqueue(<span class="string">"4"</span>);</span><br><span class="line">        singleLinkQueue.printQueue();</span><br><span class="line">        System.out.println(<span class="string">"\n***************************"</span>);</span><br><span class="line">        System.out.println(singleLinkQueue.dequeue());</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">        singleLinkQueue.printQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环队列-基于数组"><a href="#循环队列-基于数组" class="headerlink" title="循环队列 ( 基于数组 )"></a>循环队列 ( 基于数组 )</h4><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1549024069106.png" alt></p><p>循环队列可以实现不进行数据搬移而解决假溢出现象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        items = <span class="keyword">new</span> String[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String item)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is full ,cant enqueue any more items !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i % n != tail; i++) &#123;</span><br><span class="line">            System.out.print(items[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CircularQueue circularQueue = <span class="keyword">new</span> CircularQueue(<span class="number">10</span>);</span><br><span class="line">        circularQueue.enqueue(<span class="string">"1"</span>);</span><br><span class="line">        circularQueue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        circularQueue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        circularQueue.enqueue(<span class="string">"4"</span>);</span><br><span class="line">        circularQueue.enqueue(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">        circularQueue.printQueue();</span><br><span class="line">        System.out.println(<span class="string">" "</span>);</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">        System.out.println(circularQueue.dequeue());</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line"></span><br><span class="line">        circularQueue.printQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的常见应用"><a href="#队列的常见应用" class="headerlink" title="队列的常见应用"></a>队列的常见应用</h3><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><ul><li><p>在队列的基础上增加阻塞操作，就成了阻塞队列。</p></li><li><p>阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；</p><p>如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。</p></li><li><p>从上面的定义可以看出这就是一个“生产者-消费者模型”。</p><p>这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。</p><p>当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，</p><p>这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。</p><p>不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，</p><p>比如配置几个消费者，来应对一个生产者。</p></li></ul><h4 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h4><ul><li>在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。</li><li>并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作</li><li>实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</li></ul><h4 id="线程池资源枯竭时的处理"><a href="#线程池资源枯竭时的处理" class="headerlink" title="线程池资源枯竭时的处理"></a>线程池资源枯竭时的处理</h4><p>在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如何实现无锁的并发队列？</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;队列的概念&quot;&gt;&lt;a href=&quot;#队列的概念&quot; class=&quot;headerlink&quot; title=&quot;队列的概念&quot;&gt;&lt;/a&gt;队列的概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;先进者先出&lt;/li&gt;
&lt;li&gt;支持两个操作：入队 enqueue()，放一个数据到队尾；出队 dequeue()，从队头取一个元素。&lt;/li&gt;
&lt;li&gt;队列也是一种操作受限的线性表
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 8 Summary. Stack</title>
    <link href="http://yoursite.com/2019/01/29/beauty-of-algorithms-8-summary-stack/"/>
    <id>http://yoursite.com/2019/01/29/beauty-of-algorithms-8-summary-stack/</id>
    <published>2019-01-29T13:44:24.000Z</published>
    <updated>2019-03-27T16:36:10.452Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><ul><li>后进者先出，先进者后出，这就是典型的 ”栈“ 结构</li><li>从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据<a id="more"></a></li></ul><h3 id="为什么需要栈"><a href="#为什么需要栈" class="headerlink" title="为什么需要栈"></a>为什么需要栈</h3><ul><li>栈是一种操作受限的数据结构，其操作特性用数组和链表均可实现。</li><li>但任何数据结构都是对特定应用场景的抽象，数组和链表虽然使用起来更加灵活，但却暴露了几乎所有的操作，难免会引发错误操作的风险。</li><li>所以，当某个数据集合只涉及在某端插入和删除数据，且满足后进者先出，先进者后出的操作特定时，我们应该首选栈这种数据结构。</li></ul><h3 id="如何实现栈"><a href="#如何实现栈" class="headerlink" title="如何实现栈"></a>如何实现栈</h3><h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><p>使用数组实现固定容量的栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> String[maxSize];</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == maxSize - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is full ,cant push anymore !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[count] = item;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Stack is empty, no element to pop !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String top = data[count-<span class="number">1</span>];</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.count-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ArrayStack arrayStack = <span class="keyword">new</span> ArrayStack(<span class="number">5</span>);</span><br><span class="line">        arrayStack.push(<span class="string">"1"</span>);</span><br><span class="line">        arrayStack.push(<span class="string">"2"</span>);</span><br><span class="line">        arrayStack.push(<span class="string">"3"</span>);</span><br><span class="line">        arrayStack.printStack();</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">        System.out.println(arrayStack.pop());</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">        arrayStack.printStack();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组实现自动扩容</strong></p><p>改进代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == maxSize) &#123;</span><br><span class="line">            maxSize = count * <span class="number">2</span>;</span><br><span class="line">            String[] tmp = data;</span><br><span class="line">            data = <span class="keyword">new</span> String[maxSize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;count ; i++) &#123;</span><br><span class="line">                data[i] = tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[count] = item;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p>单链表栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T data;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(t,top);</span><br><span class="line">        top = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Stack is empty, no element to pop !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; node = top;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">return</span> node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStack</span><span class="params">(Node&lt;T&gt; top)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(top.data);</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SingleLinkedStack&lt;String&gt; singleLinkedStack = <span class="keyword">new</span> SingleLinkedStack&lt;&gt;();</span><br><span class="line">        singleLinkedStack.push(<span class="string">"1"</span>);</span><br><span class="line">        singleLinkedStack.push(<span class="string">"2"</span>);</span><br><span class="line">        singleLinkedStack.push(<span class="string">"3"</span>);</span><br><span class="line">        singleLinkedStack.printStack(singleLinkedStack.top);</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">        System.out.println(singleLinkedStack.pop());</span><br><span class="line">        System.out.println(<span class="string">"***************************"</span>);</span><br><span class="line">        singleLinkedStack.printStack(singleLinkedStack.top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h4><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成 “栈” 这种结构，用来存储函数调用时的临时变量。</p><p>每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><h4 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h4><p>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。从左向右遍历表达式，当遇到数字，就直接压入操作数栈。当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈。若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。</p><h4 id="站在括号匹配中的应用"><a href="#站在括号匹配中的应用" class="headerlink" title="站在括号匹配中的应用"></a>站在括号匹配中的应用</h4><p>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时候，则将其压入栈</p><p>当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。</p><p>如果扫描过程中，遇到不能配对的右括号，或者占中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。</p><h3 id="实现浏览器的前进和后退功能"><a href="#实现浏览器的前进和后退功能" class="headerlink" title="实现浏览器的前进和后退功能"></a>实现浏览器的前进和后退功能</h3><p>我们使用两个栈 X 和 Y，我们把首次浏览的页面依次压入栈 X，Y。</p><p>当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入 Y 栈。</p><p>当点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。</p><p>当栈 X 中没有数据时，说明没有页面可以继续后退浏览了。</p><p>当 Y 栈没有数据，那就说明没有页面可以点击前进浏览了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是栈&quot;&gt;&lt;a href=&quot;#什么是栈&quot; class=&quot;headerlink&quot; title=&quot;什么是栈&quot;&gt;&lt;/a&gt;什么是栈&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;后进者先出，先进者后出，这就是典型的 ”栈“ 结构&lt;/li&gt;
&lt;li&gt;从栈的操作特性来看，是一种“操作受限”的线性表，只允许在端插入和删除数据
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 7 Summary. Array Or List</title>
    <link href="http://yoursite.com/2019/01/28/beauty-of-algorithms-7-summary-array-or-list/"/>
    <id>http://yoursite.com/2019/01/28/beauty-of-algorithms-7-summary-array-or-list/</id>
    <published>2019-01-28T13:44:24.000Z</published>
    <updated>2019-03-27T16:37:48.423Z</updated>
    
    <content type="html"><![CDATA[<p>数组和链表的总结和比较<br><a id="more"></a></p><h3 id="选择数组还是链表"><a href="#选择数组还是链表" class="headerlink" title="选择数组还是链表"></a>选择数组还是链表</h3><p><strong>插入、删除和随机访问的时间复杂度</strong></p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1548775027883.png" alt></p><p><strong>数组的缺点</strong></p><ul><li>若申请内存空间很大，比如 100 M ,但若内存空间没有 100 M 的连续空间是，则会申请失败，尽管内存可用空间超过 100 M 。</li><li>大小固定，若空间存储不足，需要进行扩容，一旦扩容就要进行数据复杂，而这是非常费时的。</li></ul><p><strong>链表的缺点</strong></p><ul><li>内存空间消耗更大，因为需要额外的空间存储指针信息。</li><li>对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，还可能会造成频繁的 GC (自动辣鸡回收器) 操作。</li></ul><p><strong>如何选择链表和数组</strong></p><p>数组简单易用，在实现上使用连续的内存空间，可以借助 CPU 的缓冲机制预读数组中的数据，所以访问效率更高。</p><p>而链表在内存中并不是连续存储的，所以为 CPU 缓存不友好，没办法预读。</p><p>如果代码对内存的使用非常苛刻，那数组就更适合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组和链表的总结和比较&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="List" scheme="http://yoursite.com/tags/List/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 6 Summary. Linked List</title>
    <link href="http://yoursite.com/2019/01/27/beauty-of-algorithms-6-summary-linked-list/"/>
    <id>http://yoursite.com/2019/01/27/beauty-of-algorithms-6-summary-linked-list/</id>
    <published>2019-01-27T13:44:24.000Z</published>
    <updated>2019-03-27T16:37:05.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h3><p>和数组一样，链表也是一种线性表</p><p>从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构</p><p>链表中的每一个内存块被称为节点 Node 。节点除了存储数据外，还需要记录链上下一个节点的地址，即后继指针 next。<br><a id="more"></a></p><h3 id="链表的特点"><a href="#链表的特点" class="headerlink" title="链表的特点"></a>链表的特点</h3><p>插入、删除数据效率高，时间复杂度为 O(1)，只需要更改指针指向即可。</p><p>随机访问效率低，时间复杂度为 O(n)，需要从链头至链尾进行遍历。</p><p>和数组相比，链表的内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。</p><h3 id="常见的链表结构"><a href="#常见的链表结构" class="headerlink" title="常见的链表结构"></a>常见的链表结构</h3><p><strong>单链表</strong></p><p>每个节点只包含一个指针，即后继指针。</p><p>单链表有两个特殊的节点，即首节点和尾节点。</p><p>用首节点地址表示整条链表，尾节点的后继指针指向空地址 null 。</p><p>性能特点，插入和删除节点的时间复杂度为O(1)，查找的时间复杂度为O(n)。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1548774058186.png" alt></p><p><strong>循环链表</strong></p><p>除了尾节点的后继指针指向首节点的地址外均与单链表一致。</p><p>适用于存储有循环特点的数据，比如约瑟夫问题。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1548774142269.png" alt></p><p><strong>双向链表</strong></p><p>节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针 prev ）和下一个节点地址（后继指针 next ）。</p><p>首节点的前驱指针 prev 和尾节点的后继指针 next均指向空地址。</p><p>性能特点，和单链表相比，存储相同的数据，需要消耗更多的存储空间。</p><p>插入、删除操作比单链表效率更高，时间复杂度为 O(1) 。以删除操作为例，删除操作分为两种情况</p><ul><li><p>给定数据值删除对应节点</p><p>单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为 O(n) 。</p></li><li><p>给定节点地址删除节点</p><p>要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历知道 p-&gt;next = q，时间复杂度为 O(n) ,而双向链表可以直接找到前驱节点，时间复杂度为 O(1) 。</p></li><li><p>和单链表相比的优势</p><p>对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次超找的位置 p ，每一次查询是，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p></li></ul><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1548774643697.png" alt></p><p><strong>双向循环链表</strong></p><p>首节点的前驱指针指向尾节点，为节点的后继指针指向首节点。</p><p><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1548774791134.png" alt></p><h3 id="常见的链表操作"><a href="#常见的链表操作" class="headerlink" title="常见的链表操作"></a>常见的链表操作</h3><ul><li><p>单链表反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">reverseNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = head.getNext();</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur.setNext(pre);</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    cur.setNext(pre);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>链表中环的检测</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCircleNodeList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.getNext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.getNext();</span><br><span class="line">        fast = fast.getNext().getNext();</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两个有序链表合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeNode</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    Node guard = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    Node cur = guard;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt;= head2.val) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head1.val &lt;= head2.val) &#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (head2 != <span class="keyword">null</span> &amp;&amp; head2.val &lt; head1.val) &#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur.next = head1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cur.next = head2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除链表倒数第 n 个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteLastK</span><span class="params">(Node head, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; <span class="number">1</span> || head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node guard = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    guard.next=head;</span><br><span class="line">    Node slow = guard;</span><br><span class="line">    Node fast = guard;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next!= <span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>求链表的中间节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">findMiddle</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是链表&quot;&gt;&lt;a href=&quot;#什么是链表&quot; class=&quot;headerlink&quot; title=&quot;什么是链表&quot;&gt;&lt;/a&gt;什么是链表&lt;/h3&gt;&lt;p&gt;和数组一样，链表也是一种线性表&lt;/p&gt;
&lt;p&gt;从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构&lt;/p&gt;
&lt;p&gt;链表中的每一个内存块被称为节点 Node 。节点除了存储数据外，还需要记录链上下一个节点的地址，即后继指针 next。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Beauty Of Algorithms 5 Summary. Array</title>
    <link href="http://yoursite.com/2019/01/26/beauty-of-algorithms-5-summary-array/"/>
    <id>http://yoursite.com/2019/01/26/beauty-of-algorithms-5-summary-array/</id>
    <published>2019-01-26T13:44:24.000Z</published>
    <updated>2019-03-27T16:37:35.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。<br><a id="more"></a><br><strong>线性表</strong></p><p>线性表就是数据排成像一条线一样的结构。</p><p>常见的线性表结构：数组、链表、队列、栈等。</p><p>非线性表有：二叉树、图、堆等。<br><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1548772496408.png" alt><br><img src="https://shinhwa-1258620884.cos.ap-beijing.myqcloud.com/image/1548772512085.png" alt><br><strong>连续的内存空间和相同类型的数据</strong></p><p>优点：两个限制使得具有随机访问的特性</p><p>缺点：删除，插入数据效率低</p><h3 id="数组如何根据下标随机访问"><a href="#数组如何根据下标随机访问" class="headerlink" title="数组如何根据下标随机访问"></a>数组如何根据下标随机访问</h3><p>通过寻址公式，计算出该元素存储的内存地址：</p><p>a[i]_address = base_address + i * data_type_size</p><h3 id="为何数组插入和删除低效"><a href="#为何数组插入和删除低效" class="headerlink" title="为何数组插入和删除低效"></a>为何数组插入和删除低效</h3><p><strong>插入</strong></p><p>若有一个元素想往 int[n] 的第 K 个位置插入数据，需要 n-k 的位置往后移</p><p>最好情况时间复杂度 O(1)，最坏情况复杂度是 O(n) ,平均时间复杂度为 O(n)</p><p>如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第 K 个位置上的数据移到最后，然后将插入的数据直接放在第 K 个位置上，这样时间复杂度就将为 O(1) 了</p><p><strong>删除</strong></p><p>与插入类似，为了保持内存的连续性</p><p>最好情况时间复杂度 O(1)，最坏情况复杂度是 O(n) ,平均时间复杂度为 O(n)</p><p><strong>提高删除效率的方法</strong></p><p>讲多次删除操作集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录。当发现没有更多空间存储时，在执行真正的删除操作。这也是 <strong>JVM 标记清理垃圾回收算法</strong>的核心思想</p><p><strong>数组访问越界问题</strong></p><p>C 语言中的数据越界是一种未决行为，一般比较难发现的逻辑错误。相比之下，Java 会有越界检查。</p><h3 id="用数组还是容器"><a href="#用数组还是容器" class="headerlink" title="用数组还是容器"></a>用数组还是容器</h3><p><strong>二者的特点</strong></p><p>数组现指定了空间大小</p><p>容器如 ArrayList 可以动态扩容</p><p><strong>使用数组的情形</strong></p><ul><li>希望存储基本类型数据，可以用数组</li><li>事先知道数组的大小，并且操作简单，可以用数组</li><li>直观表示多维，可以用数组</li><li>业务开发，使用容器足够，开发框架，追求性能，首选数组。</li></ul><h3 id="为什么数组要从-0-开始编号"><a href="#为什么数组要从-0-开始编号" class="headerlink" title="为什么数组要从 0 开始编号"></a>为什么数组要从 0 开始编号</h3><p>由于数组是通过寻址公式，计算出该元素存储的内存地址：</p><p>a[i]_address = base_address + i * data_type_size</p><p>如果数组是从 1 开始计数，那么就会变成：</p><p>a[i]_address = base_address + （i-1）* data_type_size</p><p>对于 CPU 来说，多了一次执行减法的指令</p><p>当然，还有一定的历史原因。C 语言从最开始就约定使用 0 开始编号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是数组&quot;&gt;&lt;a href=&quot;#什么是数组&quot; class=&quot;headerlink&quot; title=&quot;什么是数组&quot;&gt;&lt;/a&gt;什么是数组&lt;/h3&gt;&lt;p&gt;数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。&lt;br&gt;
    
    </summary>
    
      <category term="Alogorithms" scheme="http://yoursite.com/categories/Alogorithms/"/>
    
    
      <category term="Alogorithms" scheme="http://yoursite.com/tags/Alogorithms/"/>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
